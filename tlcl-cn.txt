                                                                                                                    快乐的Linux命令行
http://billie66.github.io/TLCL/
2019-10-252019/12/09
Contents
1引言17
1.1为什么使用命令行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.2这本书讲什么 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.3谁应该读这本书 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.4这本书的内容 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.5怎样阅读这本书 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.5.1前提条件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.6拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2什么是shell22
2.1终端仿真器 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.2第一次按键 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.3命令历史 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.4移动光标 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.5关于鼠标和光标 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.6试试运行一些简单命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.7结束终端会话 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.8幕后控制台 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.9拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3文件系统中跳转26
3.1理解文件系统树 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.2当前工作目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
3.3列出目录内容 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.4更改当前工作目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.5绝对路径 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
1
3.6相对路径 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.7有用的快捷键 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4探究操作系统32
4.1 ls乐趣 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
4.2选项和参数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.3深入研究长格式输出 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.4确定文件类型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
4.5用 less浏览文件内容 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.6 less就是 more（禅语：色即是空） . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.7旅行指南 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.8符号链接 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.9硬链接 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
4.10拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
5操作文件和目录43
5.1通配符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
5.2 mkdir -创建目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.3 cp -复制文件和目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.4有用的选项和实例 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.5 mv -移动和重命名文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.6有用的选项和实例 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
5.7 rm -删除文件和目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
5.8有用的选项和实例 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
5.9 ln—创建链接 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
5.10硬链接 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
5.11符号链接 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
5.12创建游戏场（实战演习） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
5.13创建目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
5.14移动和重命名文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
5.15创建硬链接 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
5.16创建符号链接 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
5.17移动文件和目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.18总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
2
6使用命令59
6.1到底什么是命令？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
6.2识别命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
6.3 type－显示命令的类型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
6.4 which－显示一个可执行程序的位置 . . . . . . . . . . . . . . . . . . . . . . . . . 60
6.5得到命令文档 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
6.6 help－得到 shell内建命令的帮助文档 . . . . . . . . . . . . . . . . . . . . . . . . 61
6.7 --help -显示用法信息 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
6.8 man－显示程序手册页 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
6.9 apropos－显示适当的命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
6.10 whatis－显示非常简洁的命令说明 . . . . . . . . . . . . . . . . . . . . . . . . . . 64
6.11 info－显示程序 Info条目 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
6.12 README和其它程序文档 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
6.13用别名（alias）创建你自己的命令 . . . . . . . . . . . . . . . . . . . . . . . . . . 65
6.14拜访老朋友 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
6.15拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
7重定向69
7.1标准输入、输出和错误 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
7.2标准输出重定向 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
7.3标准错误重定向 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
7.4重定向标准输出和错误到同一个文件 . . . . . . . . . . . . . . . . . . . . . . . . . 72
7.5处理不需要的输出 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
7.6标准输入重定向 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
7.7 cat－连接文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
7.8管道线 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
7.9过滤器 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
7.10 uniq -报道或忽略重复行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
7.11 wc－打印行数、字数和字节数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
7.12 grep－打印匹配行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
7.13 head / tail－打印文件开头部分/结尾部分 . . . . . . . . . . . . . . . . . . . . . . 78
7.14 tee－从 Stdin读取数据，并同时输出到 Stdout和文件 . . . . . . . . . . . . . . 79
7.15总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
3
8从shell眼中看世界81
8.1 (字符)展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
8.2路径名展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
8.3波浪线展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
8.4算术表达式展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
8.5花括号展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
8.6参数展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
8.7命令替换 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
8.8引用 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
8.9双引号 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
8.10单引号 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
8.11转义字符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
8.12总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
8.13拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
9键盘高级操作技巧93
9.1命令行编辑 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
9.2移动光标 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
9.3修改文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
9.4剪切和粘贴文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
9.5自动补全 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
9.6利用历史命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
9.7搜索历史命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
9.8历史命令展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
9.9总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
9.10拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
10权限102
10.1拥有者、组成员和其他人 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
10.2读取、写入和执行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
10.3 chmod－更改文件模式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
10.4借助 GUI来设置文件模式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
10.5 umask－设置默认权限 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
10.6更改身份 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
4
10.7 su－以其他用户身份和组 ID运行一个 shell . . . . . . . . . . . . . . . . . . . . . 113
10.8 sudo－以另一个用户身份执行命令 . . . . . . . . . . . . . . . . . . . . . . . . . . 114
10.9 chown－更改文件所有者和用户组 . . . . . . . . . . . . . . . . . . . . . . . . . . 116
10.10chgrp－更改用户组所有权 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
10.11练习使用权限 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
10.12更改用户密码 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
10.13拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
11进程122
11.1进程是怎样工作的 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
11.2查看进程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
11.3用 top命令动态查看进程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
11.4控制进程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
11.5中断一个进程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
11.6把一个进程放置到后台 (执行) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
11.7进程返回到前台 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
11.8停止一个进程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
11.9 Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
11.10通过 kill命令给进程发送信号 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
11.11通过 killall命令给多个进程发送信号 . . . . . . . . . . . . . . . . . . . . . . . . . 133
11.12更多和进程相关的命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
12shell环境135
12.1什么存储在环境变量中？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
12.2检查环境变量 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
12.3一些有趣的环境变量 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
12.4如何建立 shell环境？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
12.5一个启动文件的内容 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
12.6修改 shell环境 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
12.7我们应该修改哪个文件？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
12.8文本编辑器 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
12.9使用文本编辑器 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
12.10激活我们的修改 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
12.11总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
5
12.12拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
13vi简介147
13.1为什么我们应该学习 vi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
13.2一点儿背景介绍 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
13.3启动和退出 vi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
13.4编辑模式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
13.4.1插入模式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
13.4.2保存我们的工作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
13.5移动光标 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
13.6基本编辑 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
13.6.1追加文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
13.6.2打开一行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
13.6.3删除文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
13.6.4剪切，复制和粘贴文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
13.6.5连接行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
13.7查找和替换 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
13.7.1查找一行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
13.7.2查找整个文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
13.7.3全局查找和替代 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
13.8编辑多个文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
13.8.1文件之间切换 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
13.8.2打开另一个文件并编辑 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
13.8.3跨文件复制黏贴 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
13.8.4插入整个文件到另一个文件 . . . . . . . . . . . . . . . . . . . . . . . . . . 162
13.9保存工作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
13.10拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
14自定制shell提示符165
14.1解剖一个提示符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
14.2试试一些可替代的提示符设计 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
14.3添加颜色 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
14.4移动光标 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
14.5保存提示符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
6
14.6总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
14.7拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
15软件包管理173
15.1打包系统 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
15.2软件包管理系统是怎样工作的 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
15.3包文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
15.4资源库 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
15.5依赖性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
15.6上层和底层软件包工具 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
15.7常见软件包管理任务 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
15.8查找资源库中的软件包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
15.9从资源库中安装一个软件包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
15.10通过软件包文件来安装软件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
15.11卸载软件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
15.12经过资源库来更新软件包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
15.13经过软件包文件来升级软件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
15.14列出所安装的软件包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
15.15确定是否安装了一个软件包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
15.16显示所安装软件包的信息 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
15.17查找安装了某个文件的软件包 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
15.18总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
15.19拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
16存储媒介182
16.1挂载和卸载存储设备 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
16.2查看挂载的文件系统列表 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
16.3确定设备名称 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
16.4创建新的文件系统 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
16.5用 fdisk命令操作分区 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
16.6用 mkfs命令创建一个新的文件系统 . . . . . . . . . . . . . . . . . . . . . . . . . 193
16.7测试和修复文件系统 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
16.8格式化软盘 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
16.9直接把数据移入/出设备 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
7
16.10创建 CD-ROM映像 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
16.10.1创建一个 CD-ROM的映像拷贝 . . . . . . . . . . . . . . . . . . . . . . . . 197
16.10.2从文件集合中创建一个映像 . . . . . . . . . . . . . . . . . . . . . . . . . . 197
16.11写入 CD-ROM镜像 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
16.11.1直接挂载一个 ISO镜像 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
16.11.2清除一张可重写入的 CD-ROM . . . . . . . . . . . . . . . . . . . . . . . . 199
16.11.3写入镜像 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
16.12拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
16.13友情提示 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
17网络系统201
17.1检查和监测网络 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
17.1.1 ping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
17.1.2 traceroute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
17.1.3 netstat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
17.2网络中传输文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
17.2.1 ftp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
17.2.2 lftp -更好的 ftp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
17.2.3 wget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
17.3与远程主机安全通信 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
17.3.1 ssh . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
17.3.2 scp和 sftp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
17.4拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
18查找文件215
18.1 locate -查找文件的简单方法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
18.2 find -查找文件的复杂方式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
18.2.1 Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
18.2.2操作符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
18.3预定义的操作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
18.4用户定义的行为 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
18.5提高效率 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
18.5.1 xargs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
18.6返回操练场 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
8
18.6.1选项 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
18.7拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
19归档和备份232
19.1压缩文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
19.1.1 gzip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
19.1.2 bzip2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
19.2归档文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
19.2.1 tar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
19.2.2 zip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
19.3同步文件和目录 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
19.3.1在网络间使用 rsync命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
19.4拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
20正则表达式248
20.1 grep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
20.2元字符和原义字符 (Metacharacters And Literals) . . . . . . . . . . . . . . . . . . 250
20.3任何字符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
20.4锚点 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
20.5中括号表达式和字符类 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
20.6否定 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
20.7传统的字符区域 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
20.8 POSIX字符集 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
20.9 POSIX基本正则表达式与 POSIX扩展正则表达式 . . . . . . . . . . . . . . . . . 260
20.10交替 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
20.11限定符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
20.11.1? -匹配零个或一个元素 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
20.12* -匹配零个或多个元素 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
20.12.1+ -匹配一个或多个元素 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
20.12.2{ } -匹配特定个数的元素 . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
20.13让正则表达式工作起来 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
20.13.1通过 grep命令来验证一个电话簿 . . . . . . . . . . . . . . . . . . . . . . . 265
20.13.2用 find查找丑陋的文件名 . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
20.13.3用 locate查找文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
9
20.13.4在 less和 vim中查找文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
20.14总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
20.15拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
21文本处理271
21.1文本应用程序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
21.1.1文档 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
21.1.2网页 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
21.1.3电子邮件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
21.1.4打印输出 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
21.1.5程序源码 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
21.2回顾一些老朋友 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
21.2.1 cat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
21.2.2 sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
21.2.3 uniq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
21.3切片和切块 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
21.3.1 cut . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
21.3.2 paste . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
21.3.3 join . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
21.4比较文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
21.4.1 comm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
21.4.2 diff . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
21.4.3 patch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
21.5运行时编辑 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
21.5.1 tr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
21.5.2 sed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298
21.5.3 aspell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
21.6总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
21.7拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
21.8友情提示 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
22格式化输出312
22.1简单的格式化工具 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
22.1.1 nl -添加行号 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
10
22.1.2 fold -限制文件行宽 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
22.1.3 fmt -一个简单的文本格式器 . . . . . . . . . . . . . . . . . . . . . . . . . 316
22.1.4 pr–格式化打印文本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
22.1.5 printf–Format And Print Data . . . . . . . . . . . . . . . . . . . . . . . 319
22.2 Document Formatting Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
22.3文件格式化系统 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
22.3.1 groff . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
22.4 Summing Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
22.5小节 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
22.6 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
22.7阅读更多 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
23打印331
23.1打印简史 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
23.1.1早期的打印 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
23.1.2基于字符的打印机 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
23.1.3图形化打印机 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
23.2在 Linux下打印 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
23.3为打印准备文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
23.3.1 pr -转换需要打印的文本文件 . . . . . . . . . . . . . . . . . . . . . . . . . 334
23.4将打印任务送至打印机 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335
23.4.1 lpr -打印文件（Berkeley风格） . . . . . . . . . . . . . . . . . . . . . . . 335
23.4.2 lp -打印文件（System V风格） . . . . . . . . . . . . . . . . . . . . . . . 336
23.4.3另一种选择：a2ps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
23.5监视和控制打印任务 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
23.5.1 lpstat -显示打印系统状态 . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
23.5.2 lpq -显示打印机队列状态 . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
23.5.3 lprm和 cancel -取消打印任务 . . . . . . . . . . . . . . . . . . . . . . . . 341
24编译程序343
24.1什么是编译？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
24.1.1所有的程序都是可编译的吗？ . . . . . . . . . . . . . . . . . . . . . . . . . 344
24.2编译一个 C语言 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
24.2.1得到源码 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
11
24.3检查源码树 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
24.3.1构建程序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
24.3.2安装程序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353
24.4总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353
24.5拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354
25编写第一个Shell脚本355
25.1什么是 Shell脚本？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
25.2怎样编写一个 Shell脚本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
25.3脚本文件格式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 356
25.4可执行权限 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
25.5脚本文件位置 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
25.5.1脚本文件的好去处 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
25.6更多的格式技巧 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
25.6.1长选项名称 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
25.6.2缩进和行继续符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
25.7总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
25.8拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
26启动一个项目362
26.1第一阶段：最小的文档 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
26.2第二阶段：添加一点儿数据 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365
26.3变量和常量 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365
26.3.1给变量和常量赋值 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
26.4 Here Documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370
26.5总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
26.6拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
27自顶向下设计374
27.1 Shell函数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
27.2局部变量 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378
27.3保持脚本运行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
27.4总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
27.5拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
12
28流程控制：if分支结构384
28.1 if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384
28.2退出状态 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
28.3测试 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387
28.3.1文件表达式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387
28.3.2字符串表达式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390
28.3.3整型表达式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391
28.4更现代的测试版本 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 392
28.5 (( )) -为整数设计 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
28.6结合表达式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395
28.7控制操作符：分支的另一种方法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
28.8总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
28.9拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
29读取键盘输入400
29.1 read -从标准输入读取数值 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
29.1.1选项 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
29.2 IFS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405
29.3校正输入 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
29.4菜单 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
29.5总结归纳 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
29.5.1友情提示 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
29.6拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
30流程控制：while/until循环411
30.1循环 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
30.1.1 while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
30.2跳出循环 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414
30.2.1 until . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
30.3使用循环读取文件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
30.4总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
30.5拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
13
31疑难排解418
31.1语法错误 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
31.1.1丢失引号 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
31.1.2丢失或意外的标记 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419
31.1.3预料不到的展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
31.2逻辑错误 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 422
31.2.1防错编程 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 422
31.2.2验证输入 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
31.3测试 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
31.3.1测试案例 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
31.4调试 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
31.4.1找到问题区域 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
31.4.2追踪 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
31.4.3执行时检查数值 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
31.5总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430
31.6拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430
32流程控制：case分支431
32.1 case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
32.2模式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
32.3执行多个动作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
32.4总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
32.5拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
33位置参数438
33.1访问命令行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
33.1.1确定参数个数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
33.1.2 shift -访问多个参数的利器 . . . . . . . . . . . . . . . . . . . . . . . . . . 440
33.1.3简单应用 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
33.1.4 Shell函数中使用位置参数 . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
33.2处理集体位置参数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
33.3一个更复杂的应用 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
33.4总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
33.5拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
14
34流程控制：for循环453
34.1 for:传统 shell格式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 453
34.2 for: C语言格式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456
34.3总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
34.4拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459
35字符串和数字460
35.1参数展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460
35.1.1基本参数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460
35.1.2管理空变量的展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 461
35.2返回变量名的参数展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
35.2.1字符串展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
35.2.2大小写转换 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
35.3算术求值和展开 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
35.3.1数基 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
35.3.2一元运算符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
35.3.3简单算术 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470
35.3.4赋值运算符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 471
35.3.5位运算符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 473
35.3.6逻辑运算符 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 474
35.4 bc -一种高精度计算器语言 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
35.4.1使用 bc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
35.4.2一个脚本实例 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478
35.5总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
35.6额外加分 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480
35.7拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480
36数组481
36.1什么是数组？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 481
36.2创建一个数组 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 481
36.3数组赋值 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482
36.4访问数组元素 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
36.5数组操作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484
36.5.1输出整个数组的内容 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
15
36.5.2确定数组元素个数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
36.5.3找到数组使用的下标 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 486
36.5.4在数组末尾添加元素 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 486
36.5.5数组排序 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
36.5.6删除数组 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488
36.6关联数组 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489
36.7总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489
36.8拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
37奇珍异宝491
37.1组命令和子 shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
37.1.1进程替换 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 495
37.2陷阱 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498
37.3异步执行 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
37.3.1等待 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
37.4命名管道 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
37.4.1设置一个命名管道 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
37.4.2使用命名管道 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
37.5总结 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
37.6拓展阅读 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
16
1|引言
我想给大家讲个故事。
故事内容不是 Linus Torvalds在 1991年怎样写了 Linux内核的第一个版本，因为这些内容
你可以在许多 Linux书籍中读到。我也不是来告诉你，更早之前，Richard Stallman是如何开
始 GNU项目，设计了一个免费的类 Unix的操作系统。那也是一个很有意义的故事，但大多
数 Linux书籍也讲到了它。
我想告诉大家一个你如何才能夺回计算机管理权的故事。
在 20世纪 70年代末，我刚开始和计算机打交道时，正进行着一场革命，那时的我还是一
名大学生。微处理器的发明，使普通老百姓（就如你和我）真正拥有一台计算机成为可能。今
天，人们难以想象，只有大企业和强大的政府才能够拥有计算机的世界，是怎样的一个世界。
简单说，你做不了多少事情。
今天，世界已经截然不同了。计算机遍布各个领域，从小手表到大型数据中心，及大小介
于它们之间的每件东西。除了随处可见的计算机之外，我们还有一个无处不在的连接所有计算
机的网络。这已经开创了一个奇妙的，个人授权和创作自由的新时代，但是在过去的二三十年
里，正在发生另一些事情。一个大公司不断地把它的管理权强加到世界上绝大多数的计算机上，
并且决定你对计算机的操作权力。幸运地是，来自世界各地的人们，正积极努力地做些事情来
改变这种境况。通过编写自己的软件，他们一直在为维护电脑的管理权而战斗着。他们建设着
Linux。
一提到 Linux，许多人都会说到“自由”，但我不认为他们都知道“自由”的真正涵义。“自
由”是一种权力，它决定你的计算机能做什么，同时能够拥有这种“自由”的唯一方式就是知
道计算机正在做什么。“自由”是指一台没有任何秘密的计算机，你可以从它那里了解一切，只
要你用心的去寻找。
1.1为什么使用命令行
你是否注意到，在电影中一个“超级黑客”坐在电脑前，从不摸一下鼠标，就能够在 30秒内侵
入到超安全的军用计算机中。这是因为电影制片人意识到，作为人类，本能地知道让计算机圆
17
满完成工作的唯一途径，是用键盘来操纵计算机。
现在，大多数的计算机用户只是熟悉图形用户界面（GUI），并且产品供应商和此领域的学
者会灌输给用户这样的思想，命令行界面（CLI）是过去使用的一种很恐怖的东西。这就很不
幸，因为一个好的命令行界面，是用来和计算机进行交流沟通的非常有效的方式，正像人类社
会使用文字互通信息一样。人们说，“图形用户界面让简单的任务更容易完成，而命令行界面使
完成复杂的任务成为可能”，到现在这句话仍然很正确。
因为 Linux是以 Unix家族的操作系统为模型写成的，所以它分享了 Unix丰富的命令行工
具。Unix在 20世纪 80年代初显赫一时 (虽然，开发它在更早之前），结果，在普遍地使用图
形界面之前，开发了一种广泛的命令行界面。事实上，很多人选择 Linux（而不是其他的系统，
比如说 Windows NT）是因为其可以使“完成复杂的任务成为可能”的强大的命令行界面。
1.2这本书讲什么
这本书介绍如何生存在 Linux命令行的世界。不像一些书籍仅仅涉及一个程序，比如像 shell
程序，bash。这本书将试着向你传授如何与命令行界面友好相处。它是怎样工作的？它能做什
么？使用它的最好方法是什么？
这不是一本关于Linux系统管理的书。然而任何一个关于命令行的深入讨论，都一定会牵
涉到系统管理方面的内容，这本书仅仅提到一点儿管理方面的知识。但是这本书为读者准备好
了学习更多内容的坚实基础，毕竟要胜任系统管理工作也需要良好的命令行使用基本功。
这本书是围绕Linux而写的。许多书籍，为了扩大自身的影响力，会包含一些其它平台的
知识，比如 Unix, MacOS X等。这样做，很多内容只能比较空泛的去讲了。另一方面，这本书
只研究了当代 Linux发行版。虽然，对于使用其它类 Unix系统的用户来说，书中 95％的内容
是有用的，但这本书主要面向的对象是现代 Linux命令行用户。
1.3谁应该读这本书
这本书是为已经从其它平台移民到 Linux系统的新手而写的。最有可能，你是使用某个
Windows版本的高手。或许是老板让你去管理一个 Linux服务器，或许你只是一个桌面用户，
厌倦了系统出现的各种安全防御问题，而想要体验一下 Linux。很好，这里欢迎你们！
不过一般来说，对于 Linux的启蒙教育，没有捷径可言。学习命令行富于挑战性，而且很
费气力。这并不是说 Linux命令行很难学，而是它的知识量很大，不容易掌握。Linux操作系
统，差不多有数以千计的命令可供用户操作。由此可见，要给自己提个醒，命令行可不是轻轻
松松就能学好的。
18
另一方面，学习 Linux命令行会让你受益匪浅，给你极大的回报。如果你认为，现在你已
经是高手了。别急，其实你还不知道什么才是真正的高手。不像其他一些计算机技能，一段时
间之后可能就被淘汰了，命令行知识却不会落伍，你今天所学到的，在十年以后，都会有用处。
命令行通过了时间的考验。
如果你没有编程经验，也不要担心，我会带你入门。
1.4这本书的内容
这些材料是经过精心安排的，很像一位老师坐在你身旁，耐心地指导你。许多作者用系统化的
方式讲解这些材料，虽然从一个作者的角度考虑很有道理，但对于 Linux新手来说，他们可能
会感到非常困惑。
另一个目的，是想让读者熟悉 Unix的思维方式，这种思维方式与 Windows不同。在学习
过程中，我们会帮助你理解为什么某些命令那样工作，以及它们是如何工作的。Linux不仅是
一款软件，也是 Unix文化的一小部分，它有自己的语言和历史渊源。同时，我也许会说些过
激的话。
这本书共分为五部分，每一部分讲述了不同方面的命令行知识。除了第一部分，也就是你正
在阅读的这一部分，这本书还包括：
•第二部分—学习 shell开始探究命令行基本语言，包括命令组成结构，文件系统浏览，编
写命令行，查找命令帮助文档。
•第三部分—配置文件及环境讲述了如何编写配置文件，通过配置文件，用命令行来操控计
算机。
•第四部分—常见任务及主要工具探究了许多命令行经常执行的普通任务。类似于 Unix的
操作系统，例如 Linux,包括许多经典的命令行程序，这些程序可以用来对数据进行强大
的操作。
•第五部分—编写 Shell脚本介绍了 shell编程，一个无可否认的基本技能，能够自动化许
多常见的计算任务，很容易学。通过学习 shell编程，你会逐渐熟悉一些关于编程语言方
面的概念，这些概念也适用于其他的编程语言。
1.5怎样阅读这本书
从头到尾的阅读。它并不是一本技术参考手册，实际上它更像一本故事书，有开头，过程，结
尾。
19
1.5.1前提条件
为了使用这本书，你需要安装 Linux操作系统。你可以通过两种方式，来完成安装。
1.在一台（不用很新）的电脑上安装 Linux。你选择哪个 Linux发行版安装，是无关紧要的
事。虽然大多数人一开始选择安装 Ubuntu, Fedora,或者 OpenSUSE。如果你拿不定主
意，那就先试试 Ubuntu。由于主机硬件配置不同，安装 Linux时，你可能不费吹灰之力
就装上了，也可能费了九牛二虎之力还装不上。所以我建议，一台使用了几年的台式机，
至少要有 256M的内存，6G的硬盘可用空间。尽可能避免使用笔记本电脑和无线网络，
在 Linux环境下，它们经常不能工作。
2.使用“Live CD.”许多 Linux发行版都自带一个比较酷的功能，你可以直接从系统安装盘
CDROM中运行 Linux，而不必安装 Linux。开机进入 BIOS设置界面，更改引导项，设
置为“从 CDROM启动”。
不管你怎样安装 Linux，为了练习书中介绍的知识，你需要有超级用户（管理员）权限。
当你在自己的电脑上安装了 Linux系统之后，就开始一边阅读本书，一边练习吧。本书大
部分内容都可以自己动手练习，坐下来，敲入命令，体验一下吧。
为什么我不叫它“GNU/Linux”
在某些领域，把 Linux操作系统称为“GNU/Linux操作系统”，则政治立场正
确。但“Linux”的问题是，没有一个完全正确的方式能命名它，因为它是由许许多
多，分布在世界各地的贡献者们，合作开发而成的。从技术层面讲，Linux只是操
作系统的内核名字，没别的含义。当然内核非常重要，因为有它，操作系统才能运
行起来，但它并不能构成一个完备的操作系统。
Richard Stallman是一个天才的哲学家，自由软件运动创始人，自由软件基金会
创办者，他创建了 GNU工程，编写了第一版 GNU C编译器（gcc），创立了 GNU
通用公共协议（the GPL)等等。他坚持把 Linux称为“GNU/Linux”，为的是准确
地反映 GNU工程对 Linux操作系统的贡献。然而，尽管 GNU项目早于 Linux内
核，项目的贡献应该得到极高的赞誉，但是把 GNU用在 Linux名字里，这对其他
为 Linux的发展做出重大贡献的程序员来说，就不公平了。而且，我觉得要是叫也
要叫“Linux/GNU”比较准确一些，因为内核会先启动，其他一切都运行在内核之
上。
在目前流行的用法中，“Linux”指的是内核以及在一个典型的 Linux发行版中
所包含的所有免费及开源软件；也就是说，整个 Linux生态系统，不只有 GNU项
20
目软件。在操作系统商界，好像喜欢使用单个词的名字，比如说 DOS, Windows,
MacOS, Solaris, Irix, AIX.所以我选择用流行的命名规则。然而，如果你喜欢用
“GNU/Linux”，当你读这本书时，可以在脑子里搜索并替换“Linux”。我不介意。
1.6拓展阅读
Wikipedia网站上有些介绍本章提到的名人的文章，以下是链接地址：
• http://en.wikipedia.org/wiki/Linux_Torvalds
• http://en.wikipedia.org/wiki/Richard_Stallman
介绍自由软件基金会及 GNU项目的网站和文章：
• http://en.wikipedia.org/wiki/Free_Software_Foundation
• http://www.fsf.org
• http://www.gnu.org
Richard Stallman用了大量的文字来叙述“GNU/Linux”的命名问题，可以浏览以下网页：
• http://www.gnu.org/gnu/why-gnu-linux.html
• http://www.gnu.org/gnu/gnu-linux-faq.html#tools
21
2|什么是shell
一说到命令行，我们真正指的是 shell。shell就是一个程序，它接受从键盘输入的命令，然后
把命令传递给操作系统去执行。几乎所有的 Linux发行版都提供一个名为 bash的来自 GNU
项目的 shell程序。“bash”是“Bourne Again SHell”的首字母缩写，所指的是这样一个事实，
bash是最初 Unix上由 Steve Bourne写成 shell程序 sh的增强版。
2.1终端仿真器
当使用图形用户界面时，我们需要另一个和 shell交互的叫做终端仿真器的程序。如果我们浏览
一下桌面菜单，可能会找到一个。虽然在菜单里它可能都被简单地称为“terminal”，但是 KDE
用的是 konsole ,而 GNOME则使用 gnome-terminal。还有其他一些终端仿真器可供 Linux使
用，但基本上，它们都完成同样的事情，让我们能访问 shell。也许，你可能会因为附加的一系
列花俏功能而喜欢上某个终端。
2.2第一次按键
好，开始吧。启动终端仿真器！一旦它运行起来，我们应该看到一行像这样的文字：
[me@linuxbox~]$
这叫做 shell提示符，无论何时当 shell准备好了去接受输入时，它就会出现。然而，它可
能会以各种各样的面孔显示，这则取决于不同的 Linux发行版，它通常包括你的用户名 @主机
名，紧接着当前工作目录（稍后会有更多介绍）和一个美元符号。
如果提示符的最后一个字符是“#”,而不是“$”,那么这个终端会话就有超级用户权限。
这意味着，我们或者是以 root用户的身份登录，或者是我们选择的终端仿真器提供超级用户
（管理员）权限。
22
假定到目前为止，所有事情都进行顺利，那我们试着键入字符吧。在提示符下敲入一些像下
面一样的乱七八糟的字符：
[me@linuxbox~]$kaekfjaeifj
因为这个命令没有任何意义，所以 shell会提示错误信息，并让我们再试一下：
bash:kaekfjaeifj:commandnotfound
[me@linuxbox~]$
2.3命令历史
如果按下上箭头按键，我们会看到刚才输入的命令“kaekfjaeifj”重新出现在提示符之后。这就
叫做命令历史。许多 Linux发行版默认保存最后输入的 500个命令。按下下箭头按键，先前输
入的命令就消失了。
2.4移动光标
可借助上箭头按键，来获得上次输入的命令。现在试着使用左右箭头按键。看一下怎样把光标
定位到命令行的任意位置？通过使用箭头按键，使编辑命令变得轻松些。
2.5关于鼠标和光标
虽然，shell是和键盘打交道的，但你也可以在终端仿真器里使用鼠标。X窗口系统（使 GUI
工作的底层引擎）内建了一种机制，支持快速拷贝和粘贴技巧。如果你按下鼠标左键，沿着文
本拖动鼠标（或者双击一个单词）高亮了一些文本，那么这些高亮的文本就被拷贝到了一个由
X管理的缓冲区里面。然后按下鼠标中键，这些文本就被粘贴到光标所在的位置。试试看。
注意：不要在一个终端窗口里使用 Ctrl-c和 Ctrl-v快捷键来执行拷贝和粘贴操作。它们不
起作用。对于 shell来说，这两个控制代码有着不同的含义，它们在早于 Microsoft Windows
（定义复制粘贴的含义）许多年之前就赋予了不同的意义。
你的图形桌面环境（像 KDE或 GNOME），努力想和 Windows一样，可能会把它的聚焦策
略设置成“单击聚焦”。这意味着，为了让窗口聚焦（变成活动窗口）你需要单击它。这与“聚
23
焦跟随着鼠标”的传统 X行为不同，传统 X行为是指只要把鼠标移动到一个窗口的上方。它
能接受输入，但是直到你单击窗口之前它都不会成为前端窗口。设置聚焦策略为“聚焦跟随着
鼠标”，可以使拷贝和粘贴更方便易用。尝试一下。我想如果你试了一下你会喜欢上它的。你
能在窗口管理器的配置程序中找到这个设置。
2.6试试运行一些简单命令
现在，我们学习了怎样输入命令，那我们执行一些简单的命令吧。第一个命令是 date。这个命
令显示系统当前时间和日期。
[me@linuxbox~]$date
ThuOct2513:51:54EDT2007
一个相关联的命令，cal，它默认显示当前月份的日历。
[me@linuxbox~]$cal
October2007
SuMoTuWeThFrSa
123456
78910111213
14151617181920
21222324252627
28293031
查看磁盘剩余空间的数量，输入 df:
[me@linuxbox~]$df
Filesystem1K-blocksUsedAvailableUse%Mountedon
/dev/sda2151154525012392994971634%/
/dev/sda559631908265454243000843247%/home
/dev/sda11477641737012276513%/boot
tmpfs25685602568560%/dev/shm
同样地，显示空闲内存的数量，输入命令 free。
24
[me@linuxbox~]$free
totalusedfreesharedbufferscached
Mem:205967684645612132200
44028360568
-/+buffers/cache:4418601617816
Swap:104242801042428
2.7结束终端会话
我们可以通过关闭终端仿真器窗口，或者是在 shell提示符下输入 exit命令来终止一个终端会
话：
[me@linuxbox~]$exit
2.8幕后控制台
即使终端仿真器没有运行，在后台仍然有几个终端会话运行着。它们叫做虚拟终端或者是虚拟
控制台。在大多数 Linux发行版中，这些终端会话都可以通过按下 Ctrl-Alt-F1到 Ctrl-Alt-F6
访问。当一个会话被访问的时候，它会显示登录提示框，我们需要输入用户名和密码。要从一
个虚拟控制台转换到另一个，按下 Alt和 F1-F6(中的一个)。返回图形桌面，按下 Alt-F7。
2.9拓展阅读
•想了解更多关于 Steve Bourne的故事，Bourne Shell之父，读一下这篇文章：
http://en.wikipedia.org/wiki/Steve_Bourne
•这是一篇关于在计算机领域里，shells概念的文章：
http://en.wikipedia.org/wiki/Shell_(computing)
25
3|文件系统中跳转
我们需要学习的第一件事（除了打字之外）是如何在 Linux文件系统中跳转。在这一章节中，
我们将介绍以下命令：
• pwd—打印出当前工作目录名
• cd—更改目录
• ls—列出目录内容
3.1理解文件系统树
类似于 Windows，一个“类 Unix”的操作系统，比如说 Linux，以分层目录结构来组织所有文
件。这就意味着所有文件组成了一棵树型目录（有时候在其它系统中叫做文件夹），这个目录树
可能包含文件和其它的目录。文件系统中的第一级目录称为根目录。根目录包含文件和子目录，
子目录包含更多的文件和子目录，依此类推。
注意 (类 Unix系统)不像 Windows，每个存储设备都有一个独自的文件系统。类 Unix操
作系统，比如 Linux，总是只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接
到计算机上。根据负责维护系统安全的系统管理员的兴致，存储设备连接到（或着更精确些，
是挂载到）目录树的各个节点上。
26
3.2当前工作目录
图 1:由图形化文件管理器显示的文件系统树
大多数人都可能熟悉如图 1所示描述文件系统树的图形文件管理器。注意，通常这是一棵
倒置的树，也就是说，树根在最上面，而各个枝干在下面展开。
然而，命令行没有这样的图片，所以我们需要把文件系统树想象成别的样子（而不是这张图
片）。
把文件系统想象成一个迷宫形状，就像一棵倒立的大树，我们站在迷宫的中间位置。在任意
时刻，我们处于一个目录里面，我们能看到这个目录包含的所有文件，以及通往上面目录（父
目录）的路径，和下面的各个子目录。我们所在的目录则称为当前工作目录。我们使用 pwd
（print working directory(的缩写)）命令，来显示当前工作目录。
[me@linuxbox~]$pwd
/home/me
当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。每个
用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一允许用户写入
文件的地方。
27
3.3列出目录内容
列出一个目录包含的文件及子目录，使用 ls命令。
[me@linuxbox~]$ls
DesktopDocumentsMusicPicturesPublicTemplatesVideos
实际上，用 ls命令可以列出任一个目录的内容，而不只是当前工作目录的内容。ls命令还
能完成许多有趣的事情。在下一章节，我们将介绍更多关于 ls的知识。
3.4更改当前工作目录
要更改工作目录（此刻，我们站在树形迷宫里面），我们用 cd命令。输入 cd,然后输入你想要
去的工作目录的路径名。路径名就是沿着目录树的分支到达想要的目录期间所经过的路线。路
径名可通过两种方式来指定，一种是绝对路径，另一种是相对路径。我们先来介绍绝对路径。
3.5绝对路径
绝对路径开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件。例如，
你的系统中有一个目录，大多数系统程序都安装在这个目录下。这个目录的路径名是 /usr/
bin。它意味着从根目录（用开头的“/“表示）开始，有一个叫”usr”的目录包含了目录 “bin”。
[me@linuxbox~]$cd/usr/bin
[me@linuxboxbin]$pwd
/usr/bin
[me@linuxboxbin]$ls
...Listingofmany,manyfiles...
我们把工作目录转到 /usr/bin目录下，里面装满了文件。注意 shell提示符是怎样改变的
吗？为了方便，通常终端提示符自动显示工作目录名。
28
3.6相对路径
绝对路径从根目录开始，直到它的目的地，而相对路径开始于工作目录。为了做到这个（用相
对路径表示），我们在文件系统树中用一对特殊符号来表示相对位置。这对特殊符号是 “.” (点)
和 “..” (点点)。
符号 “.”指的是工作目录，”..”指的是工作目录的父目录。下面的例子说明怎样使用它。让
我们再次把工作目录切换到 /usr/bin：
[me@linuxbox~]$cd/usr/bin
[me@linuxboxbin]$pwd
/usr/bin
好了，比方说我们想更改工作目录到 /usr/bin的父目录 /usr。可以通过两种方法来实现。
可以使用以下绝对路径名：
[me@linuxboxbin]$cd/usr
[me@linuxboxusr]$pwd
/usr
或者，也可以使用相对路径：
[me@linuxboxbin]$cd..
[me@linuxboxusr]$pwd
/usr
两种不同的方法，一样的结果。我们应该选哪一个呢？选输入量最少的那个！
同样地，从目录 /usr/到 /usr/bin也有两种途径。可以使用绝对路径：
[me@linuxboxusr]$cd/usr/bin
[me@linuxboxbin]$pwd
/usr/bin
29
或者，也可以用相对路径：
[me@linuxboxusr]$cd./bin
[me@linuxboxbin]$pwd
/usr/bin
有一件很重要的事，我必须指出来。在几乎所有的情况下，你可以省略 “./”。它是隐含的。
输入：
[me@linuxboxusr]$cdbin
实现相同的效果。如果不指定一个文件的路径，那它被默认为在当前工作目录下。
3.7有用的快捷键
在表 3-1中，列举出了一些快速改变当前工作目录的有效方法。
快捷键运行结果
cd更改工作目录到你的家目录。
cd -更改工作目录到先前的工作目录。
cd ˜user_name更改工作目录到用户家目录。例如, cd ˜bob会更改工作目
录到用户“bob”的家目录。
表 3-1: cd快捷键
关于文件名的重要规则
1.以 “.”字符开头的文件名是隐藏文件。这仅表示，ls命令不能列出它们，用 ls
-a命令就可以了。当你创建帐号后，几个配置帐号的隐藏文件被放置在你的家
目录下。稍后，我们会仔细研究一些隐藏文件，来定制你的系统环境。另外，
一些应用程序也会把它们的配置文件以隐藏文件的形式放在你的家目录下面。
2.文件名和命令名是大小写敏感的。文件名“File1”和“file1”是指两个不同的
文件名。
30
3. Linux没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任何
名字来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix的操作
系统，不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。
4.虽然 Linux支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限
使用“.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表
示词与词间的空格，用下划线字符来代替。过些时候，你会感激自己这样做。
31
4|探究操作系统
既然我们已经知道了如何在文件系统中跳转，是时候开始 Linux操作系统之旅了。然而在开始
之前，我们先学习一些对研究 Linux系统有帮助的命令。
• ls—列出目录内容
• file—确定文件类型
• less—浏览文件内容
4.1ls乐趣
ls可能是用户最常使用的命令了，这自有它的道理。通过它，我们可以知道目录的内容，以及
各种各样重要文件和目录的属性。正如我们已经见到的，只要简单地输入 ls就能看到在当前目
录下所有文件和子目录的列表。
[me@linuxbox~]$ls
DesktopDocumentsMusicPicturesPublicaTemplatesVideos
除了当前工作目录以外，也可以指定别的目录，就像这样：
me@linuxbox~]$ls/usr
bingameskerberoslibexecsbinsrc
etcincludeliblocalsharetmp
甚至可以列出多个指定目录的内容。在这个例子中，将会列出用户家目录（用字符“”代
表）和/usr目录的内容：
32
[me@linuxbox~]$ls~/usr
/home/me:
DesktopDocumentsMusicPicturesPublicTemplatesVideos
/usr:
bingameskerberoslibexecsbinsrc
etcincludeliblocalsharetmp
我们也可以改变输出格式，来得到更多的细节：
[me@linuxbox~]$ls-l
total56
drwxrwxr-x2meme40962007-10-2617:20Desktop
drwxrwxr-x2meme40962007-10-2617:20Documents
drwxrwxr-x2meme40962007-10-2617:20Music
drwxrwxr-x2meme40962007-10-2617:20Pictures
drwxrwxr-x2meme40962007-10-2617:20Public
drwxrwxr-x2meme40962007-10-2617:20Templates
drwxrwxr-x2meme40962007-10-2617:20Videos
使用 ls命令的“-l”选项，则结果以长模式输出。
4.2选项和参数
我们将学习一个非常重要的知识点，即大多数命令是如何工作的。命令名经常会带有一个或多
个用来更正命令行为的选项，更进一步，选项后面会带有一个或多个参数，这些参数是命令作
用的对象。所以大多数命令看起来像这样：
command-optionsarguments
大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令，
包括来自于 GNU项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然，
许多命令也允许把多个短选项串在一起使用。下面这个例子，ls命令有两个选项，“l”选项产
生长格式输出，“t”选项按文件修改时间的先后来排序。
33
[me@linuxbox~]$ls-lt
加上长选项“–reverse”，则结果会以相反的顺序输出：
[me@linuxbox~]$ls-lt--reverse
ls命令有大量的选项。表 4-1列出了最常使用的选项。
选项长选项描述
-a --all列出所有文件，甚至包括文件名以圆点开头的默认会
被隐藏的隐藏文件。
-d --directory通常，如果指定了目录名，ls命令会列出这个目录中
的内容，而不是目录本身。把这个选项与 -l选项结合
使用，可以看到所指定目录的详细信息，而不是目录
中的内容。
-F --classify这个选项会在每个所列出的名字后面加上一个指示
符。例如，如果名字是目录名，则会加上一个’/’字
符。
-h --human-readable当以长格式列出时，以人们可读的格式，而不是以字
节数来显示文件的大小。
-l以长格式显示结果。
-r --reverse以相反的顺序来显示结果。通常，ls命令的输出结果
按照字母升序排列。
-S命令输出结果按照文件大小来排序。
-t按照修改时间来排序。
表 4-1: ls命令选项
4.3深入研究长格式输出
正如我们先前知道的，“-l”选项导致 ls的输出结果以长格式输出。这种格式包含大量的有用信
息。下面的例子目录来自于 Ubuntu系统：
34
-rw-r--r--1rootroot35762962007-04-0311:05Experienceubuntu.ogg
-rw-r--r--1rootroot11862192007-04-0311:05kubuntu-leaflet.png
-rw-r--r--1rootroot475842007-04-0311:05logo-Edubuntu.png
-rw-r--r--1rootroot443552007-04-0311:05logo-Kubuntu.png
-rw-r--r--1rootroot343912007-04-0311:05logo-Ubuntu.png
-rw-r--r--1rootroot320592007-04-0311:05oo-cd-cover.odf
-rw-r--r--1rootroot1597442007-04-0311:05oo-derivatives.doc
-rw-r--r--1rootroot278372007-04-0311:05oo-maxwell.odt
-rw-r--r--1rootroot988162007-04-0311:05oo-trig.xls
-rw-r--r--1rootroot4537642007-04-0311:05oo-welcome.odt
-rw-r--r--1rootroot3583742007-04-0311:05ubuntuSax.ogg
选一个文件，来看一下各个输出字段的含义：
字段含义
-rw-r--r--对于文件的访问权限。第一个字符指明文件类型。在不同
类型之间，开头的“－”说明是一个普通文件，“d”表明是
一个目录。其后三个字符是文件所有者的访问权限，再其后
的三个字符是文件所属组中成员的访问权限，最后三个字符
是其他所有人的访问权限。这个字段的完整含义将在第十
章讨论。
1文件的硬链接数目。参考随后讨论的关于链接的内容。
root文件所有者的用户名。
root文件所属用户组的名字。
32059以字节数表示的文件大小。
2007-04-03 11:05上次修改文件的时间和日期。
oo-cd-cover.odf文件名。
表 4-2: ls长格式列表的字段
4.4确定文件类型
随着探究操作系统的进行，知道文件包含的内容是很有用的。我们将用 file命令来确定文件的
类型。我们之前讨论过，在 Linux系统中，并不要求文件名来反映文件的内容。然而，一个类
35
似“picture.jpg”的文件名，我们会期望它包含 JPEG压缩图像，但 Linux却不这样要求它。
可以这样调用 file命令：
filefilename
当调用 file命令后，file命令会打印出文件内容的简单描述。例如：
[me@linuxbox~]$filepicture.jpg
picture.jpg:JPEGimagedata,JFIFstandard1.01
有许多种类型的文件。事实上，在类 Unix操作系统中比如说 Linux中，有个普遍的观念就
是“一切皆文件”。随着课程的进行，我们将会明白这句话是多么的正确。
虽然系统中许多文件格式是熟悉的，例如 MP3和 JPEG文件，但也有一些文件格式不太
常见，极少数文件相当陌生。
4.5用less浏览文件内容
less命令是一个用来浏览文本文件的程序。纵观 Linux系统，有许多人类可读的文本文件。less
程序为我们检查文本文件提供了方便。
什么是“文本”
在计算机中，有许多方法可以表达信息。所有的方法都涉及到，在信息与一些数
字之间确立一种关系，而这些数字可以用来代表信息。毕竟，计算机只能理解数字，
这样所有的数据都被转换成数值来表示。
有些数值表达法非常复杂（例如压缩的视频文件），而其它的就相当简单。最早
也是最简单的一种表达法，叫做 ASCII文本。ASCII（发音是 “As-Key”）是美国信
息交换标准码的简称。这是一个简单的编码方法，它首先被用在电传打字机上，用
来实现键盘字符到数字的映射。
文本是简单的字符与数字之间的一对一映射。它非常紧凑。五十个字符的文本
翻译成五十个字节的数据。文本只是包含简单的字符到数字的映射，理解这点很重
要。它和一些文字处理器文档不一样，比如说由微软或 OpenOffice.org文档编辑器
36
创建的文件。这些文件，和简单的 ASCII文件形成鲜明对比，它们包含许多非文本
元素，来描述它的结构和格式。纯 ASCII文件只包含字符本身，和一些基本的控制
符，像制表符、回车符及换行符。纵观 Linux系统，许多文件以文本格式存储，也
有许多 Linux工具来处理文本文件。甚至 Windows也承认这种文件格式的重要性。
著名的 NOTEPAD.EXE程序就是一个纯 ASCII文本文件编辑器。
为什么我们要查看文本文件呢？因为许多包含系统设置的文件（叫做配置文件），是以文本
格式存储的，阅读它们可以更深入的了解系统是如何工作的。另外，许多系统所用到的实际程
序（叫做脚本）也是以这种格式存储的。在随后的章节里，我们将要学习怎样编辑文本文件以
修改系统设置，还要学习编写自己的脚本文件，但现在我们只是看看它们的内容而已。
less命令是这样使用的：
lessfilename
一旦运行起来，less程序允许你前后滚动文件。例如，要查看一个定义了系统中全部用户身
份的文件，输入以下命令：
[me@linuxbox~]$less/etc/passwd
一旦 less程序运行起来，我们就能浏览文件内容了。如果文件内容多于一页，那么我们可
以上下滚动文件。按下“q”键，退出 less程序。
下表列出了 less程序最常使用的键盘命令。
命令行为
Page UP or b向上翻滚一页
Page Down or space向下翻滚一页
UP Arrow向上翻滚一行
Down Arrow向下翻滚一行
G移动到最后一行
1G or g移动到开头一行
/charaters向前查找指定的字符串
37
n向前查找下一个出现的字符串，这个字符串是
之前所指定查找的
h显示帮助屏幕
q退出 less程序
表 4-3: less命令
4.6less就是more（禅语：色即是空）
less程序是早期 Unix程序 more的改进版。“less”这个名字，对习语“less is more”开了个玩
笑，这个习语是现代主义建筑师和设计者的座右铭。
less属于 “页面调度器”类程序，这些程序允许以逐页方式轻松浏览长文本文档。more程序
只能向前翻页，而 less程序允许前后翻页，此外还有很多其它的特性。
4.7旅行指南
Linux系统中，文件系统布局与类 Unix系统的文件布局很相似。实际上，一个已经发布的标
准，叫做 Linux文件系统层次标准，详细说明了这种设计模式。不是所有 Linux发行版都根据
这个标准，但大多数都是。
下一步，我们将在文件系统中漫游，来了解 Linux系统的工作原理。这会给你一个温习跳转
命令的机会。我们会发现很多有趣的文件都是纯人类可读文本。下面旅行开始，做做以下练习：
1. cd到给定目录
2.列出目录内容 ls -l
3.如果看到一个有趣的文件，用 file命令确定文件内容
4.如果文件看起来像文本，试着用 less命令浏览它
记得复制和粘贴技巧！如果你正在使用鼠标，双击文件名，来复制它，然后按下鼠标中键，
粘贴文件名到命令行中。
38
在系统中漫游时，不要害怕四处看看。普通用户是很难把东西弄乱的。那是系统管理员的
工作！如果一个命令抱怨一些事情，不要管它，尝试一下别的东西。花一些时间四处看看。系
统是我们自己的，尽情地探究吧。记住在 Linux中，没有秘密存在！表 4-4仅仅列出了一些我
们可以浏览的目录。随意尝试更多！
目录评论
/根目录，万物起源。
/bin包含系统启动和运行所必须的二进制程序。
/boot包含 Linux内核、初始 RAM磁盘映像（用于启动时所需
的驱动）和启动加载程序。
有趣的文件：
• /boot/grub/grub.conf or menu.lst，被用来配置启动
加载程序。
• /boot/vmlinuz，Linux内核。
/dev这是一个包含设备结点的特殊目录。“一切都是文件”，也适
用于设备。在这个目录里，内核维护着所有设备的列表。
/etc这个目录包含所有系统层面的配置文件。它也包含一系列
的 shell脚本，在系统启动时，这些脚本会开启每个系统服
务。这个目录中的任何文件应该是可读的文本文件。
有趣的文件：虽然/etc目录中的任何文件都有趣，但这里只
列出了一些我一直喜欢的文件：
• /etc/crontab，定义自动运行的任务。
• /etc/fstab，包含存储设备的列表，以及与他们相关的
挂载点。
• /etc/passwd，包含用户帐号列表。
39
/home在通常的配置环境下，系统会在/home下，给每个用户分配
一个目录。普通用户只能在自己的目录下写文件。这个限
制保护系统免受错误的用户活动破坏。
/lib包含核心系统程序所使用的共享库文件。这些文件与
Windows中的动态链接库相似。
/lost+found每个使用 Linux文件系统的格式化分区或设备，例如 ext3
文件系统，都会有这个目录。当部分恢复一个损坏的文件系
统时，会用到这个目录。这个目录应该是空的，除非文件系
统真正的损坏了。
/media在现在的 Linux系统中，/media目录会包含可移动介质的
挂载点，例如 USB驱动器，CD-ROMs等等。这些介质连
接到计算机之后，会自动地挂载到这个目录结点下。
/mnt在早些的 Linux系统中，/mnt目录包含可移动介质的挂载
点。
/opt这个/opt目录被用来安装“可选的”软件。这个主要用来
存储可能安装在系统中的商业软件产品。
/proc这个/proc目录很特殊。从存储在硬盘上的文件的意义上说，
它不是真正的文件系统。相反，它是一个由 Linux内核维护
的虚拟文件系统。它所包含的文件是内核的窥视孔。这些
文件是可读的，它们会告诉你内核是怎样监管计算机的。
/root root帐户的家目录。
/sbin这个目录包含“系统”二进制文件。它们是完成重大系统任
务的程序，通常为超级用户保留。
/tmp这个/tmp目录，是用来存储由各种程序创建的临时文件的
地方。一些配置导致系统每次重新启动时，都会清空这个目
录。
/usr在 Linux系统中，/usr目录可能是最大的一个。它包含普
通用户所需要的所有程序和文件。
/usr/bin /usr/bin目录包含系统安装的可执行程序。通常，这个目录
会包含许多程序。
/usr/lib包含由/usr/bin目录中的程序所用的共享库。
40
/usr/local这个/usr/local目录，是非系统发行版自带程序的安装目
录。通常，由源码编译的程序会安装在/usr/local/bin目录
下。新安装的 Linux系统中会存在这个目录，并且在管理员
安装程序之前，这个目录是空的。
/usr/sbin包含许多系统管理程序。
/usr/share /usr/share目录包含许多由/usr/bin目录中的程序使用的
共享数据。其中包括像默认的配置文件、图标、桌面背景、
音频文件等等。
/usr/share/doc大多数安装在系统中的软件包会包含一些文档。在/usr/
share/doc目录下，我们可以找到按照软件包分类的文档。
/var除了/tmp和/home目录之外，相对来说，目前我们看到的
目录是静态的，这是说，它们的内容不会改变。/var目录存
放的是动态文件。各种数据库，假脱机文件，用户邮件等等，
都位于在这里。
/var/log这个/var/log目录包含日志文件、各种系统活动的记录。这
些文件非常重要，并且应该时时监测它们。其中最重要的一
个文件是/var/log/messages。注意，为了系统安全，在一些
系统中，你必须是超级用户才能查看这些日志文件。
表 4-4: Linux系统中的目录
4.8符号链接
在我们到处查看时，我们可能会看到一个目录，列出像这样的一条信息：
lrwxrwxrwx1rootroot112007-08-1107:34libc.so.6->libc-2.6.so
注意看，为何这条信息第一个字符是“l”，并且有两个文件名呢？这是一个特殊文件，叫做
符号链接（也称为软链接或者 symlink）。在大多数“类 Unix”系统中，有可能一个文件被多
个文件名所指向。虽然这种特性的意义并不明显，但它真的很有用。
描绘一下这样的情景：一个程序要求使用某个包含在名为“foo”文件中的共享资源，但是
“foo”经常改变版本号。这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其
41
它相关方，会知道安装了哪个“foo”版本。这会导致另一个问题。如果我们更改了共享资源的
名字，那么我们必须跟踪每个可能使用了这个共享资源的程序，当每次这个资源的新版本被安
装后，都要让使用了它的程序去寻找新的资源名。这听起来很没趣。
这就是符号链接存在至今的原因。比方说，我们安装了文件“foo”的 2.6版本，它的文件
名是“foo-2.6”，然后创建了叫做“foo”的符号链接，这个符号链接指向“foo-2.6”。这意味
着，当一个程序打开文件“foo”时，它实际上是打开文件“foo-2.6”。现在，每个人都很高兴。
依赖于“foo”文件的程序能找到这个文件，并且我们能知道安装了哪个文件版本。当升级到
“foo-2.7”版本的时候，仅添加这个文件到文件系统中，删除符号链接“foo”，创建一个指向新
版本的符号链接。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版
本。假想“foo-2.7”有个错误（该死的开发者！），那我们得回到原来的版本。一样的操作，我
们只需要删除指向新版本的符号链接，然后创建指向旧版本的符号链接就可以了。
在上面列出的目录（来自于 Fedora的 /lib目录）展示了一个叫做“libc.so.6”的符号链接，
这个符号链接指向一个叫做“libc-2.6.so”的共享库文件。这意味着，寻找文件“libc.so.6”的
程序，实际上得到是文件“libc-2.6.so”。在下一章节，我们将学习如何建立符号链接。
4.9硬链接
讨论到链接问题，我们需要提一下，还有一种链接类型，叫做硬链接。硬链接同样允许文件有
多个名字，但是硬链接以不同的方法来创建多个文件名。在下一章中，我们会谈到更多符号链
接与硬链接之间的差异问题。
4.10拓展阅读
•完整的 Linux文件系统层次体系标准可通过以下链接找到：
http://www.pathname.com/fhs/
42
5|操作文件和目录
此时此刻，我们已经准备好了做些真正的工作！这一章节将会介绍以下命令：
• cp—复制文件和目录
• mv—移动/重命名文件和目录
• mkdir—创建目录
• rm—删除文件和目录
• ln—创建硬链接和符号链接
这五个命令属于最常使用的 Linux命令之列。它们用来操作文件和目录。
现在，坦诚地说，用图形文件管理器来完成一些由这些命令执行的任务会更容易些。使用文
件管理器，我们可以把文件从一个目录拖放到另一个目录、剪贴和粘贴文件、删除文件等等。
那么，为什么还使用早期的命令行程序呢？
答案是命令行程序，功能强大灵活。虽然图形文件管理器能轻松地实现简单的文件操作，但
是对于复杂的文件操作任务，则使用命令行程序比较容易完成。例如，怎样拷贝一个目录下所
有的 HTML文件——这些文件在目标目录不存在或者版本比目标目录的文件更新——到目标目
录呢？要完成这个任务，使用文件管理器相当难，使用命令行相当容易：
cp-u*.htmldestination
5.1通配符
在开始使用命令之前，我们需要介绍一个使命令行如此强大的 shell特性。因为 shell频繁地使
用文件名，shell提供了特殊字符来帮助你快速指定一组文件名。这些特殊字符叫做通配符。使
43
用通配符（也以文件名代换著称）允许你依据字符的组合模式来选择文件名。下表列出这些通
配符以及它们所选择的对象：
通配符意义
*匹配任意多个字符（包括零个或一个）
?匹配任意一个字符（不包括零个）
[characters]匹配任意一个属于字符集中的字符
[!characters]匹配任意一个不是字符集中的字符
[[:class:]]匹配任意一个属于指定字符类中的字符
表 5-1:通配符
表 5-2列出了最常使用的字符类：
字符类意义
[:alnum:]匹配任意一个字母或数字
[:alpha:]匹配任意一个字母
[:digit:]匹配任意一个数字
[:lower:]匹配任意一个小写字母
[:upper:]匹配任意一个大写字母
表 5-2:普遍使用的字符类
借助通配符，为文件名构建非常复杂的选择标准成为可能。下面是一些类型匹配的范例:
模式匹配对象
*所有文件
g*文件名以“g”开头的文件
b*.txt以”b”开头，中间有零个或任意多个字符，并以”.txt”结尾
的文件
Data???以“Data”开头，其后紧接着 3个字符的文件
[abc]*文件名以”a”,”b”,或”c”开头的文件
BACKUP.[0-9][0-以”BACKUP.”开头，并紧接着 3个数字的文件
9][0-9]
[[:upper:]]*以大写字母开头的文件
[![:digit:]]*不以数字开头的文件
44
*[[:lower:]123]文件名以小写字母结尾，或以“1”，“2”，或“3”结尾的文件
表 5-3:通配符范例
接受文件名作为参数的任何命令，都可以使用通配符，我们会在第八章更深入地谈到这个知
识点。
字符范围
如果你用过别的类 Unix系统的操作环境，或者是读过这方面的书籍，你可能遇
到过 [A-Z]或 [a-z]形式的字符范围表示法。这些都是传统的 Unix表示法，并且在
早期的 Linux版本中仍有效。虽然它们仍然起作用，但是你必须小心地使用它们，
因为它们不会产生你期望的输出结果，除非你合理地配置它们。从现在开始，你应
该避免使用它们，并且用字符类来代替它们。
通配符在 GUI中也有效
通配符非常重要，不仅因为它们经常用在命令行中，而且一些图形文件管理器也
支持它们。
•在 Nautilus (GNOME文件管理器）中，可以通过 Edit/Select模式菜单项来
选择文件。输入一个用通配符表示的文件选择模式后，那么当前所浏览的目录
中，所匹配的文件名就会高亮显示。
•在 Dolphin和 Konqueror（KDE文件管理器）中，可以在地址栏中直接输入
通配符。例如，如果你想查看目录 /usr/bin中，所有以小写字母 ‘u’开头的文
件，在地址栏中敲入 ‘/usr/bin/u*‘，则文件管理器会显示匹配的结果。
最初源于命令行界面中的想法，在图形界面中也适用。这就是使 Linux桌面系
统如此强大的众多原因中的一个
5.2mkdir-创建目录
mkdir命令是用来创建目录的。它这样工作：
mkdirdirectory...
45
注意表示法:在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面，这
意味着那个参数可以重复，就像这样：
mkdirdir1
会创建一个名为 “dir1”的目录，而
mkdirdir1dir2dir3
会创建三个目录，名为 dir1, dir2, dir3。
5.3cp-复制文件和目录
cp命令，复制文件或者目录。它有两种使用方法：
cpitem1item2
复制单个文件或目录 “item1”到文件或目录”item2”，和：
cpitem...directory
复制多个项目（文件或目录）到一个目录下。
5.4有用的选项和实例
这里列举了 cp命令一些有用的选项（短选项和等效的长选项）：
选项意义
-a, --archive复制文件和目录，以及它们的属性，包括所有权和权限。通
常，副本具有用户所操作文件的默认属性。
-i, --interactive在重写已存在文件之前，提示用户确认。如果这个选项不指
定，cp命令会默认重写文件。
46
-r, --recursive递归地复制目录及目录中的内容。当复制目录时，需要这个
选项（或者-a选项）。
-u, --update当把文件从一个目录复制到另一个目录时，仅复制目标目录
中不存在的文件，或者是文件内容新于目标目录中已经存在
的文件。
-v, --verbose显示翔实的命令操作信息
表 5-4: cp选项
命令运行结果
cp file1 file2复制文件 file1内容到文件 file2。如果 file2已经存在，file2
的内容会被 file1的内容重写。如果 file2不存在，则会创建
file2。
cp -i file1 file2这条命令和上面的命令一样，除了如果文件 file2存在的话，
在文件 file2被重写之前，会提示用户确认信息。
cp file1 file2 dir1复制文件 file1和文件 file2到目录 dir1。目录 dir1必须存
在。
cp dir1/* dir2使用一个通配符，在目录 dir1中的所有文件都被复制到目
录 dir2中。dir2必须已经存在。
cp -r dir1 dir2复制目录 dir1中的内容到目录 dir2。如果目录 dir2不存在，
创建目录 dir2，操作完成后，目录 dir2中的内容和 dir1中
的一样。如果目录 dir2存在，则目录 dir1 (和目录中的内
容)将会被复制到 dir2中。
表 5-5: cp实例
5.5mv-移动和重命名文件
mv命令可以执行文件移动和文件命名任务，这依赖于你怎样使用它。任何一种情况下，完成
操作之后，原来的文件名不再存在。mv使用方法与 cp很相像：
mvitem1item2
47
把文件或目录“item1”移动或重命名为“item2”,或者：
mvitem...directory
把一个或多个条目从一个目录移动到另一个目录中。
5.6有用的选项和实例
mv与 cp共享了很多一样的选项：
选项意义
-i --interactive在重写一个已经存在的文件之前，提示用户确认信息。如果
不指定这个选项，mv命令会默认重写文件内容。
-u --update当把文件从一个目录移动另一个目录时，只是移动不存在的
文件，或者文件内容新于目标目录相对应文件的内容。
-v --verbose当操作 mv命令时，显示翔实的操作信息。
表 5-6: mv选项
mv file1 file2移动 file1到 file2。如果file2存在，它的内容会被file1的
内容重写。如果 file2不存在，则创建 file2。这两种情况下，
file1都不再存在。
mv -i file1 file2除了如果 file2存在的话，在 file2被重写之前，用户会得到
提示信息外，这个和上面的选项一样。
mv file1 file2 dir1移动 file1和 file2到目录 dir1中。dir1必须已经存在。
mv dir1 dir2如果目录 dir2不存在，创建目录 dir2，并且移动目录 dir1
的内容到目录 dir2中，同时删除目录 dir1。如果目录 dir2
存在，移动目录 dir1（及它的内容）到目录 dir2。
表 5-7: mv实例
5.7rm-删除文件和目录
rm命令用来移除（删除）文件和目录：
48
rmitem...
“item”代表一个或多个文件或目录。
5.8有用的选项和实例
下表是一些普遍使用的 rm选项：
选项意义
-i, --interactive在删除已存在的文件前，提示用户确认信息。如果不指定这
个选项，rm会默默地删除文件
-r, --recursive递归地删除文件，这意味着，如果要删除一个目录，而此目
录又包含子目录，那么子目录也会被删除。要删除一个目
录，必须指定这个选项。
-f, --force忽视不存在的文件，不显示提示信息。这选项覆盖了“--
interactive”选项。
-v, --verbose在执行 rm命令时，显示翔实的操作信息。
表 5-8: rm选项
命令运行结果
rm file1默默地删除文件
rm -i file1除了在删除文件之前，提示用户确认信息之外，和上面的命
令作用一样。
rm -r file1 dir1删除文件 file1,目录 dir1，及 dir1中的内容。
rm -rf file1 dir1同上，除了如果文件 file1，或目录 dir1不存在的话，rm仍
会继续执行。
表 5-9: rm实例
小心 rm!
类 Unix的操作系统，比如说 Linux，没有复原命令。一旦你用 rm删除了一些
49
东西，它就消失了。Linux假定你很聪明，你知道你在做什么。
尤其要小心通配符。思考一下这个经典的例子。假如说，你只想删除一个目录中
的 HTML文件。输入：
rm*.html
这是正确的，如果你不小心在“*”和“.html”之间多输入了一个空格，就像这
样：
rm*.html
这个 rm命令会删除目录中的所有文件，还会抱怨没有文件叫做“.html”。
小贴士。当你使用带有通配符的 rm命令时（除了仔细检查输入的内容外），先
用 ls命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头
按键，重新调用刚刚执行的命令，用 rm替换 ls。
5.9ln—创建链接
ln命令既可创建硬链接，也可以创建符号链接。可以用其中一种方法来使用它：
lnfilelink
创建硬链接，和：
ln-sitemlink
创建符号链接，“item”可以是一个文件或是一个目录。
5.10硬链接
与更加现代的符号链接相比，硬链接是最初 Unix创建链接的方式。每个文件默认会有一个硬
链接，这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目
录项。硬链接有两个重要局限性：
1.一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联与链接本身
不在同一个磁盘分区上的文件。
50
2.一个硬链接不能关联一个目录。
一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录内
容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文
件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件
的链接都删除掉。知道硬链接很重要，因为你可能有时会遇到它们，但现在实际中更喜欢使用
符号链接，下一步我们会讨论符号链接。
5.11符号链接
创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文件，
这个文件包含一个关联文件或目录的文本指针。在这一方面，它们和 Windows的快捷方式差
不多，当然，符号链接早于 Windows的快捷方式很多年;-)
一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例
如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个
符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接
仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中，ls
命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。
关于链接的概念，看起来很迷惑，但不要胆怯。我们将要试着练习这些命令，希望，它变得
清晰起来。
5.12创建游戏场（实战演习）
下面我们将要做些真正的文件操作，让我们先建立一个安全地带，来玩一下文件操作命令。首
先，我们需要一个工作目录。在我们的家目录下创建一个叫做“playground”的目录。
5.13创建目录
mkdir命令被用来创建目录。首先确定我们在我们的家目录下，然后创建 playground目录：
[me@linuxbox~]$cd
[me@linuxbox~]$mkdirplayground
为了让我们的游戏场更加有趣，在 playground目录下创建一对目录，分别叫做“dir1”和
“dir2”。更改我们的当前工作目录到 playground，然后执行 mkdir命令：
51
[me@linuxbox~]$cdplayground
[me@linuxboxplayground]$mkdirdir1dir2
注意到 mkdir命令可以接受多个参数，它允许我们用一个命令来创建这两个目录。
#　复制文件
下一步，让我们输入一些数据到我们的游戏场中。我们可以通过复制一个文件来实现目的。
我们使用 cp命令从 /etc目录复制 passwd文件到当前工作目录下：
[me@linuxboxplayground]$cp/etc/passwd.
请注意，我们使用命令末尾的一个圆点来简化当前工作目录的写法。如果我们执行 ls命令，
可以看到我们的文件：
[me@linuxboxplayground]$ls-l
total12
drwxrwxr-x2meme40962008-01-1016:40dir1
drwxrwxr-x2meme40962008-01-1016:40dir2
-rw-r--r--1meme16502008-01-1016:07passwd
现在，仅仅是为了高兴，重复操作复制命令，使用 “-v”选项（详细），看看它做了些什么：
[me@linuxboxplayground]$cp-v/etc/passwd.
`/etc/passwd'->`./passwd'
cp命令再一次执行了复制操作，但是这次显示了一条简洁的信息，指明它进行了什么操作。
注意，cp没有警告，就重写了第一次复制的文件。这是一个案例，cp会假设你知道自己在做什
么。如果希望得到警告的话，需要加入“-i”（互动）选项：
[me@linuxboxplayground]$cp-i/etc/passwd.
cp:overwrite`./passwd'?
52
在提示信息后输入 “y”，文件就会被重写，输入其它的字符（例如，”n”）cp命令会保留原
文件。
5.14移动和重命名文件
现在，“passwd”这个名字，看起来不怎么有趣，这是个游戏场，所以我们给它改个名字：
[me@linuxboxplayground]$mvpasswdfun
让我们来传送 fun文件，通过移动重命名的文件到各个子目录，然后再把它移回到当前目
录：
[me@linuxboxplayground]$mvfundir1
首先，把 fun文件移动目录 dir1中，然后：
[me@linuxboxplayground]$mvdir1/fundir2
再把 fun文件从 dir1移到目录 dir2,然后：
[me@linuxboxplayground]$mvdir2/fun.
最后，再把 fun文件带回到当前工作目录。接下来，来看看移动目录的效果。首先，我们先
移动我们的数据文件到 dir1目录：
[me@linuxboxplayground]$mvfundir1
然后移动 dir1到 dir2目录，用 ls来确认执行结果:
53
[me@linuxboxplayground]$mvdir1dir2
[me@linuxboxplayground]$ls-ldir2
total4
drwxrwxr-x2meme40962008-01-1106:06dir1
[me@linuxboxplayground]$ls-ldir2/dir1
total4
-rw-r--r--1meme16502008-01-1016:33fun
注意：因为目录 dir2已经存在，mv命令会把 dir1移动到 dir2目录中。如果 dir2不存在，
mv会把 dir1重命名为 dir2。最后，让我们把所有的东西放回原处：
[me@linuxboxplayground]$mvdir2/dir1.
[me@linuxboxplayground]$mvdir1/fun.
5.15创建硬链接
现在，我们试着创建链接。首先是硬链接。我们创建一些关联我们数据文件的链接：
[me@linuxboxplayground]$lnfunfun-hard
[me@linuxboxplayground]$lnfundir1/fun-hard
[me@linuxboxplayground]$lnfundir2/fun-hard
所以现在，我们有四个文件 “fun”的实例。看一下目录 playground中的内容：
[me@linuxboxplayground]$ls-l
total16
drwxrwxr-x2meme40962008-01-1416:17dir1
drwxrwxr-x2meme40962008-01-1416:17dir2
-rw-r--r--4meme16502008-01-1016:33fun
-rw-r--r--4meme16502008-01-1016:33fun-hard
注意到一件事，列表中，文件 fun和 fun-hard的第二个字段是 “4”，这个数字是文件 “fun”
的硬链接数目。你要记得一个文件至少有一个硬链接，因为文件名就是由链接创建的。那么，
54
我们怎样知道实际上 fun和 fun-hard是同一个文件呢？在这个例子里，ls不是很有用。虽然我
们能够看到 fun和 fun-hard文件大小一样（第五字段），但我们的列表没有提供可靠的信息来
确定（这两个文件一样）。为了解决这个问题，我们更深入的研究一下。
当考虑到硬链接的时候，我们可以假设文件由两部分组成：包含文件内容的数据部分和持有
文件名的名字部分，这将有助于我们理解这个概念。当我们创建文件硬链接的时候，实际上是
为文件创建了额外的名字部分，并且这些名字都关联到相同的数据部分。这时系统会分配一连
串的磁盘块给所谓的索引节点，然后索引节点与文件名字部分相关联。因此每一个硬链接都关
系到一个具体的包含文件内容的索引节点。
ls命令有一种方法，来展示（文件索引节点）的信息。在命令中加上 “-i”选项：
[me@linuxboxplayground]$ls-li
total16
12353539drwxrwxr-x2meme40962008-01-1416:17dir1
12353540drwxrwxr-x2meme40962008-01-1416:17dir2
12353538-rw-r--r--4meme16502008-01-1016:33fun
12353538-rw-r--r--4meme16502008-01-1016:33fun-hard
在这个版本的列表中，第一字段表示文件索引节点号，正如我们所见到的，fun和 fun-hard
共享一样的索引节点号，这就证实这两个文件是同一个文件。
5.16创建符号链接
建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备，硬链接不能关
联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向目标文件或目录的文本指
针。
符号链接的建立过程相似于创建硬链接：
[me@linuxboxplayground]$ln-sfunfun-sym
[me@linuxboxplayground]$ln-s../fundir1/fun-sym
[me@linuxboxplayground]$ln-s../fundir2/fun-sym
第一个例子相当直接，在 ln命令中，简单地加上 “-s”选项就可以创建一个符号链接，而不
是一个硬链接。下面两个例子又是怎样呢？记住，当我们创建一个符号链接的时候，会建立一
55
个目标文件在哪里和符号链接有关联的文本描述。如果我们看看 ls命令的输出结果，比较容易
理解。
[me@linuxboxplayground]$ls-ldir1
total4
-rw-r--r--4meme16502008-01-1016:33fun-hard
lrwxrwxrwx1meme62008-01-1515:17fun-sym->../fun
目录 dir1中，fun-sym的列表说明了它是一个符号链接，通过在第一字段中的首字符 “l”
可知，并且它还指向 “../fun”，也是正确的。相对于 fun-sym的存储位置，fun在它的上一个目
录。同时注意，符号链接文件的长度是 6，这是字符串 “../fun”所包含的字符数，而不是符号
链接所指向的文件长度。
当建立符号链接时，你既可以使用绝对路径名：
ln-s/home/me/playground/fundir1/fun-sym
也可用相对路径名，正如前面例题所展示的。使用相对路径名更令人满意，因为它允许一个
包含符号链接的目录重命名或移动，而不会破坏链接。
除了普通文件，符号链接也能关联目录：
[me@linuxboxplayground]$ln-sdir1dir1-sym
[me@linuxboxplayground]$ls-l
total16
...省略
5.17移动文件和目录
正如我们之前讨论的，rm命令被用来删除文件和目录。我们将要使用它来清理一下我们的游
戏场。首先，删除一个硬链接：
56
[me@linuxboxplayground]$rmfun-hard
[me@linuxboxplayground]$ls-l
total12
...省略
结果不出所料。文件 fun-hard消失了，文件 fun的链接数从 4减到 3，正如目录列表第二
字段所示。下一步，我们会删除文件 fun，仅为了娱乐，我们会加入 “-i”选项，看一看它的作用：
[me@linuxboxplayground]$rm-ifun
rm:removeregularfile`fun'?
在提示符下输入 “y”，删除文件。让我们看一下 ls的输出结果。注意，fun-sym发生了什么
事?因为它是一个符号链接，指向已经不存在的文件，链接已经坏了：
[me@linuxboxplayground]$ls-l
total8
drwxrwxr-x2meme40962008-01-1515:17dir1
lrwxrwxrwx1meme42008-01-1614:45dir1-sym->dir1
drwxrwxr-x2meme40962008-01-1515:17dir2
lrwxrwxrwx1meme32008-01-1515:15fun-sym->fun
大多数 Linux的发行版本配置 ls显示损坏的链接。在 Fedora系统中，坏的链接以闪烁的
红色文本显示！损坏链接的出现，并不危险，但是相当混乱。如果我们试着使用损坏的链接，
会看到以下情况：
[me@linuxboxplayground]$lessfun-sym
fun-sym:Nosuchfileordirectory
稍微清理一下现场。删除符号链接：
57
[me@linuxboxplayground]$rmfun-symdir1-sym
[me@linuxboxplayground]$ls-l
total8
drwxrwxr-x2meme40962008-01-1515:17dir1
drwxrwxr-x2meme40962008-01-1515:17dir2
对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本
身。而 rm命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。
最后，我们将删除我们的游戏场。为了完成这个工作，我们将返回到我们的家目录，然后用
rm命令加上选项 (-r)，来删除目录 playground，和目录下的所有内容，包括子目录：
[me@linuxboxplayground]$cd
[me@linuxbox~]$rm-rplayground
用 GUI来创建符号链接
文件管理器 GNOME和 KDE都提供了一个简单而且自动化的方法来创建符号
链接。在 GNOME里面，当拖动文件时，同时按下 Ctrl+Shift按键会创建一个链
接，而不是复制（或移动）文件。在 KDE中，无论什么时候放下一个文件，会弹出
一个小菜单，这个菜单会提供复制，移动，或创建链接文件选项。
5.18总结
在这一章中，我们已经研究了许多基础知识。我们得花费一些时间来全面地理解。反复练习
playground例题，直到你觉得它有意义。能够良好地理解基本文件操作命令和通配符，非常重
要。随意通过添加文件和目录来拓展 playground练习，使用通配符来为各种各样的操作命令
指定文件。关于链接的概念，在刚开始接触时会觉得有点迷惑，花些时间来学习它们是怎样工
作的。它们能成为真正的救星。
58
6|使用命令
在这之前，我们已经知道了一系列神秘的命令，每个命令都有自己奇妙的选项和参数。在这一
章中，我们将试图去掉一些神秘性，甚至创建我们自己的命令。这一章将介绍以下命令：
• type–说明怎样解释一个命令名
• which–显示会执行哪个可执行程序
• man–显示命令手册页
• apropos–显示一系列适合的命令
• info–显示命令 info
• whatis–显示一个命令的简洁描述
• alias–创建命令别名
6.1到底什么是命令？
命令可以是下面四种形式之一：
1.是一个可执行程序，就像我们所看到的位于目录/usr/bin中的文件一样。这一类程序可
以是用诸如 C和 C++语言写成的程序编译的二进制文件,也可以是由诸如 shell，perl，
python，ruby等等脚本语言写成的程序。
2.是一个内建于 shell自身的命令。bash支持若干命令，内部叫做 shell内部命令 (builtins)。
例如，cd命令，就是一个 shell内部命令。
3.是一个 shell函数。这些是小规模的 shell脚本，它们混合到环境变量中。在后续的章节
里，我们将讨论配置环境变量以及书写 shell函数。但是现在，仅仅意识到它们的存在就
可以了。
4.是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。
59
6.2识别命令
这经常很有用，能确切地知道正在使用四类命令中的哪一类。Linux提供了一对方法来弄明白
命令类型。
6.3type－显示命令的类型
type命令是 shell内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。它像
这样工作：
typecommand
“command”是你要检测的命令名。这里有些例子：
[me@linuxbox~]$typetype
typeisashellbuiltins
[me@linuxbox~]$typels
lsisaliasedto`ls--color=tty`
[me@linuxbox~]$typecp
cpis/bin/cp
我们看到这三个不同命令的检测结果。注意，ls命令（在 Fedora系统中）的检查结果，ls
命令实际上是 ls命令加上选项 “--color=tty”的别名。现在我们知道为什么 ls的输出结果是有
颜色的！
6.4which－显示一个可执行程序的位置
有时候在一个操作系统中，不只安装了可执行程序的一个版本。虽然在桌面系统中这并不普遍，
但在大型服务器中却很平常。为了确定所给定的执行程序的准确位置，使用 which命令：
[me@linuxbox~]$whichls
/bin/ls
60
这个命令只对可执行程序有效，不包括内建命令和命令别名，别名是真正的可执行程序的替
代物。当我们试着使用 shell内建命令时，例如，cd命令，我们或者得不到回应，或者是个错
误信息：
[me@linuxbox~]$whichcd
/usr/bin/which:nocdin
(/opt/jre1.6.0_03/bin:/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/opt/jre1
.6.0_03/bin:/usr/lib/ccache:/usr/local/bin:/usr/bin:/bin:/home/me/bin)
说“命令没有找到”，真是很奇特。
6.5得到命令文档
知道了什么是命令，现在我们来寻找每一类命令的可得到的文档。
6.6help－得到shell内建命令的帮助文档
bash有一个内建的帮助工具，可供每一个 shell内建命令使用。输入“help”，接着是 shell内
部命令名。例如：
[me@linuxbox~]$helpcd
cd:cd[-L|-P][dir]
Change...
注意表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符表示互斥选
项。在上面 cd命令的例子中：
cd[-L|-P][dir]
这种表示法说明，cd命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。
虽然 cd命令的帮助文档很简洁准确，但它决不是教程。正如我们所看到的，它似乎提到了
许多我们还没有谈论到的东西！不要担心，我们会学到的。
61
6.7--help-显示用法信息
许多可执行程序支持一个 --help选项，这个选项是显示命令所支持的语法和选项说明。例如：
[me@linuxbox~]$mkdir--help
Usage:mkdir[OPTION]DIRECTORY...
Create...
一些程序不支持 --help选项，但不管怎样试一下。这经常会导致输出错误信息，但同时能
揭示一样的命令用法信息。
6.8man－显示程序手册页
许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页 (man page)。
一个特殊的叫做 man的分页程序，可用来浏览他们。它是这样使用的：
manprogram
“program”是要浏览的命令名。
手册文档的格式有点不同，一般地包含一个标题、命令语法的纲要、命令用途的说明、以
及每个命令选项的列表和说明。然而，手册文档通常并不包含实例，它打算作为一本参考手册，
而不是教程。作为一个例子，浏览一下 ls命令的手册文档：
[me@linuxbox~]$manls
在大多数 Linux系统中，man使用 less工具来显示参考手册，所以当浏览文档时，你所熟
悉的 less命令都能有效。
man所显示的参考手册，被分成几个章节，它们不仅仅包括用户命令，也包括系统管理员
命令、程序接口、文件格式等等。下表描绘了手册的布局：
章节内容
1用户命令
62
2程序接口内核系统调用
3 C库函数程序接口
4特殊文件，比如说设备结点和驱动程序
5文件格式
6游戏娱乐，如屏幕保护程序
7其他方面
8系统管理员命令
表 6-1:手册页的组织形式
有时候，我们需要查看参考手册的特定章节，从而找到我们需要的信息。如果我们要查找一
种文件格式，而同时它也是一个命令名时,这种情况尤其正确。没有指定章节号，我们总是得
到第一个匹配项，可能在第一章节。我们这样使用 man命令，来指定章节号：
mansectionsearch_term
例如：
[me@linuxbox~]$man5passwd
命令运行结果会显示文件 /etc/passwd的文件格式说明手册。
6.9apropos－显示适当的命令
也有可能搜索参考手册列表，基于某个关键字的匹配项。虽然很粗糙但有时很有用。下面是一
个以 “floppy”为关键词来搜索参考手册的例子：
[me@linuxbox~]$aproposfloppy
create_floppy_devices(8)-udevcallouttocreateallpossible
...
输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man命令加上
“-k”选项，和 apropos完成一样的功能。
63
6.10whatis－显示非常简洁的命令说明
whatis程序显示匹配特定关键字的手册页的名字和一行命令说明：
最晦涩难懂的手册页
正如我们所看到的，Linux和类 Unix的系统提供的手册页，只是打算作为参考
手册使用，而不是教程。许多手册页都很难阅读，但是我认为由于阅读难度而能拿
到特等奖的手册页应该是 bash手册页。因为我正在为这本书做我的研究，所以我
很仔细地浏览了整个 bash手册，为的是确保我讲述了大部分的 bash主题。当把
bash参考手册整个打印出来，其篇幅有八十多页且内容极其紧密，但对于初学者来
说，其结构安排毫无意义。
另一方面，bash参考手册的内容非常简明精确，同时也非常完善。所以，如果
你有胆量就查看一下，并且期望有一天你能读懂它。
6.11info－显示程序Info条目
GNU项目提供了一个命令程序手册页的替代物，称为 “info”。info内容可通过 info阅读器程
序读取。info页是超级链接形式的，和网页很相似。这有个例子：
File:coreutils.info,Node:lsinvocation,Next:dirinvocation,
Up:Directorylisting
10.1`ls':Listdirectorycontents
==================================
...
info程序读取 info文件，info文件是树型结构，分化为各个结点，每一个包含一个题目。
info文件包含超级链接，它可以让你从一个结点跳到另一个结点。一个超级链接可通过它开头
的星号来辨别出来，把光标放在它上面并按下 enter键，就可以激活它。
输入 “info”，接着输入程序名称，启动 info。下表中的命令，当显示一个 info页面时，用来
控制阅读器。
命令行为
64
?显示命令帮助
PgUp or Backspace显示上一页
PgDn or Space显示下一页
n下一个 -显示下一个结点
p上一个 -显示上一个结点
u Up -显示当前所显示结点的父结点，通常是个
菜单
Enter激活光标位置下的超级链接
q退出
表 6-2: info命令
到目前为止，我们所讨论的大多数命令行程序，属于 GNU项目 “coreutils”包，所以输入：
[me@linuxbox~]$infocoreutils
将会显示一个包含超级链接的手册页，这些超级链接指向包含在 coreutils包中的各个程序。
6.12README和其它程序文档
许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc目录下。这
些文件大多数是以文本文件的形式存储的，可用 less阅读器来浏览。一些文件是 HTML格式，
可用网页浏览器来阅读。我们可能遇到许多以 “.gz”结尾的文件。这表示 gzip压缩程序已经压
缩了这些文件。gzip软件包包括一个特殊的 less版本，叫做 zless，zless可以显示由 gzip压缩
的文本文件的内容。
6.13用别名（alias）创建你自己的命令
现在是时候，感受第一次编程经历了！我们将用 alias命令创建我们自己的命令。但在开始之
前，我们需要展示一个命令行小技巧。可以把多个命令放在同一行上，命令之间用 “;”分开。
它像这样工作：
65
command1;command2;command3...
我们会用到下面的例子：
[me@linuxbox~]$cd/usr;ls;cd-
bingameskerberoslib64localsharetmp
...
[me@linuxbox~]$
正如我们看到的，我们在一行上联合了三个命令。首先更改目录到/usr，然后列出目录内容，
最后回到原始目录（用命令 “cd -”）,结束在开始的地方。现在，通过 alias命令把这一串命令
转变为一个命令。我们要做的第一件事就是为我们的新命令构想一个名字。比方说 “test”。在
使用”test”之前，查明是否 “test”命令名已经存在系统中，是个很不错的主意。为了查清此事，
可以使用 type命令：
[me@linuxbox~]$typetest
testisashellbuiltin
哦！“test”名字已经被使用了。试一下”foo”:
[me@linuxbox~]$typefoo
bash:type:foo:notfound
太棒了！“foo”还没被占用。创建命令别名：
[me@linuxbox~]$aliasfoo='cd/usr;ls;cd-'
注意命令结构：
66
aliasname='string'
在命令 “alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是一串用引
号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后，这个命令别名可以使
用在任何地方。试一下：
[me@linuxbox~]$foo
bingameskerberoslib64localsharetmp
...
[me@linuxbox~]$
我们也可以使用 type命令来查看我们的别名：
[me@linuxbox~]$typefoo
fooisaliasedto`cd/usr;ls;cd-'
删除别名，使用 unalias命令，像这样：
[me@linuxbox~]$unaliasfoo
[me@linuxbox~]$typefoo
bash:type:foo:notfound
虽然我们有意避免使用已经存在的命令名来命名我们的别名，但这是常做的事情。通常，会
把一个普遍用到的选项加到一个经常使用的命令后面。例如，之前见到的 ls命令，会带有色彩
支持：
[me@linuxbox~]$typels
lsisaliasedto'ls--color=tty'
要查看所有定义在系统环境中的别名，使用不带参数的 alias命令。下面在 Fedora系统中
默认定义的别名。试着弄明白，它们是做什么的：
67
[me@linuxbox~]$alias
aliasl.='ls-d.*--color=tty'
...
在命令行中定义别名有点儿小问题。当你的 shell会话结束时，它们会消失。随后的章节里，
我们会了解怎样把自己的别名添加到文件中去，每次我们登录系统，这些文件会建立系统环境。
现在，好好享受我们刚经历过的，步入 shell编程世界的第一步吧，虽然微小。
6.14拜访老朋友
既然我们已经学习了怎样找到命令的帮助文档，那就试着查阅，到目前为止，我们学到的所有
命令的文档。学习命令其它可用的选项，练习一下！
6.15拓展阅读
•在网上，有许多关于 Linux和命令行的文档。以下是一些最好的文档：
• Bash参考手册是一本 bash shell的参考指南。它仍然是一本参考书，但是包含了很多实
例，而且它比 bash手册页容易阅读。
http://www.gnu.org/software/bash/manual/bashref.html
• Bash FAQ包含关于 bash，而经常提到的问题的答案。这个列表面向 bash的中高级用
户，但它包含了许多有帮助的信息。
http://mywiki.wooledge.org/BashFAQ
• GUN项目为它的程序提供了大量的文档，这些文档组成了 Linux命令行实验的核心。这
里你可以看到一个完整的列表：
http://www.gnu.org/manual/manual.html
• Wikipedia有一篇关于手册页的有趣文章：
http://en.wikipedia.org/wiki/Man_page
68
7|重定向
这堂课，我们来介绍可能是命令行最酷的特性。它叫做 I/O重定向。“I/O”代表输入/输出，通
过这个工具，你可以将命令的输入来源以及输出地点重定向为文件。也可以把多个命令连接起
来组成一个强大的命令管道。为了展示这个工具，我们将叙述以下命令：
• cat－连接文件
• sort－排序文本行
• uniq－报道或省略重复行
• grep－打印匹配行
• wc－打印文件中换行符，字，和字节个数
• head－输出文件第一部分
• tail -输出文件最后一部分
• tee -从标准输入读取数据，并同时写到标准输出和文件
7.1标准输入、输出和错误
到目前为止，我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成。第一，
程序运行结果；这是说，程序要完成的功能。第二，我们得到状态和错误信息，这些告诉我们
程序进展。如果我们观察一个命令，像 ls，会看到它的运行结果和错误信息显示在屏幕上。
与 Unix主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行
结果输送到一个叫做标准输出的特殊文件（经常用 stdout表示），而它们的状态信息则送到另
一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是
保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情
况下，标准输入连接到键盘。
69
I/O重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，但
是通过 I/O重定向，我们可以做出改变。
7.2标准输出重定向
I/O重定向允许我们来重定义标准输出的地点。我们使用 “>”重定向符后接文件名将标准输
出重定向到除屏幕以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运
行结果存储到一个文件很有用处。例如，我们可以告诉 shell把 ls命令的运行结果输送到文件
ls-output.txt中去，由文件代替屏幕。
[me@linuxbox~]$ls-l/usr/bin>ls-output.txt
这里，我们创建了一个长长的目录/usr/bin列表，并且输送程序运行结果到文件ls-output.txt
中。我们检查一下重定向的命令输出结果：
[me@linuxbox~]$ls-lls-output.txt
-rw-rw-r--1meme1678782008-02-0115:07ls-output.txt
好；一个不错的大型文本文件。如果我们用 less阅读器来查看这个文件，我们会看到文件
ls-output.txt的确包含 ls命令的执行结果。
[me@linuxbox~]$lessls-output.txt
现在，重复我们的重定向测试，但这次有改动。我们把目录换成一个不存在的目录。
[me@linuxbox~]$ls-l/bin/usr>ls-output.txt
ls:cannotaccess/bin/usr:Nosuchfileordirectory
我们收到一个错误信息。这讲得通，因为我们指定了一个不存在的目录/bin/usr,但是为什
么这条错误信息显示在屏幕上而不是被重定向到文件 ls-output.txt？答案是，ls程序不把它的
错误信息输送到标准输出。反而，像许多写得不错的 Unix程序，ls把错误信息送到标准错误。
70
因为我们只是重定向了标准输出，而没有重定向标准错误，所以错误信息被送到屏幕。马上，
我们将知道怎样重定向标准错误，但是首先看一下我们的输出文件发生了什么事情。
me@linuxbox~]$ls-lls-output.txt
-rw-rw-r--1meme02008-02-0115:08ls-output.txt
文件长度为零！这是因为，当我们使用 “>”重定向符来重定向输出结果时，目标文件总是
从开头被重写。因为我们 ls命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，
然后由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创
建一个新的空文件），可以使用这样的技巧：
[me@linuxbox~]$>ls-output.txt
简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是创建一个新
的空文件。
所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目
的，我们使用 “>>”重定向符，像这样：
[me@linuxbox~]$ls-l/usr/bin>>ls-output.txt
使用 “>>”操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会被创
建，就如使用了 “>”操作符。把它放到测试中：
[me@linuxbox~]$ls-l/usr/bin>>ls-output.txt
[me@linuxbox~]$ls-lls-output.txt
-rw-rw-r--1meme5036342008-02-0115:45ls-output.txt
我们重复执行命令三次，导致输出文件大小是原来的三倍。
71
7.3标准错误重定向
标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述
符。一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的
前三个称作标准输入、输出和错误，shell内部分别将其称为文件描述符 0、1和 2。shell使用
文件描述符提供了一种表示法来重定向文件。因为标准错误和文件描述符 2一样，我们用这种
表示法来重定向标准错误：
[me@linuxbox~]$ls-l/bin/usr2>ls-error.txt
文件描述符 “2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt
任务。
7.4重定向标准输出和错误到同一个文件
可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们必须同
时重定向标准输出和标准错误。有两种方法来完成任务。第一个，传统的方法，在旧版本 shell
中也有效：
[me@linuxbox~]$ls-l/bin/usr>ls-output.txt2>&1
使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后重定
向文件描述符 2（标准错误）到文件描述符 1（标准输出）使用表示法 2>&1。
注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后，
要不然它不起作用。上面的例子，
>ls-output.txt2>&1
重定向标准错误到文件 ls-output.txt，但是如果命令顺序改为：
72
2>&1>ls-output.txt
则标准错误定向到屏幕。
现在的 bash版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。
[me@linuxbox~]$ls-l/bin/usr&>ls-output.txt
在这个例子里面，我们使用单单一个表示法 &>来重定向标准输出和错误到文件 ls-
output.txt。
7.5处理不需要的输出
有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况尤其适用于
错误和状态信息。系统通过重定向输出结果到一个叫做 “/dev/null”的特殊文件，为我们提供
了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做
任何处理。为了隐瞒命令错误信息，我们这样做：
[me@linuxbox~]$ls-l/bin/usr2>/dev/null
Unix文化中的/dev/null
位存储桶是个古老的 Unix概念，由于它的普遍性，它的身影出现在 Unix文化
的许多部分。当有人说他/她正在发送你的评论到/dev/null，现在你应该知道那是
什么意思了。更多的例子，可以阅读 Wikipedia关于 “/dev/null”的文章。
7.6标准输入重定向
到目前为止，我们还没有遇到一个命令是利用标准输入的（实际上我们遇到过了，但是一会儿
再揭晓谜底），所以我们需要介绍一个。
73
7.7cat－连接文件
cat命令读取一个或多个文件，然后复制它们到标准输出，就像这样:
cat[file]
在大多数情况下，你可以认为 cat命令相似于 DOS中的 TYPE命令。你可以使用 cat来
显示文件而没有分页，例如：
[me@linuxbox~]$catls-output.txt
将会显示文件 ls-output.txt的内容。cat经常被用来显示简短的文本文件。因为 cat可以接
受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个大型
文件，这个文件被分离成多个部分（USENET中的多媒体文件经常以这种方式分离），我们想
把它们连起来。如果文件命名为：
我们能用这个命令把它们连接起来：
catmovie.mpeg.0*>movie.mpeg
因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。
这很好，但是这和标准输入有什么关系呢？没有任何关系，让我们试着做些其他的工作。如
果我们输入不带参数的 “cat”命令，会发生什么呢：
[me@linuxbox~]$cat
没有发生任何事情，它只是坐在那里，好像挂掉了一样。看起来是那样，但是它正在做它该
做的事情：
如果 cat没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到
键盘，它正在等待我们输入数据！试试这个：
74
[me@linuxbox~]$cat
Thequickbrownfoxjumpedoverthelazydog.
下一步，输入 Ctrl-d（按住 Ctrl键同时按下 “d”），来告诉 cat，在标准输入中，它已经到
达文件末尾（EOF）：
[me@linuxbox~]$cat
Thequickbrownfoxjumpedoverthelazydog.
由于没有文件名参数，cat复制标准输入到标准输出，所以我们看到文本行重复出现。我们
可以使用这种行为来创建简短的文本文件。比方说，我们想创建一个叫做 “lazy_dog.txt”的文
件，这个文件包含例子中的文本。我们这样做：
[me@linuxbox~]$cat>lazy_dog.txt
Thequickbrownfoxjumpedoverthelazydog.
输入命令，其后输入要放入文件中的文本。记住，最后输入 Ctrl-d。通过使用这个命令，我
们实现了世界上最低能的文字处理器！看一下运行结果，我们使用 cat来复制文件内容到标准
输出：
[me@linuxbox~]$catlazy_dog.txt
Thequickbrownfoxjumpedoverthelazydog.
现在我们知道 cat怎样接受标准输入，除了文件名参数，让我们试着重定向标准输入：
[me@linuxbox~]$cat<lazy_dog.txt
Thequickbrownfoxjumpedoverthelazydog.
使用“<”重定向操作符，我们把标准输入源从键盘改到文件 lazy_dog.tx。我们看到结果
和传递单个文件名作为参数的执行结果一样。把这和传递一个文件名参数作比较，不是特别有
75
意义，但它是用来说明把一个文件作为标准输入源。有其他的命令更好地利用了标准输入，我
们不久将会看到。
在我们继续之前，查看 cat的手册页，因为它有几个有趣的选项。
7.8管道线
命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell特性所利用。使
用管道操作符 “|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：
command1|command2
为了全面地说明这个命令，我们需要一些命令。是否记得我们说过，我们已经知道有一个命
令接受标准输入？它是 less命令。我们用 less来一页一页地显示任何命令的输出，命令把它的
运行结果输送到标准输出：
[me@linuxbox~]$ls-l/usr/bin|less
这极其方便！使用这项技术，我们可以方便地检测会产生标准输出的任一命令的运行结果。
7.9过滤器
管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，
以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。第
一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin和/usr/bin中的可执行程序都
联合在一起，再把它们排序，然后浏览执行结果：
[me@linuxbox~]$ls/bin/usr/bin|sort|less
因为我们指定了两个目录（/bin和/usr/bin），ls命令的输出结果由有序列表组成，各自针
对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个有序列表。
76
7.10uniq-报道或忽略重复行
uniq命令经常和 sort命令结合在一起使用。uniq从标准输入或单个文件名参数接受数据有序
列表（详情查看 uniq手册页），默认情况下，从数据列表中删除任何重复行。所以，为了确信
我们的列表中不包含重复句子（这是说，出现在目录/bin和/usr/bin中重名的程序），我们添
加 uniq到我们的管道线中：
[me@linuxbox~]$ls/bin/usr/bin|sort|uniq|less
在这个例子中，我们使用 uniq从 sort命令的输出结果中，来删除任何重复行。如果我们想
看到重复的数据列表，让 uniq命令带上 “-d”选项，就像这样：
[me@linuxbox~]$ls/bin/usr/bin|sort|uniq-d|less
7.11wc－打印行数、字数和字节数
wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。例如：
[me@linuxbox~]$wcls-output.txt
790264566503634ls-output.txt
在这个例子中，wc打印出来三个数字：包含在文件 ls-output.txt中的行数，单词数和字节
数，正如我们先前的命令，如果 wc不带命令行参数，它接受标准输入。“-l”选项限制命令输出
只能报道行数。添加 wc到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程
序个数，我们可以这样做：
[me@linuxbox~]$ls/bin/usr/bin|sort|uniq|wc-l
2728
77
7.12grep－打印匹配行
grep是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep命令：
greppattern[file...]
当 grep遇到一个文件中的匹配 “模式”，它会打印出包含这个类型的行。grep能够匹配的
模式可以很复杂，但是现在我们把注意力集中在简单文本匹配上面。在后面的章节中，我们将
会研究高级模式，叫做正则表达式。
比如说，我们想在我们的程序列表中，找到文件名中包含单词 “zip”的所有文件。这样一个
搜索，可能让我们了解系统中的一些程序与文件压缩有关系。这样做：
[me@linuxbox~]$ls/bin/usr/bin|sort|uniq|grepzip
bunzip2
bzip2
gunzip
...
grep有一些方便的选项：“-i”使得 grep在执行搜索时忽略大小写（通常，搜索是大小写敏
感的），“-v”选项会告诉 grep只打印不匹配的行。
7.13head/tail－打印文件开头部分/结尾部分
有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。head命
令打印文件的前十行，而 tail命令打印文件的后十行。默认情况下，两个命令都打印十行文本，
但是可以通过 “-n”选项来调整命令打印的行数。
[me@linuxbox~]$head-n5ls-output.txt
total343496
...
[me@linuxbox~]$tail-n5ls-output.txt
...
78
它们也能用在管道线中：
[me@linuxbox~]$ls/usr/bin|tail-n5
znew
...
tail有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同
时在被写入。在以下的例子里，我们要查看目录/var/log里面的信息文件。在一些 Linux发行
版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages可能包含安全信
息。
[me@linuxbox~]$tail-f/var/log/messages
Feb813:40:05twin4dhclient:DHCPACKfrom192.168.1.1
....
使用 “-f”选项，tail命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在
屏幕上。这会一直继续下去直到你输入 Ctrl-c。
7.14tee－从Stdin读取数据，并同时输出到Stdout和文件
为了和我们的管道隐喻保持一致，Linux提供了一个叫做 tee的命令，这个命令制造了一个
“tee”，安装到我们的管道上。tee程序从标准输入读入数据，并且同时复制数据到标准输出（允
许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的
内容时，这很有帮助。这里，我们重复执行一个先前的例子，这次包含 tee命令，在 grep过滤
管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：
[me@linuxbox~]$ls/usr/bin|teels.txt|grepzip
bunzip2
bzip2
....
79
7.15总结归纳
一如既往，查看这章学到的每一个命令的文档。我们已经知道了他们最基本的用法。它们还有
很多有趣的选项。随着我们 Linux经验的积累，我们会了解命令行重定向特性在解决特殊问题
时非常有用处。有许多命令利用标准输入和输出，而几乎所有的命令行程序都使用标准错误来
显示它们的详细信息。
Linux可以激发我们的想象
当我被要求解释 Windows与 Linux之间的差异时，我经常拿玩具来作比喻。
Windows就像一个游戏机。你去商店，买了一个包装在盒子里面的全新的游戏
机。你把它带回家，打开盒子，开始玩游戏。精美的画面，动人的声音。玩了一段
时间之后，你厌倦了它自带的游戏，所以你返回商店，又买了另一个游戏机。这个
过程反复重复。最后，你玩腻了游戏机自带的游戏，你回到商店，告诉售货员，“我
想要一个这样的游戏！”但售货员告诉你没有这样的游戏存在，因为它没有“市场
需求”。然后你说，“但是我只需要修改一下这个游戏！“，售货员又告诉你不能修改
它。所有游戏都被封装在它们的存储器中。到头来，你发现你的玩具只局限于别人
为你规定好的游戏。
另一方面，Linux就像一个全世界上最大的建造模型。你打开它，发现它只是一
个巨大的部件集合。有许多钢支柱、螺钉、螺母、齿轮、滑轮、发动机和一些怎样
来建造它的说明书。然后你开始摆弄它。你建造了一个又一个样板模型。过了一会
儿，你发现你要建造自己的模型。你不必返回商店，因为你已经拥有了你需要的一
切。建造模型以你构想的形状为模板，搭建你想要的模型。
当然，选择哪一个玩具，是你的事情，那么你觉得哪个玩具更令人满意呢？
80
8|从shell眼中看世界
在这一章我们将看到，当你按下 enter键后，发生在命令行中的一些“魔法”。尽管我们会深入
研究几个复杂而有趣的 shell特性，但我们只需要使用一个新命令：
• echo－显示一行文本
8.1(字符)展开
每当你输入一个命令并按下 enter键，bash会在执行你的命令之前对输入的字符完成几个步骤
的处理。我们已经见过几个例子：例如一个简单的字符序列 “*”,对 shell来说有着多么丰富的
涵义。这背后的的过程叫做（字符）展开。通过展开，你输入的字符，在 shell对它起作用之
前，会展开成为别的字符。为了说明这一点，让我们看一看 echo命令。echo是一个 shell内建
命令，可以完成非常简单的任务。它将它的文本参数打印到标准输出中。
[me@linuxbox~]$echothisisatest
thisisatest
这个命令的作用相当简单明了。传递到 echo命令的任一个参数都会在（屏幕上）显示出
来。让我们试试另一个例子：
[me@linuxbox~]$echo*
DesktopDocumentsls-output.txtMusicPicturesPublicTemplatesVideos
那么刚才发生了什么事情呢？为什么 echo不打印 “*”呢？如果你回忆起我们所学过的关于
通配符的内容，这个 “*”字符意味着匹配文件名中的任意字符，但在原先的讨论中我们并不知
道 shell是怎样实现这个功能的。简单的答案就是 shell在 echo命令被执行前把 “*”展开成了
81
另外的东西（在这里，就是在当前工作目录下的文件名字）。当回车键被按下时，shell在命令
被执行前在命令行上自动展开任何符合条件的字符，所以 echo命令的实际参数并不是 “*”，而
是它展开后的结果。知道了这个以后，我们就能明白 echo的行为符合预期。
8.2路径名展开
通配符所依赖的工作机制叫做路径名展开。如果我们试一下在之前的章节中使用的技巧，我们
会看到它们实际上是展开。给定一个家目录，它看起来像这样：
[me@linuxbox~]$ls
Desktopls-output.txtPicturesTemplates
....
我们能够执行以下的展开：
[me@linuxbox~]$echoD*
DesktopDocuments
和：
[me@linuxbox~]$echo*s
DocumentsPicturesTemplatesVideos
甚至是：
[me@linuxbox~]$echo[[:upper:]]*
DesktopDocumentsMusicPicturesPublicTemplatesVideos
查看家目录之外的目录：
82
[me@linuxbox~]$echo/usr/*/share
/usr/kerberos/share/usr/local/share
隐藏文件路径名展开
正如我们知道的，以圆点字符开头的文件名是隐藏文件。路径名展开也尊重这种
行为。像这样的展开：
echo*
不会显示隐藏文件
直觉告诉我们，如果展开模式以一个圆点开头，我们就能够在展开中包含隐藏文
件，就像这样：
echo.*
它几乎要起作用了。然而，如果我们仔细检查一下输出结果，我们会看到名字
“.”和 “..”也出现在结果中。由于它们是指当前工作目录和父目录，使用这种模式可
能会产生不正确的结果。我们可以通过这个命令来验证：
ls-d.*|less
为了在这种情况下正确地完成路径名展开，我们应该使用一个更精确的模式。这
个模式会正确地工作：
ls-d.[!.]?*
这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字
符，并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数
的隐藏文件（但仍不能包含以多个圆点开头的文件名）。带有 -A选项（“几乎所有”）
的 ls命令能够提供一份正确的隐藏文件清单：
ls-A
8.3波浪线展开
可能你从我们对 cd命令的介绍中回想起来，波浪线字符 (“”)有特殊的含义。当它用在一个
单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的
家目录：
83
[me@linuxbox~]$echo~
/home/me
如果有用户 “foo”这个帐号，那么：
[me@linuxbox~]$echo~foo
/home/foo
8.4算术表达式展开
shell在展开中执行算数表达式。这允许我们把 shell提示当作计算器来使用：
[me@linuxbox~]$echo$((2+2))
4
算术表达式展开使用这种格式：
$((expression))
（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。
算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。这里是
一些它支持的操作符：
操作符说明
+加
-减
*乘
/除（但是记住，因为展开只是支持整数除法，所以结果是整
数。）
%取余，只是简单的意味着，“余数”
84
**取幂
表 8-1:算术操作符
在算术表达式中空格并不重要，并且表达式可以嵌套。例如，5的平方乘以 3：
[me@linuxbox~]$echo$(($((5**2))*3))
75
一对括号可以用来把多个子表达式括起来。通过这个技术，我们可以重写上面的例子，同时
用一个展开代替两个，来得到一样的结果：
[me@linuxbox~]$echo$(((5**2)*3))
75
这是一个使用除法和取余操作符的例子。注意整数除法的结果：
[me@linuxbox~]$echoFivedividedbytwoequals$((5/2))
Fivedividedbytwoequals2
[me@linuxbox~]$echowith$((5%2))leftover.
with1leftover.
在 35章会更深入地讨论算术表达式的内容。
8.5花括号展开
可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中创建多个文本字
符串。这是一个例子：
[me@linuxbox~]$echoFront-{A,B,C}-Back
Front-A-BackFront-B-BackFront-C-Back
85
花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式
本身可能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这
种模式不能嵌入空白字符。这个例子中使用了一个整数区间：
[me@linuxbox~]$echoNumber_{1..5}
Number_1Number_2Number_3Number_4Number_5
倒序排列的字母区间：
[me@linuxbox~]$echo{Z..A}
ZYXWVUTSRQPONMLKJIHGFEDCBA
花括号展开可以嵌套：
[me@linuxbox~]$echoa{A{1,2},B{3,4}}b
aA1baA2baB3baB4b
那么这对什么有好处呢？最常见的应用是，创建一系列的文件或目录列表。例如，如果我们
是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先，我们要创建一系列
以数值 “年－月”形式命名的目录。通过这种方式，可以使目录名按照年代顺序排列。我们可
以手动键入整个目录列表，但是工作量太大了，并且易于出错。反之，我们可以这样做：
[me@linuxbox~]$mkdirPics
[me@linuxbox~]$cdPics
[me@linuxboxPics]$mkdir{2007..2009}-0{1..9}{2007..2009}-{10..12}
[me@linuxboxPics]$ls
2007-012007-072008-012008-072009-012009-07
2007-022007-082008-022008-082009-022009-08
2007-032007-092008-032008-092009-032009-09
2007-042007-102008-042008-102009-042009-10
2007-052007-112008-052008-112009-052009-11
2007-062007-122008-062008-122009-062009-12
棒极了！
86
8.6参数展开
在这一章我们将会简单介绍参数展开，但会在后续章节中进行详细讨论。这个特性在 shell脚
本中比直接在命令行中更有用。它的许多功能和系统存储小块数据，并给每块数据命名的能力
有关系。许多像这样的小块数据，更恰当的称呼应该是变量，可供你方便地检查它们。例如，
叫做 “USER”的变量包含你的用户名。可以这样做来调用参数，并查看 USER中的内容，：
[me@linuxbox~]$echo$USER
me
要查看有效的变量列表，可以试试这个：
[me@linuxbox~]$printenv|less
你可能注意到在其它展开类型中，如果你误输入一个模式，展开就不会发生。这时 echo命
令只简单地显示误键入的模式。但在参数展开中，如果你拼写错了一个变量名，展开仍然会进
行，只是展开的结果是一个空字符串：
[me@linuxbox~]$echo$SUER
[me@linuxbox~]$
8.7命令替换
命令替换允许我们把一个命令的输出作为一个展开模式来使用：
[me@linuxbox~]$echo$(ls)
DesktopDocumentsls-output.txtMusicPicturesPublicTemplates
Videos
我最喜欢用的一行命令是像这样的：
87
[me@linuxbox~]$ls-l$(whichcp)
-rwxr-xr-x1rootroot715162007-12-0508:58/bin/cp
这里我们把 which cp的执行结果作为一个参数传递给 ls命令，因此可以在不知道 cp命令
完整路径名的情况下得到它的文件属性列表。我们不只限制于简单命令。也可以使用整个管道
线（只展示部分输出）：
[me@linuxbox~]$file$(ls/usr/bin/*|grepzip)
/usr/bin/bunzip2:symboliclinkto`bzip2'
....
在这个例子中，管道线的输出结果成为 file命令的参数列表。
在旧版 shell程序中，有另一种语法也支持命令替换，可与刚提到的语法轮换使用。bash也
支持这种语法。它使用倒引号来代替美元符号和括号：
[me@linuxbox~]$ls-l`whichcp`
-rwxr-xr-x1rootroot715162007-12-0508:58/bin/cp
8.8引用
我们已经知道 shell有许多方式可以完成展开，现在是时候学习怎样来控制展开了。以下面例
子来说明：
[me@linuxbox~]$echothisisatest
thisisatest
或者：
[me@linuxbox~]$echoThetotalis$100.00
Thetotalis00.00
88
在第一个例子中，shell利用单词分割删除掉 echo命令的参数列表中多余的空格。在第二个
例子中，参数展开把$1的值替换为一个空字符串，因为1是没有定义的变量。shell提供了一
种叫做引用的机制，来有选择地禁止不需要的展开。
8.9双引号
我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中，shell使用的特殊字
符，都失去它们的特殊含义，被当作普通字符来看待。有几个例外：$，\ (反斜杠），和 ‘（倒
引号）。这意味着单词分割、路径名展开、波浪线展开和花括号展开都将失效，然而参数展开、
算术展开和命令替换仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是
不幸的名为twowords.txt文件的受害者。如果我们试图在命令行中使用这个文件，单词分割机
制会导致这个文件名被看作两个独自的参数，而不是所期望的单个参数：
[me@linuxbox~]$ls-ltwowords.txt
ls:cannotaccesstwo:Nosuchfileordirectory
ls:cannotaccesswords.txt:Nosuchfileordirectory
使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复破损的
文件名。
[me@linuxbox~]$ls-l"twowords.txt"
-rw-rw-r--1meme182008-02-2013:03twowords.txt
[me@linuxbox~]$mv"twowords.txt"two_words.txt
你瞧！现在我们不必一直输入那些讨厌的双引号了。
记住，在双引号中，参数展开、算术表达式展开和命令替换仍然有效：
[me@linuxbox~]$echo"$USER$((2+2))$(cal)"
me4February2008
SuMoTuWeThFrSa
....
我们应该花费一点时间来看一下双引号在命令替换中的效果。首先仔细研究一下单词分割
是怎样工作的。在之前的范例中，我们已经看到单词分割机制是怎样来删除文本中额外空格的：
89
[me@linuxbox~]$echothisisatest
thisisatest
在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作单词
之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分，它们只作为分
隔符使用。由于它们把单词分为不同的参数，所以在上面的例子中，命令行包含一个带有四个
不同参数的命令。如果我们加上双引号：
[me@linuxbox~]$echo"thisisatest"
thisisatest
单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。一旦加上双引
号，我们的命令行就包含一个带有一个参数的命令。
事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个虽然微妙但有趣的影
响。考虑下面的例子：
[me@linuxbox~]$echo$(cal)
February2008SuMoTuWeThFrSa1234567891011121314
151617181920212223242526272829
[me@linuxbox~]$echo"$(cal)"
February2008
....
在第一个实例中，没有引用的命令替换导致命令行包含 38个参数。在第二个例子中，命令
行只有一个参数，参数中包括嵌入的空格和换行符。
8.10单引号
如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较
结果：
90
[me@linuxbox~]$echotext~/*.txt{a,b}$(echofoo)$((2+2))$USER
text/home/me/ls-output.txtabfoo4me
[me@linuxbox~]$echo"text~/*.txt{a,b}$(echofoo)$((2+2))$USER"
text~/*.txt{a,b}foo4me
[me@linuxbox~]$echo'text~/*.txt{a,b}$(echofoo)$((2+2))$USER'
text~/*.txt{a,b}$(echofoo)$((2+2))$USER
正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。
8.11转义字符
有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。
经常在双引号中使用转义字符，来有选择地阻止展开。
[me@linuxbox~]$echo"Thebalanceforuser$USERis:\$5.00"
Thebalanceforusermeis:$5.00
使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使
用一些对于 shell来说有特殊含义的字符。这些字符包括 “$”, ”¡‘, ” ”等字符。在文件名中包含
特殊字符，你可以这样做：
[me@linuxbox~]$mvbad\&filenamegood_filename
为了允许反斜杠字符出现，输入 “\”来转义。注意在单引号中，反斜杠失去它的特殊含义，
它被看作普通字符。
反斜杠转义字符序列
反斜杠除了作为转义字符外，也可以构成一种表示法，来代表某种特殊字符，这
些特殊字符叫做控制码。ASCII编码表中前 32个字符被用来把命令转输到电报机
之类的设备。一些编码是众所周知的（制表符，退格符，换行符，和回车符），而其
它一些编码就不熟悉了（空值，传输结束码，和确认）。
91
转义序列含义
\a响铃（“警告”－导致计算机嘟嘟响）
\b退格符
\n新的一行。在类 Unix系统中，产生换行。
\r回车符
\t制表符
上表列出了一些常见的反斜杠转义字符序列。这种利用反斜杠的表示法背后的
思想来源于 C编程语言，许多其它语言也采用了这种表示方法，包括 shell。
echo命令带上 ‘-e’选项，能够解释转义序列。你可以把转义序列放在 $’ ’里面。
以下例子中，我们可以使用 sleep命令创建一个简单的倒数计数器（sleep是一个简
单的程序，它会等待指定的秒数，然后退出）：
sleep10;echo-e”Time’sup\a”
我们也可以这样做：
sleep10;echo”Time’sup”$’\a’
8.12总结归纳
随着我们继续学习 shell，你会发现使用展开和引用的频率逐渐多起来，所以能够很好的理解它
们的工作方式很有意义。事实上，可以这样说，它们是学习 shell的最重要的主题。如果没有
准确地理解展开模式，shell总是神秘和混乱的源泉，并且 shell潜在的能力也浪费掉了。
8.13拓展阅读
• Bash手册页有主要段落是关于展开和引用的，它们以更正式的方式介绍了这些题目。
• Bash参考手册也包含章节，介绍展开和引用：
http://www.gnu.org/software/bash/manual/bashref.html
92
9|键盘高级操作技巧
开玩笑地说，我经常把 Unix描述为“这个操作系统是为喜欢敲键盘的人们服务的。”当然，
Unix甚至还有一个命令行这件事证明了我所说的话。但是命令行用户不喜欢敲入那么多字。
要不为什么会有如此多的命令有这样简短的命令名，像 cp、ls、mv和 rm？事实上，命令行最
为珍视的目标之一就是懒惰；用最少的击键次数来完成最多的工作。另一个目标是你的手指永
远不必离开键盘，永不触摸鼠标。在这一章节，我们将看一下 bash特性，这些特性使键盘使用
起来更加迅速，更加高效。
以下命令将会露面：
• clear－清空屏幕
• history－显示历史列表内容
9.1命令行编辑
Bash使用了一个名为 Readline的库（共享的例程集合，可以被不同的程序使用），来实现命令
行编辑。我们已经看到一些例子。我们知道，例如，箭头按键可以移动光标，此外还有许多特
性。想想这些额外的工具，我们可以在工作中使用。学会所有的特性并不重要，但许多特性非
常有帮助。选择自己需要的特性。
注意：下面一些按键组合（尤其使用 Alt键的组合），可能会被 GUI拦截来触发其它的功
能。当使用虚拟控制台时，所有的按键组合都应该正确地工作。
9.2移动光标
下表列出了移动光标所使用的按键：
按键行动
Ctrl-a移动光标到行首。
93
Ctrl-e移动光标到行尾。
Ctrl-f光标前移一个字符；和右箭头作用一样。
Ctrl-b光标后移一个字符；和左箭头作用一样。
Alt-f光标前移一个字。
Alt-b光标后移一个字。
Ctrl-l清空屏幕，移动光标到左上角。clear命令完成同样的工作。
表 9-1:光标移动命令
9.3修改文本
表 9－ 2列出了键盘命令，这些命令用来在命令行中编辑字符。
按键行动
Ctrl-d删除光标位置的字符。
Ctrl-t光标位置的字符和光标前面的字符互换位置。
Alt-t光标位置的字和其前面的字互换位置。
Alt-l把从光标位置到字尾的字符转换成小写字母。
Alt-u把从光标位置到字尾的字符转换成大写字母。
表 9-2:文本编辑命令
9.4剪切和粘贴文本
Readline的文档使用术语 killing和 yanking来指我们平常所说的剪切和粘贴。剪切下来的本
文被存储在一个叫做剪切环 (kill-ring)的缓冲区中。
按键行动
Ctrl-k剪切从光标位置到行尾的文本。
Ctrl-u剪切从光标位置到行首的文本。
Alt-d剪切从光标位置到词尾的文本。
Alt-Backspace剪切从光标位置到词头的文本。如果光标在一个单词的开
头，剪切前一个单词。
Ctrl-y把剪切环中的文本粘贴到光标位置。
94
表 9-3:剪切和粘贴命令
元键
如果你冒险进入到 Readline的文档中，你会在 bash手册页的 READLINE段
落，遇到一个术语 “元键”（meta key）。在当今的键盘上，这个元键是指 Alt键，但
并不总是这样。
回到昏暗的年代（在 PC之前 Unix之后），并不是每个人都有他们自己的计算
机。他们可能有一个叫做终端的设备。一个终端是一种通信设备，它以一个文本显
示屏幕和一个键盘作为其特色，它里面有足够的电子器件来显示文本字符和移动光
标。它连接到（通常通过串行电缆）一个更大的计算机或者是一个大型计算机的通
信网络。有许多不同的终端产品商标，它们有着不同的键盘和特征显示集。因为它
们都倾向于至少能理解 ASCII，所以软件开发者想要符合最低标准的可移植的应用
程序。Unix系统有一个非常精巧的方法来处理各种终端产品和它们不同的显示特
征。因为 Readline程序的开发者们，不能确定一个专用多余的控制键的存在，他们
发明了一个控制键，并把它叫做 “元”（”meta”）。然而在现代的键盘上，Alt键作为
元键来服务。如果你仍然在使用终端（在 Linux中，你仍然可以得到一个终端），你
也可以按下和释放 Esc键来得到如控制 Alt键一样的效果。
9.5自动补全
shell能帮助你的另一种方式是通过一种叫做自动补全的机制。当你敲入一个命令时，按下 tab
键，自动补全就会发生。让我们看一下这是怎样工作的。给出一个看起来像这样的家目录：
[me@linuxbox~]$ls
Desktopls-output.txtPicturesTemplatesVideos
....
试着输入下面的命令，但不要按下 Enter键：
95
[me@linuxbox~]$lsl
现在按下 tab键：
[me@linuxbox~]$lsls-output.txt
看一下 shell是怎样补全这一行的？让我们再试试另一个例子。这回，也不要按下 Enter:
[me@linuxbox~]$lsD
按下 tab:
[me@linuxbox~]$lsD
没有补全，只是嘟嘟响。因为 “D”不止匹配目录中的一个条目。为了自动补全执行成功，
你给它的 “线索”不能模棱两可。如果我们继续输入：
[me@linuxbox~]$lsDo
然后按下 tab：
[me@linuxbox~]$lsDocuments
自动补全成功了。
这个实例展示了路径名自动补全，这是最常用的形式。自动补全也能对变量（如果字的开
头是一个 “$”）、用户名字（单词以””开始）、命令（如果单词是一行的第一个单词）和主机
名（如果单词的开头是 “@”）起作用。主机名自动补全只对包含在文件/etc/hosts中的主机名
有效。
有一系列的控制和元键序列与自动补全相关联：
96
按键行动
Alt-?显示可能的自动补全列表。在大多数系统中，你也可以完成
这个通过按两次 tab键，这会更容易些。
Alt-*插入所有可能的自动补全。当你想要使用多个可能的匹配
项时，这个很有帮助。
表 9-4:自动补全命令
可编程自动补全
目前的 bash版本有一个叫做可编程自动补全工具。可编程自动补全允许你（更
可能是，你的发行版提供商）来加入额外的自动补全规则。通常需要加入对特定应
用程序的支持，来完成这个任务。例如，有可能为一个命令的选项列表，或者一个
应用程序支持的特殊文件类型加入自动补全。默认情况下，Ubuntu已经定义了一
个相当大的规则集合。可编程自动补全是由 shell函数实现的，shell函数是一种小
巧的 shell脚本，我们会在后面的章节中讨论到。如果你感到好奇，试一下：
set|less
查看一下如果你能找到它们的话。默认情况下，并不是所有的发行版都包括它
们。
9.6利用历史命令
正如我们在第二章中讨论到的，bash维护着一个已经执行过的命令的历史列表。这个命令列表
被保存在你家目录下，一个叫做.bash_history的文件里。这个 history工具是个有用资源，因
为它可以减少你敲键盘的次数，尤其当和命令行编辑联系起来时。
9.7搜索历史命令
在任何时候，我们都可以浏览历史列表的内容，通过：
[me@linuxbox~]$history|less
97
在默认情况下，bash会存储你所输入的最后 500个命令。在随后的章节里，我们会知道怎
样调整这个数值。比方说我们想在自己曾经用过的命令中，找出和/usr/bin这一目录相关的。
那么我们就可以这样做：
[me@linuxbox~]$history|grep/usr/bin
比方说在我们的搜索结果之中，我们得到一行，包含了有趣的命令，像这样；
88ls-l/usr/bin>ls-output.txt
数字 “88”是这个命令在历史列表中的行号。我们可以使用另一种叫做历史命令展开的方
式，来调用“88”所代表的这一行命令：
[me@linuxbox~]$!88
bash会把 “!88”展开成为历史列表中 88行的内容。还有其它的历史命令展开形式，我们一
会儿讨论它们。bash也具有增量搜索历史列表的能力。意思是在字符输入的同时，bash会去
搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接
近目标。输入 Ctrl-r来启动增量搜索，接着输入你要寻找的字。当你找到它以后，你可以敲入
Enter来执行命令，或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，
来找到下一个匹配项（历史列表中向上移动）。输入 Ctrl-g或者 Ctrl-c，退出搜索。现在看看
它的实际效果：
[me@linuxbox~]$
首先输入 Ctrl-r:
(reverse-i-search)`':
98
提示符改变，显示我们正在执行反向增量搜索。搜索过程是 “反向的”，因为我们按照从”现
在”到过去某个时间段的顺序来搜寻。下一步，我们开始输入要查找的文本。在这个例子里是
“/usr/bin”：
(reverse-i-search)`/usr/bin':ls-l/usr/bin>ls-output.txt
上面这一行冒号后面的第一个 “/”会高亮显示。
即刻，搜索返回我们需要的结果。我们可以按下 Enter键来执行这个命令，或者我们可以
按下 Ctrl-j复制这个命令到我们当前的命令行，来进一步编辑它。好了现在我们复制它，输入
Ctrl-j：
[me@linuxbox~]$ls-l/usr/bin>ls-output.txt
我们的 shell提示符重新出现，命令行加载完毕，准备接受下一命令！下表列出了一些按键
组合，这些按键可以用来操作历史列表：
按键行为
Ctrl-p移动到上一个历史条目。类似于上箭头按键。
Ctrl-n移动到下一个历史条目。类似于下箭头按键。
Alt-<移动到历史列表开头。
Alt->移动到历史列表结尾，即当前命令行。
Ctrl-r反向增量搜索。从当前命令行开始，向上增量搜索。
Alt-p反向搜索，非增量搜索。（输入要查找的字符串，按下 Enter
来执行搜索）。
Alt-n向前搜索，非增量。
Ctrl-o执行历史列表中的当前项，并移到下一个。如果你想要执行
历史列表中一系列的命令，这很方便。
表 9-5:历史命令
99
9.8历史命令展开
通过使用 “!”字符，shell为历史列表中的命令，提供了一个特殊的展开类型。我们已经知道一
个感叹号，其后再加上一个数字，可以把来自历史列表中的命令插入到命令行中。这里还有一
些其它的展开特性：
序列行为
!!重复最后一次执行的命令。可能按下上箭头按键和 enter键
更容易些。
!number重复历史列表中第 number行的命令。
!string重复最近历史列表中，以这个字符串开头的命令。
!?string重复最近历史列表中，包含这个字符串的命令。
表 9-6:历史展开命令
应该小心谨慎地使用 “!string”和 “!?string”格式，除非你完全确信历史列表条目的内容。
在历史展开机制中，还有许多可利用的特点，但是这个题目已经太晦涩难懂了，如果我们再
继续讨论的话，我们的头可能要爆炸了。bash手册页的 HISTORY EXPANSION部分详尽地
讲述了所有要素。
脚本
除了 bash中的命令历史特性，许多 Linux发行版包括一个叫做 script的程序，
这个程序可以记录整个 shell会话，并把 shell会话存在一个文件里面。这个命令的
基本语法是：
script[file]
命令中的 file是指用来存储 shell会话记录的文件名。如果没有指定文件名，则
使用文件 typescript。查看脚本的手册页，可以得到一个关于 script程序选项和特
点的完整列表。
9.9总结归纳
在这一章中，我们已经讨论了一些由 shell提供的键盘操作技巧，这些技巧是来帮助打字员减
少工作量的。随着时光流逝，你和命令行打交道越来越多，我猜想你会重新翻阅这一章的内容，
100
学会更多的技巧。目前，你就认为它们是可选的，潜在地有帮助的。
9.10拓展阅读
• Wikipedia上有一篇关于计算机终端的好文章：
http://en.wikipedia.org/wiki/Computer_terminal
101
10|权限
Unix传统中的操作系统不同于那些 MS-DOS传统中的系统，区别在于它们不仅是多任务系统，
而且也是多用户系统。这到底意味着什么？它意味着多个用户可以在同一时间使用同一台计算
机。然而一个典型的计算机可能只有一个键盘和一个监视器，但是它仍然可以被多个用户使
用。例如，如果一台计算机连接到一个网络或者因特网，那么远程用户通过 ssh（安全 shell）
可以登录并操纵这台电脑。事实上，远程用户也能运行图形界面应用程序，并且图形化的输出
结果会出现在远端的显示器上。X窗口系统把这个作为基本设计理念的一部分，并支持这种功
能。
Linux系统的多用户性能，不是最近的“创新”，而是一种深深地嵌入到了 Linux操作系统
的设计中的特性。想想 Unix系统的诞生环境，这一点就很好理解了。多年前，在个人电脑出
现之前，计算机都是大型、昂贵的、集中化的。例如一个典型的大学计算机系统，是由坐落在
一座建筑中的一台大型中央计算机和许多散布在校园各处的终端机组成，每个终端都连接到这
台大型中央计算机。这台计算机可以同时支持很多用户。
为了使多用户特性付诸实践，那么必须发明一种方法来阻止用户彼此之间受到影响。毕竟，
一个用户的行为不能导致计算机崩溃，也不能乱动属于另一个用户的文件。
在这一章中，我们将看看这一系统安全的本质部分，会介绍以下命令：
• id–显示用户身份号
• chmod–更改文件模式
• umask–设置默认的文件权限
• su–以另一个用户的身份来运行 shell
• sudo–以另一个用户的身份来执行命令
• chown–更改文件所有者
• chgrp–更改文件组所有权
102
• passwd–更改用户密码
10.1拥有者、组成员和其他人
在第四章探究文件系统时，当我们试图查看一个像/etc/shadow那样的文件的时候，我们会遇
到一个问题。
[me@linuxbox~]$file/etc/shadow
/etc/shadow:regularfile,noreadpermission
[me@linuxbox~]$less/etc/shadow
/etc/shadow:Permissiondenied
产生这种错误信息的原因是，作为一个普通用户，我们没有权限来读取这个文件。
在 Unix安全模型中，一个用户可能拥有文件和目录。当一个用户拥有一个文件或目录时，
用户对这个文件或目录的访问权限拥有控制权。用户反过来又属于一个由一个或多个用户组成
的用户组，用户组成员由文件和目录的所有者授予对文件和目录的访问权限。除了对一个用户
组授予权限之外，文件所有者可能会给每个人一些权限，在 Unix术语中，每个人是指整个世
界。可以用 id命令，来找到关于你自己身份的信息：
[me@linuxbox~]$id
uid=500(me)gid=500(me)groups=500(me)
让我们看一下输出结果。当用户创建帐户之后，系统会给用户分配一个号码，叫做用户 ID
或者 uid，然后，为了符合人类的习惯，这个 ID映射到一个用户名。系统又会给这个用户分
配一个原始的组 ID或者是 gid，这个 gid可能属于另外的组。上面的例子来自于 Fedora系统，
比方说 Ubuntu的输出结果可能看起来有点儿不同：
[me@linuxbox~]$id
uid=1000(me)gid=1000(me)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
103
正如我们能看到的，两个系统中用户的 uid和 gid号码是不同的。原因很简单，因为 Fedora
系统从 500开始进行普通用户帐户的编号，而 Ubuntu从 1000开始。我们也能看到 Ubuntu
的用户属于更多的用户组。这和 Ubuntu管理系统设备和服务权限的方式有关系。
那么这些信息来源于哪里呢？像 Linux系统中的许多东西一样，来自一系列的文本文件。
用户帐户定义在/etc/passwd文件里面，用户组定义在/etc/group文件里面。当用户帐户和用
户组创建以后，这些文件随着文件/etc/shadow的变动而修改，文件/etc/shadow包含了关于用
户密码的信息。对于每个用户帐号，文件/etc/passwd定义了用户（登录）名、uid、gid、帐号
的真实姓名、家目录和登录 shell。如果你查看一下文件/etc/passwd和文件/etc/group的内容，
你会注意到除了普通用户帐号之外，还有超级用户（uid 0）帐号，和各种各样的系统用户。
在下一章中，当我们讨论进程时，你会知道这些其他的“用户”是谁，实际上，他们相当忙
碌。
然而许多像 Unix的系统会把普通用户分配到一个公共的用户组中，例如“users”，现在的
Linux会创建一个独一无二的，只有一个成员的用户组，这个用户组与用户同名。这样使某种
类型的权限分配更容易些。
10.2读取、写入和执行
对于文件和目录的访问权力是根据读访问、写访问和执行访问来定义的。如果我们看一下 ls命
令的输出结果，我们能得到一些线索，这是怎样实现的：
[me@linuxbox~]$>foo.txt
[me@linuxbox~]$ls-lfoo.txt
-rw-rw-r--1meme02008-03-0614:52foo.txt
列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。下表是你可能
经常看到的文件类型（还有其它的，不常见类型）：
属性文件类型
-一个普通文件
d一个目录
l一个符号链接。注意对于符号链接文件，剩余的文件属性总
是”rwxrwxrwx”，而且都是虚拟值。真正的文件属性是指符
号链接所指向的文件的属性。
104
c一个字符设备文件。这种文件类型是指按照字节流来处理
数据的设备。比如说终端机或者调制解调器
b一个块设备文件。这种文件类型是指按照数据块来处理数
据的设备，例如一个硬盘或者 CD-ROM盘。
表 10-1:文件类型
剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执
行权限。
图 1:权限属性
当设置文件模式后，r、w和 x模式属性对文件和目录会产生以下影响：
属性文件目录
r允许打开并允许列出目录中的内容，前提是目录必须设置了可执
读取文件内行属性（x）。
容。
w允许写入文允许在目录下新建、删除或重命名文件，前提是目录
件内容或截必须设置了可执行属性（x）。
断文件。但
是不允许
对文件进行
重命名或删
除，重命名
或删除是由
目录的属性
决定的。
105
x允许将文件允许进入目录，例如：cd directory。
作为程序来
执行，使用
脚本语言编
写的程序必
须设置为可
读才能被执
行。
表 10-2:权限属性
下面是权限属性的一些例子：
文件属性含义
-rwx-––-一个普通文件，对文件所有者来说可读、可写、可执行。其
他人无法访问。
-rw-–––一个普通文件，对文件所有者来说可读可写。其他人无法访
问。
-rw-r--r--一个普通文件，对文件所有者来说可读可写，文件所有者的
组成员可以读该文件，其他所有人都可以读该文件。
-rwxr-xr-x一个普通文件，对文件所有者来说可读、可写、可执行。也
可以被其他的所有人读取和执行。
-rw-rw-–-一个普通文件，对文件所有者以及文件所有者的组成员来说
可读可写。
lrwxrwxrwx一个符号链接，符号链接的权限都是虚拟的，真实的权限应
该以符号链接指向的文件为准。
drwxrwx-–一个目录，文件所有者以及文件所有者的组成员可以访问该
目录，并且可以在该目录下新建、重命名、删除文件。
drwxr-x-–一个目录，文件所有者可以访问该目录，并且可以在该目录
下新建、重命名、删除文件，文件所有者的组成员可以访问
该目录，但是不能新建、重命名、删除文件。
表 10-3:权限属性示例
106
10.3chmod－更改文件模式
更改文件或目录的模式（权限），可以利用 chmod命令。注意只有文件的所有者或者超级用户
才能更改文件或目录的模式。chmod命令支持两种不同的方法来改变文件模式：八进制数字表
示法或符号表示法。首先我们讨论一下八进制数字表示法。
究竟什么是八进制？
八进制（以 8为基数）及其亲戚十六进制（以 16为基数）都是数字系统，通常
被用来表示计算机中的数字。我们人类，因为（或者至少大多数人）天生有十个手
指的事实，利用以 10为基数的数字系统来计数。计算机，从另一方面讲，生来只有
一个手指，因此它以二进制（以 2为基数）来计数。它们的数字系统只有两个数值，
0和 1。因此在二进制中，计数看起来像这样：
0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011…
在八进制中，逢八进一，用数字 0到 7来计数，像这样：
0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 20, 21…
十六进制中，使用数字 0到 9，加上大写字母 “A”到”F”来计数，逢 16进一：
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, 13…
虽然我们能知道二进制的意义（因为计算机只有一个手指），但是八进制和十六
进制对什么有好处呢？答案是为了人类的便利。许多时候，在计算机中，一小部分
数据以二进制的形式表示。以 RGB颜色为例来说明。大多数的计算机显示器，每
个像素由三种颜色组成：8位红色，8位绿色，8位蓝色。这样，一种可爱的中蓝色
就由 24位数字来表示：
010000110110111111001101
我不认为你每天都喜欢读写这类数字。另一种数字系统对我们更有帮助。每个
十六进制数字代表四个二进制。在八进制中，每个数字代表三个二进制数字。那么
代表中蓝色的 24位二进制能够压缩成 6位十六进制数：
436FCD
因为十六进制中的两个数字对应二进制的 8位数字，我们可以看到”43“代表红
色，“6F”代表绿色，“CD”代表蓝色。
现在，十六进制表示法（经常叫做“hex”）比八进制更普遍，但是我们很快会看
到，用八进制来表示 3个二进制数非常有用处…
107
通过八进制表示法，我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字
代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。下表
展示了我们所要表达的意思：
Octal Binary File Mode
0 000 -–
1 001 --x
2 010 -w-
3 011 -wx
4 100 r--
5 101 r-x
6 110 rw-
7 111 rwx
通过使用 3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：
[me@linuxbox~]$>foo.txt
[me@linuxbox~]$ls-lfoo.txt
-rw-rw-r--1meme02008-03-0614:52foo.txt
[me@linuxbox~]$chmod600foo.txt
[me@linuxbox~]$ls-lfoo.txt
-rw-------1meme02008-03-0614:52foo.txt
通过传递参数“600”，我们能够设置文件所有者的权限为读写权限，而删除用户组和其他人
的所有权限。虽然八进制到二进制的映射看起来不方便，但通常只会用到一些常见的映射关系：
7 (rwx)，6 (rw-)，5 (r-x)，4 (r--)，和 0 (-–)。
chmod命令支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响
谁，要执行哪个操作，要设置哪种权限。通过字符“u”、“g”、“o”和“a”的组合来指定要影
响的对象，如下所示：
u ”user”的简写，意思是文件或目录的所有者。
g用户组。
o ”others”的简写，意思是其他所有的人。
a ”all”的简写，是”u”, ”g”和“o”三者的联合。
表 10-4: chmod命令符号表示法
108
如果没有指定字符，则假定使用 “all”。执行的操作可能是一个“＋”字符，表示加上一个
权限，一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有
的权限被删除。
权限由“r”、“w”和“x”来指定。这里是一些符号表示法的实例：
u+x为文件所有者添加可执行权限。
u-x删除文件所有者的可执行权限。
+x为文件所有者，用户组，和其他所有人添加可执行权限。等
价于 a+x。
o-rw除了文件所有者和用户组，删除其他人的读权限和写权限。
go=rw给文件所属的组和文件所属者/组以外的人读写权限。如果
文件所属组或其他人已经拥有执行的权限，执行权限将被移
除。
u+x,go=rw给文件拥有者执行权限并给组和其他人读和执行的权限。
多种设定可以用逗号分开。
表 10-5: chmod符号表示法实例
一些人喜欢使用八进制表示法，而另一些人则非常喜欢符号表示法。符号表示法的优点是，
允许你设置文件模式的某个属性，而不影响其他的属性。
看一下 chmod命令的手册页，可以得到更详尽的信息和 chmod命令的各个选项。要注意
“--recursive”选项：它可以同时作用于文件和目录，所以它并不是如我们期望的那么有用处，因
为我们很少希望文件和目录拥有同样的权限。
10.4借助GUI来设置文件模式
现在我们已经知道了怎样设置文件和目录的权限，这样我们就可以更好的理解 GUI中的设置
权限对话框。在 Nautilus (GNOME)和 Konqueror (KDE)中，右击一个文件或目录图标将会
弹出一个属性对话框。下面这个例子来自 KDE 3.5：
109
图 2: KDE 3.5文件属性对话框
从这个对话框中，我们看到可以设置文件所有者、用户组和其他人的访问权限。在 KDE
中，右击 “Advanced Permissions”按钮，会打开另一个对话框，这个对话框允许你单独设置各
个模式属性。这也可以通过命令行来理解！
10.5umask－设置默认权限
当创建一个文件时，umask命令控制着文件的默认权限。umask命令使用八进制表示法来表达
从文件模式属性中删除一个位掩码。大家看下面的例子：
[me@linuxbox~]$rm-ffoo.txt
[me@linuxbox~]$umask
0002
[me@linuxbox~]$>foo.txt
[me@linuxbox~]$ls-lfoo.txt
-rw-rw-r--1meme02008-03-0614:53foo.txt
首先，删除文件 foo.txt，以此确定我们从新开始。下一步，运行不带参数的 umask命令，
看一下当前的掩码值。响应的数值是 0002（0022是另一个常用值），这个数值是掩码的八进制
表示形式。下一步，我们创建文件 foo.txt，并且保留它的权限。
110
我们可以看到文件所有者和用户组都得到读权限和写权限，而其他人只是得到读权限。其
他人没有得到写权限的原因是由掩码值决定的。重复我们的实验，这次自己设置掩码值：
[me@linuxbox~]$rmfoo.txt
[me@linuxbox~]$umask0000
[me@linuxbox~]$>foo.txt
[me@linuxbox~]$ls-lfoo.txt
-rw-rw-rw-1meme02008-03-0614:58foo.txt
当掩码设置为 0000（实质上是关掉它）之后，我们看到其他人能够读写文件。为了弄明白
这是怎么回事，我们需要看一下掩码的八进制形式。把掩码展开成二进制形式，然后与文件属
性相比较，看看有什么区别：
Original file mode -– rw- rw- rw-
Mask 000 000 000 010
Result -– rw- rw- r--
此刻先忽略掉开头的三个零（我们一会儿再讨论），注意掩码中若出现一个数字 1，则删除
文件模式中和这个 1在相同位置的属性，在这是指其他人的写权限。这就是掩码要完成的任
务。掩码的二进制形式中，出现数字 1的位置，相应地关掉一个文件模式属性。看一下掩码
0022的作用：
Original file mode -– rw- rw- rw-
Mask 000 000 010 010
Result -– rw- r-- r--
又一次，二进制中数字 1出现的位置，相对应的属性被删除。再试一下其它的掩码值（一
些带数字 7的），习惯于掩码的工作原理。当你实验完成之后，要记得清理现场：
[me@linuxbox~]$rmfoo.txt;umask0002
大多数情况下，你不必修改掩码值，系统提供的默认掩码值就很好了。然而，在一些高安全
级别下，你要能控制掩码值。
111
一些特殊权限
虽然我们通常看到一个八进制的权限掩码用三位数字来表示，但是从技术层面上
来讲，用四位数字来表示它更确切些。为什么呢？因为除了读取、写入和执行权限
之外，还有其它较少用到的权限设置。
其中之一是 setuid位（八进制 4000）。当应用到一个可执行文件时，它把有效
用户 ID从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作
通常会应用到一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个
程序由根用户 (root)所有，并且设置了 setuid位，这个程序运行时具有超级用户的
特权，这样程序就可以访问普通用户禁止访问的文件和目录。很明显，因为这会引
起安全方面的问题，所有可以设置 setuid位的程序个数，必须控制在绝对小的范围
内。
第二个是 setgid位（八进制 2000），这个相似于 setuid位，把有效用户组 ID从
真正的用户组 ID更改为文件所有者的组 ID。如果设置了一个目录的 setgid位，则
目录中新创建的文件具有这个目录用户组的所有权，而不是文件创建者所属用户组
的所有权。对于共享目录来说，当一个普通用户组中的成员，需要访问共享目录中
的所有文件，而不管文件所有者的主用户组时，那么设置 setgid位很有用处。
第三个是 sticky位（八进制 1000）。这个继承于 Unix，在 Unix中，它可能把一
个可执行文件标志为“不可交换的”。在 Linux中，会忽略文件的 sticky位，但是
如果一个目录设置了 sticky位，那么它能阻止用户删除或重命名文件，除非用户是
这个目录的所有者，或者是文件所有者，或是超级用户。这个经常用来控制访问共
享目录，比方说/tmp。
这里有一些例子，使用 chmod命令和符号表示法，来设置这些特殊的权限。首
先，授予一个程序 setuid权限。
chmodu+sprogram
下一步，授予一个目录 setgid权限：
chmodg+sdir
最后，授予一个目录 sticky权限：
chmod+tdir
当浏览 ls命令的输出结果时，你可以确认这些特殊权限。这里有一些例子。首
先，一个程序被设置为 setuid属性：
-rwsr-xr-x
具有 setgid属性的目录：
112
drwxrwsr-x
设置了 sticky位的目录：
drwxrwxrwt
10.6更改身份
在不同的时候，我们会发现很有必要具有另一个用户的身份。经常地，我们想要得到超级用户
特权，来执行一些管理任务，但是也有可能 “变为”另一个普通用户，比如说测试一个帐号。有
三种方式，可以拥有多重身份：
1.注销系统并以其他用户身份重新登录系统。
2.使用 su命令。
3.使用 sudo命令。
我们将跳过第一种方法，因为我们知道怎样使用它，并且它缺乏其它两种方法的方便性。在
我们自己的 shell会话中，su命令允许你假定为另一个用户的身份，以这个用户的 ID启动一
个新的 shell会话，或者是以这个用户的身份来发布一个命令。sudo命令允许一个管理员设置
一个叫做/etc/sudoers的配置文件，并且定义了一些具体命令，在假定的身份下，特殊用户可
以执行这些命令。选择使用哪个命令，很大程度上是由你使用的 Linux发行版来决定的。你的
发行版可能这两个命令都包含，但系统配置可能会偏袒其中之一。我们先介绍 su命令。
10.7su－以其他用户身份和组ID运行一个shell
su命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样：
su[-[l]][user]
如果包含 “-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户
的 shell环境，并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指
定用户，那么就假定是超级用户。注意（不可思议地），选项 “-l”可以缩写为”-”，这是经常用
到的形式。启动超级用户的 shell，我们可以这样做：
113
[me@linuxbox~]$su-
Password:
[root@linuxbox~]#
按下回车符之后，shell提示我们输入超级用户的密码。如果密码输入正确，出现一个新的
shell提示符，这表明这个 shell具有超级用户特权（提示符的末尾字符是 “#”而不是”$”），并
且当前工作目录是超级用户的家目录（通常是/root）。一旦进入一个新的 shell，我们能执行超
级用户所使用的命令。当工作完成后，输入 “exit”，则返回到原来的 shell:
[root@linuxbox~]#exit
[me@linuxbox~]$
以这样的方式使用 su命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：
su-c'command'
使用这种模式，命令传递到一个新 shell中执行。把命令用单引号引起来很重要，因为我们
不想命令在我们的 shell中展开，但需要在新 shell中展开。
[me@linuxbox~]$su-c'ls-l/root/*'
Password:
-rw-------1rootroot7542007-08-1103:19/root/anaconda-ks.cfg
/root/Mail:
total0
[me@linuxbox~]$
10.8sudo－以另一个用户身份执行命令
sudo命令在很多方面都相似于 su命令，但是 sudo还有一些非常重要的功能。管理员能够配
置 sudo命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的
114
方式来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo命
令的方便性）。另一个重要差异是 sudo命令不要求超级用户的密码。使用 sudo命令时，用户
使用他/她自己的密码来认证。比如说，例如，sudo命令经过配置，允许我们运行一个虚构的
备份程序，叫做 “backup_script”，这个程序要求超级用户权限。通过 sudo命令，这个程序会
像这样运行：
[me@linuxbox~]$sudobackup_script
Password:
SystemBackupStarting...
按下回车键之后，shell提示我们输入我们的密码（不是超级用户的）。一旦认证完成，则执
行具体的命令。su和 sudo之间的一个重要区别是 sudo不会重新启动一个 shell，也不会加载
另一个用户的 shell运行环境。这意味者命令不必用单引号引起来。注意通过指定各种各样的
选项，这种行为可以被推翻。详细信息，阅读 sudo手册页。
想知道 sudo命令可以授予哪些权限，使用 “-l”选项，列出所有权限：
[me@linuxbox~]$sudo-l
Usermemayrunthefollowingcommandsonthishost:
(ALL)ALL
Ubuntu与 sudo
普通用户经常会遇到这样的问题，怎样完成某些需要超级用户权限的任务。这些
任务包括安装和更新软件，编辑系统配置文件，和访问设备。在 Windows世界里，
这些任务是通过授予用户管理员权限来完成的。这允许用户执行这些任务。然而，
这也会导致用户所执行的程序拥有同样的能力。在大多数情况下，这是我们所期望
的，但是它也允许 malware（恶意软件），比方说电脑病毒，自由地支配计算机。
在 Unix世界中，由于 Unix是多用户系统，所以在普通用户和管理员之间总是
存在很大的差别。Unix采取的方法是只有在需要的时候，才授予普通用户超级用户
权限。这样，普遍会用到 su和 sudo命令。
几年前，大多数的 Linux发行版都依赖于 su命令，来达到目的。su命令不需要
sudo命令所要求的配置，su命令拥有一个 root帐号，是 Unix中的传统。但这会
115
引起问题。所有用户会企图以 root用户帐号来操纵系统。事实上，一些用户专门以
root用户帐号来操作系统，因为这样做，的确消除了所有那些讨厌的“权限被拒绝”
的消息。你这样做就会使得 Linux系统的安全性能被降低到和 Windows系统相同
的级别。不是一个好主意。
当引进 Ubuntu的时候，它的创作者们采取了不同的策略。默认情况下，Ubuntu
不允许用户登录到 root帐号（因为不能为 root帐号设置密码），而是使用 sudo命
令授予普通用户超级用户权限。通过 sudo命令，最初的用户可以拥有超级用户权
限，也可以授予随后的用户帐号相似的权力。
10.9chown－更改文件所有者和用户组
chown命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。
chown命令的语法看起来像这样：
chown[owner][:[group]]file...
chown可以根据这个命令的第一个参数更改文件所有者和/或文件用户组。这里有一些例子：
参数结果
bob把文件所有者从当前属主更改为用户 bob。
bob:users把文件所有者改为用户 bob，文件用户组改为用户组 users。
:admins把文件用户组改为组 admins，文件所有者不变。
bob:文件所有者改为用户 bob，文件用户组改为用户 bob登录
系统时所属的用户组。
表 10-6: chown参数实例
比方说，我们有两个用户，janet拥有超级用户访问权限，而 tony没有。用户 janet想要从
她的家目录复制一个文件到用户 tony的家目录。因为用户 janet想要 tony能够编辑这个文件，
janet把这个文件的所有者更改为 tony:
116
[janet@linuxbox~]$sudocpmyfile.txt~tony
Password:
[janet@linuxbox~]$sudols-l~tony/myfile.txt
-rw-r--r--1rootroot80312008-03-2014:30/home/tony/myfile.txt
[janet@linuxbox~]$sudochowntony:~tony/myfile.txt
[janet@linuxbox~]$sudols-l~tony/myfile.txt
-rw-r--r--1tonytony80312008-03-2014:30/home/tony/myfile.txt
这里，我们看到用户 janet把文件从她的目录复制到 tony的家目录。下一步，janet把文件
所有者从 root（使用 sudo命令的原因）改到 tony。通过在第一个参数中使用末尾的 “:”字符，
janet同时把文件用户组改为 tony登录系统时，所属的用户组，碰巧是用户组 tony。
注意，第一次使用 sudo命令之后，为什么（shell）没有提示 janet输入她的密码？这是因
为，在大多数的配置中，sudo命令会相信你几分钟，直到计时结束。
10.10chgrp－更改用户组所有权
在旧版 Unix系统中，chown命令只能更改文件所有权，而不是用户组所有权。为了达到目的，
使用一个独立的命令，chgrp来完成。除了限制多一点之外，chgrp命令与 chown命令使用起
来很相似。
10.11练习使用权限
到目前为止，我们已经知道了权限这类东西是怎样工作的，现在是时候炫耀一下了。我们将展
示一个常见问题的解决方案，这个问题是如何设置一个共享目录。假想我们有两个用户，他们
分别是 “bill”和 “karen”。他们都有音乐 CD收藏品，也愿意设置一个共享目录，在这个共享
目录中，他们分别以 Ogg Vorbis或 MP3的格式来存储他们的音乐文件。通过 sudo命令，用
户 bill具有超级用户访问权限。
我们需要做的第一件事，是创建一个以 bill和 karen为成员的用户组。使用图形化的用户
管理工具，bill创建了一个叫做 music的用户组，并且把用户 bill和 karen添加到用户组 music
中：
117
图 3:用 GNOME创建一个新的用户组
下一步，bill创建了存储音乐文件的目录：
[bill@linuxbox~]$sudomkdir/usr/local/share/Music
password:
因为 bill正在他的家目录之外操作文件，所以需要超级用户权限。这个目录创建之后，它
具有以下所有权和权限：
[bill@linuxbox~]$ls-ld/usr/local/share/Music
drwxr-xr-x2rootroot40962008-03-2118:05/usr/local/share/Music
正如我们所见到的，这个目录由 root用户拥有，并且具有权限 755。为了使这个目录共享，
允许（用户 karen）写入，bill需要更改目录用户组所有权和权限：
[bill@linuxbox~]$sudochown:music/usr/local/share/Music
[bill@linuxbox~]$sudochmod775/usr/local/share/Music
[bill@linuxbox~]$ls-ld/usr/local/share/Music
drwxrwxr-x2rootmusic40962008-03-2118:05/usr/local/share/Music
那么这是什么意思呢？它的意思是，现在我们拥有一个目录，/usr/local/share/Music，这个
目录由 root用户拥有，并且允许用户组 music读取和写入。用户组 music有两个成员 bill和
118
karen，这样 bill和 karen能够在目录 /usr/local/share/Music中创建文件。其他用户能够列出
目录中的内容，但是不能在其中创建文件。
但是我们仍然会遇到问题。通过我们目前所拥有的权限，在 Music目录中创建的文件，只
具有用户 bill和 karen的普通权限：
[bill@linuxbox~]$>/usr/local/share/Music/test_file
[bill@linuxbox~]$ls-l/usr/local/share/Music
-rw-r--r--1billbill02008-03-2420:03test_file
实际上，存在两个问题。第一个，系统中默认的掩码值是 0022，这会禁止用户组成员编辑
属于同组成员的文件。如果共享目录中只包含文件，这就不是个问题，但是因为这个目录将会
存储音乐，通常音乐会按照艺术家和唱片的层次结构来组织分类。所以用户组成员需要在同组
其他成员创建的目录中创建文件和目录。我们将把用户 bill和 karen使用的掩码值改为 0002。
第二个问题是，用户组成员创建的文件和目录的用户组，将会设置为用户的主要组，而不是
用户组 music。通过设置此目录的 setgid位来解决这个问题：
[bill@linuxbox~]$sudochmodg+s/usr/local/share/Music
[bill@linuxbox~]$ls-ld/usr/local/share/Music
drwxrwsr-x2rootmusic40962008-03-2420:03/usr/local/share/Music
现在测试一下，看看是否新的权限解决了这个问题。bill把他的掩码值设为 0002，删除先
前的测试文件，并创建了一个新的测试文件和目录：
[bill@linuxbox~]$umask0002
[bill@linuxbox~]$rm/usr/local/share/Music/test_file
[bill@linuxbox~]$>/usr/local/share/Music/test_file
[bill@linuxbox~]$mkdir/usr/local/share/Music/test_dir
[bill@linuxbox~]$ls-l/usr/local/share/Music
drwxrwsr-x2billmusic40962008-03-2420:24test_dir
-rw-rw-r--1billmusic02008-03-2420:22test_file
[bill@linuxbox~]$
119
现在，创建的文件和目录都具有正确的权限，允许用户组 music的所有成员在目录 Music
中创建文件和目录。
剩下一个问题是关于 umask命令的。umask命令设置的掩码值只能在当前 shell会话中生
效，若当前 shell会话结束后，则必须重新设置。在这本书的第三部分，我们将看一下，怎样使
掩码值永久生效。
10.12更改用户密码
这一章最后一个话题，我们将讨论自己帐号的密码（和其他人的密码，如果你具有超级用户权
限）。使用 passwd命令，来设置或更改用户密码。命令语法如下所示：
passwd[user]
只要输入 passwd命令，就能更改你的密码。shell会提示你输入你的旧密码和你的新密码：
[me@linuxbox~]$passwd
(current)UNIXpassword:
NewUNIXpassword:
passwd命令将会试着强迫你使用“强”密码。这意味着它会拒绝接受太短的密码、与先前
相似的密码、字典中的单词作为密码或者是太容易猜到的密码：
[me@linuxbox~]$passwd
(current)UNIXpassword:
NewUNIXpassword:
BADPASSWORD:istoosimilartotheoldone
NewUNIXpassword:
BADPASSWORD:itisWAYtooshort
NewUNIXpassword:
BADPASSWORD:itisbasedonadictionaryword
如果你具有超级用户权限，你可以指定一个用户名作为 passwd命令的参数，这样可以设置
另一个用户的密码。还有其它的 passwd命令选项对超级用户有效，允许帐号锁定，密码失效，
等等。详细内容，参考 passwd命令的手册页。
120
10.13拓展阅读
• Wikipedia上面有一篇关于 malware（恶意软件）好文章：
http://en.wikipedia.org/wiki/Malware
还有一系列的命令行程序，可以用来创建和维护用户和用户组。更多信息，查看以下命令的
手册页：
•adduser
•useradd
•groupadd
121
11|进程
通常，现在的操作系统都支持多任务，意味着操作系统通过在一个执行中的程序和另一个程序
之间快速地切换造成了一种它同时能够做多件事情的假象。Linux内核通过使用进程来管理多
任务。进程，就是 Linux组织安排正在等待使用 CPU的各种程序的方式。
有时候，计算机变得呆滞，运行缓慢，或者一个应用程序停止响应。在这一章中，我们将看
一些可用的命令行工具，这些工具帮助我们查看程序的执行状态，以及怎样终止行为不当的进
程。
这一章将介绍以下命令：
• ps–报告当前进程快照
• top–显示任务
• jobs–列出活跃的任务
• bg–把一个任务放到后台执行
• fg–把一个任务放到前台执行
• kill–给一个进程发送信号
• killall–杀死指定名字的进程
• shutdown–关机或重启系统
11.1进程是怎样工作的
当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init的程
序。init，依次地，再运行一系列的称为 init脚本的 shell脚本（位于/etc），它们可以启动所有
的系统服务。其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，
122
没有任何用户接口 (User Interface)。这样，即使我们没有登录系统，至少系统也在忙于执行一
些例行事务。
在进程方案中，一个程序可以发动另一个程序被表述为一个父进程可以产生一个子进程。
内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这
个数字叫做进程 (process) ID或 PID。PID号按升序分配，init进程的 PID总是 1。内核也对
分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。像文件一样，进程也有所
有者和用户 ID，有效用户 ID，等等。
11.2查看进程
查看进程，最常使用地命令（有几个命令）是 ps(process status)。ps程序有许多选项，它最简
单地使用形式是这样的：
[me@linuxbox~]$ps
PIDTTYTIMECMD
5198pts/100:00:00bash
10129pts/100:00:00ps
上例中，列出了两个进程，进程 5198和进程 10129，各自代表命令 bash和 ps。正如我们
所看到的，默认情况下，ps不会显示很多进程信息，只是列出与当前终端会话相关的进程。为
了得到更多信息，我们需要加上一些选项，但是在这样做之前，我们先看一下 ps命令运行结果
的其它字段。TTY是 “Teletype”(直译电传打字机)的简写，是指进程的控制终端。TTY足足
显示了 Unix的年代久远。TIME字段表示进程所消耗的 CPU时间数量。正如我们所看到的，
这两个进程使计算机工作起来很轻松。
如果给 ps命令加上选项，我们可以得到更多关于系统运行状态的信息：
[me@linuxbox~]$psx
PIDTTYSTATTIMECOMMAND
2799?Ssl0:00/usr/libexec/bonobo-activation-server–ac
2820?Sl0:01/usr/libexec/evolution-data-server-1.10--
andmanymore...
123
加上 “x”选项（注意没有开头的”-“字符），告诉 ps命令，展示所有进程，不管它们由什么
终端（如果有的话）控制。在 TTY一栏中出现的 “?”，表示没有控制终端。使用这个 “x”选
项，可以看到我们所拥有的每个进程的信息。
因为系统中正运行着许多进程，所以 ps命令的输出结果很长。为了方便查看，将 ps的输
出管道到 less中通常很有帮助。一些选项组合也会产生很长的输出结果，所以最大化终端仿真
器窗口可能也是一个好主意。
输出结果中，新添加了一栏，标题为 STAT。STAT是 “state”的简写，它揭示了进程当前
状态：
状态含义
R运行中。这意味着，进程正在运行或准备运行。
S正在睡眠。进程没有运行，而是，正在等待一个事件，比如
说，一个按键或者网络分组。
D不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动
器的 I/O。
T已停止.已经指示进程停止运行。稍后介绍更多。
Z一个死进程或“僵尸”进程。这是一个已经终止的子进程，
但是它的父进程还没有清空它。（父进程没有把子进程从进
程表中删除）
<一个高优先级进程。这可能会授予一个进程更多重要的资
源，给它更多的 CPU时间。进程的这种属性叫做 niceness。
具有高优先级的进程据说是不好的（less nice），因为它占用
了比较多的 CPU时间，这样就给其它进程留下很少时间。
N低优先级进程。一个低优先级进程（一个“nice”进程）只有
当其它高优先级进程被服务了之后，才会得到处理器时间。
表 11-1:进程状态
进程状态信息之后，可能还跟随其他的字符。这表示各种外来进程的特性。详细信息请看
ps手册页。
另一个流行的选项组合是 “aux”（不带开头的 “-”字符）。这会给我们更多信息：
[me@linuxbox~]$psaux
USERPID%CPU%MEMVSZRSSTTYSTATSTARTTIMECOMMAND
124
root10.00.02136644?SsMar050:31init
root20.00.000?S&lt;Mar050:00[kt]
andmanymore...
这个选项组合，能够显示属于每个用户的进程信息。使用这个选项，可以唤醒“BSD风格”
的输出结果。Linux版本的 ps命令，可以模拟几个不同 Unix版本中的 ps程序的行为。通过
这些选项，我们得到这些额外的列。
标题含义
USER用户 ID.进程的所有者。
%CPU以百分比表示的 CPU使用率
%MEM以百分比表示的内存使用率
VSZ虚拟内存大小
RSS进程占用的物理内存的大小，以千字节为单位。
START进程启动的时间。若它的值超过 24小时，则用天表示。
11.3用top命令动态查看进程
虽然 ps命令能够展示许多计算机运行状态的信息，但是它只是提供 ps命令执行时刻的机器状
态快照。为了看到更多动态的信息，我们使用 top命令：
[me@linuxbox~]$top
top程序以进程活动顺序显示连续更新的系统进程列表。（默认情况下，每三秒钟更新一次），
“top”这个名字来源于 top程序是用来查看系统中“顶端”进程的。top显示结果由两部分组
成：最上面是系统概要，下面是进程列表，以 CPU的使用率排序。
top-14:59:20up6:30,2users,loadaverage:0.07,0.02,0.00
Tasks:109total,1running,106sleeping,0stopped,2zombie
Cpu(s):0.7%us,1.0%sy,0.0%ni,98.3%id,0.0%wa,0.0%hi,0.0%si
Mem:319496ktotal,314860kused,4636kfree,19392kbuff
Swap:875500ktotal,149128kused,726372kfree,114676kcach
125
PIDUSERPRNIVIRTRESSHRS%CPU%MEMTIME+COMMAND
6244me39193175231242188S6.31.016:24.42trackerd
....
其中系统概要包含许多有用信息。下表是对系统概要的说明：
行号字段意义
1 top程序名。
14:59:20当前时间。
up 6:30这是正常运行时间。它是计算机从上次启动到现在所
运行的时间。在这个例子里，系统已经运行了六个半
小时。
2 users有两个用户登录系统。
load average:加载平均值是指，等待运行的进程数目，也就是说，处
于可以运行状态并共享 CPU的进程个数。这里展示
了三个数值，每个数值对应不同的时间段。第一个是
最后 60秒的平均值，下一个是前 5分钟的平均值，最
后一个是前 15分钟的平均值。若平均值低于 1.0，则
指示计算机工作不忙碌。
2 Tasks:总结了进程数目和这些进程的各种状态。
3 Cpu(s):这一行描述了 CPU正在进行的活动的特性。
0.7%us 0.7%的 CPU被用于用户进程。这意味着进程在内核
之外。
1.0%sy 1.0%的 CPU时间被用于系统（内核）进程。
0.0%ni 0.0%的 CPU时间被用于”nice”（低优先级）进程。
98.3%id 98.3%的 CPU时间是空闲的。
0.0%wa 0.0%的 CPU时间来等待 I/O。
4 Mem:展示物理内存的使用情况。
5 Swap:展示交换分区（虚拟内存）的使用情况。
表 11-3: top命令信息字段
top程序接受一系列从键盘输入的命令。两个最有趣的命令是 h和 q。h，显示程序的帮助
126
屏幕，q，退出 top程序。
两个主要的桌面环境都提供了图形化应用程序，来显示与 top程序相似的信息（和 Windows
中的任务管理器差别不多），但是我觉得 top程序要好于图形化的版本，因为它运行速度快，并
且消费很少的系统资源。毕竟，我们的系统监测程序不能成为我们试图追踪的系统怠工的原
因。
11.4控制进程
现在我们可以看到和监测进程，让我们得到一些对它们的控制权。为了我们的实验，我们将使
用一个叫做 xlogo的小程序，作为我们的实验品。这个 xlogo程序是 X窗口系统（使图形界面
显示在屏幕上的底层引擎）提供的示例程序，这个程序仅显示一个大小可调的包含 X标志的窗
口。首先，我们需要知道测试的实验对象：
[me@linuxbox~]$xlogo
命令执行之后，一个包含 X标志的小窗口应该出现在屏幕的某个位置上。在一些系统中，
xlogo命令会打印一条警告信息，但是不用理会它。
小贴士：如果你的系统不包含 xlogo程序，试着用 gedit或者 kwrite来代替。
通过调整它的窗口大小，我们能够证明 xlogo程序正在运行。如果这个标志以新的尺寸被
重画，则这个程序正在运行。
注意，为什么我们的 shell提示符还没有返回？这是因为 shell正在等待这个程序结束，就像
到目前为止我们用过的其它所有程序一样。如果我们关闭 xlogo窗口，shell提示符就返回了。
11.5中断一个进程
我们再运行 xlogo程序一次，观察一下发生了什么事。首先，执行 xlogo命令，并且证实这个
程序正在运行。下一步，回到终端窗口，按下 Ctrl-c。
[me@linuxbox~]$xlogo
[me@linuxbox~]$
在一个终端中，输入 Ctrl-c，中断一个程序。这意味着，我们礼貌地要求终止这个程序。输
入 Ctrl-c之后，xlogo窗口关闭，shell提示符返回。
127
通过这个技巧，许多（但不是全部）命令行程序可以被中断。
11.6把一个进程放置到后台(执行)
假如说我们想让 shell提示符返回，却不终止 xlogo程序。我们可以把这个程序放到后台
(background)执行。把终端想象是一个有前台（包含在表层可见的事物，像 shell提示符）和
后台（包含表层之下的隐藏的事物）（的设备）。为了启动一个程序并让它立即在后台运行，我
们在程序命令之后，加上 “&”字符：
[me@linuxbox~]$xlogo&
[1]28236
[me@linuxbox~]$
执行命令之后，这个 xlogo窗口出现，并且 shell提示符返回，同时打印一些有趣的数字。
这条信息是 shell特性的一部分，叫做任务控制 (job control)。通过这条信息，shell告诉我们，
已经启动了任务号 (job number)为 1（“［1］”），PID为 28236的程序。如果我们运行 ps命令，
可以看到我们的进程：
[me@linuxbox~]$ps
PIDTTYTIMECMD
10603pts/100:00:00bash
28236pts/100:00:00xlogo
28239pts/100:00:00ps
shell的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行 jobs命令，
我们可以看到这个输出列表：
[me@linuxbox~]$jobs
[1]+Runningxlogo&
结果显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是 xlogo＆。
128
11.7进程返回到前台
一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c来中断它。为了让一个
进程返回前台 (foreground)，这样使用 fg命令：
[me@linuxbox~]$jobs
[1]+Runningxlogo&
[me@linuxbox~]$fg%1
xlogo
fg命令之后，跟随着一个百分号和任务序号（叫做 jobspec,如此处的%1）就可以了。如
果我们只有一个后台任务，那么 jobspec(job specification)是可有可无的。输入 Ctrl-c来终止
xlogo程序。
11.8停止一个进程
有时候，我们想要停止一个进程，而不是终止它。我们这么做通常是为了允许前台进程被移动
到后台。输入 Ctrl-z，可以停止一个前台进程。让我们试一下。在命令提示符下，执行 xlogo
命令，然后输入 Ctrl-z:
[me@linuxbox~]$xlogo
[1]+Stoppedxlogo
[me@linuxbox~]$
停止 xlogo程序之后，通过调整 xlogo的窗口大小，我们可以证实这个程序已经停止了。它
看起来像死掉了一样。使用 fg命令，可以恢复程序到前台运行，或者用 bg命令把程序移到后
台。
[me@linuxbox~]$bg%1
[1]+xlogo&
[me@linuxbox~]$
和 fg命令一样，如果只有一个任务的话，jobspec参数是可选的。
129
如果我们从命令行启动一个图形程序，但是忘了在命令后加字符“&”，将一个进程从前台
移动到后台也是很方便的。
为什么要从命令行启动一个图形界面程序呢？有两个原因。第一个，你想要启动的程序，可
能没有在窗口管理器的菜单中列出来（比方说 xlogo）。第二个，从命令行启动一个程序，你能
够看到一些错误信息，如果从图形界面中运行程序的话，这些信息是不可见的。有时候，一个
程序不能从图形界面菜单中启动。通过从命令行中启动它，我们可能会看到能揭示问题的错误
信息。一些图形界面程序还有许多有意思并且有用的命令行选项。
11.9Signals
kill命令被用来“杀死”程序。这样我们就可以终止需要杀死的程序。这里有一个例子：
[me@linuxbox~]$xlogo&
[1]28401
[me@linuxbox~]$kill28401
[1]+Terminatedxlogo
首先，我们在后台启动 xlogo程序。shell打印出这个后台进程的 jobspec和 PID。下一步，
我们使用 kill命令，并且指定我们想要终止的进程 PID。也可以用 jobspec（例如，“％1”）来
代替 PID。
虽然这个命令看上去很直白，但是它的含义不止于此。这个 kill命令不是真的“杀死”程
序，而是给程序发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一
种。在使用 Ctrl-c和 Ctrl-z的过程中我们已经看到信号的实际用法。当终端接受了其中一个
按键组合后，它会给在前端运行的程序发送一个信号。在使用 Ctrl-c的情况下，会发送一个叫
做 INT（Interrupt,中断）的信号；当使用 Ctrl-z时，则发送一个叫做 TSTP（Terminal Stop,
终端停止）的信号。程序，相应地，监听信号的到来，当程序接到信号之后，则做出响应。一
个程序能够监听和响应信号这件事允许一个程序做些事情，比如，当程序接到一个终止信号时，
它可以保存所做的工作。
11.10通过kill命令给进程发送信号
kill命令被用来给程序发送信号。它最常见的语法形式看起来像这样：
130
kill[-signal]PID...
如果在命令行中没有指定信号，那么默认情况下，发送 TERM（Terminate，终止）信号。
kill命令被经常用来发送以下命令：
编号名字含义
1 HUP挂起（Hangup）。这是美好往昔的残留部分，那时候终
端机通过电话线和调制解调器连接到远端的计算机。
这个信号被用来告诉程序，控制的终端机已经“挂
断”。通过关闭一个终端会话，可以展示这个信号的作
用。在当前终端运行的前台程序将会收到这个信号并
终止。许多守护进程也使用这个信号，来重新初始化。
这意味着，当一个守护进程收到这个信号后，这个进
程会重新启动，并且重新读取它的配置文件。Apache
网络服务器守护进程就是一个例子。
2 INT中断。实现和 Ctrl-c一样的功能，由终端发送。通常，
它会终止一个程序。
9 KILL杀死。这个信号很特别。尽管程序可能会选择不同的
方式来处理发送给它的信号，其中也包含忽略信号，
但是 KILL信号从不被发送到目标程序。而是内核立
即终止这个进程。当一个进程以这种方式终止的时候，
它没有机会去做些“清理”工作，或者是保存工作。
因为这个原因，把 KILL信号看作最后一招，当其它
终止信号失败后，再使用它。
15 TERM终止。这是 kill命令发送的默认信号。如果程序仍然
“活着”，可以接受信号，那么这个它会终止。
18 CONT继续。在一个停止信号后，这个信号会恢复进程的运
行。
19 STOP停止。这个信号导致进程停止运行，而不是终止。像
KILL信号，它不被发送到目标进程，因此它不能被
忽略。
131
表 11-4:常用信号
让我们试一下 kill命令：
[me@linuxbox~]$xlogo&
[1]13546
[me@linuxbox~]$kill-113546
[1]+Hangupxlogo
在这个例子里，我们在后台启动 xlogo程序，然后通过 kill命令，发送给它一个 HUP信
号。这个 xlogo程序终止运行，并且 shell指示这个后台进程已经接受了一个挂起信号。在看
到这条信息之前，你可能需要多按几次 enter键。注意，信号既可以用号码，也可以用名字来
指定，包括在前面加上字母“SIG”的名字。
[me@linuxbox~]$xlogo1]13601
[me@linuxbox~]$kill-INT13601
[1]+Interruptxlogo
[me@linuxbox~]$xlogo&
[1]13608
[me@linuxbox~]$kill-SIGINT13608
[1]+Interruptxlogo
重复上面的例子，试着使用其它的信号。记住，你也可以用 jobspecs来代替 PID。
进程，和文件一样，拥有所有者，所以为了能够通过 kill命令来给进程发送信号，你必须是
进程的所有者（或者是超级用户）。
除了上表列出的 kill命令最常使用的信号之外，还有一些系统频繁使用的信号。以下是其
它一些常用信号列表：
编号名字含义
3 QUIT退出
11 SEGV段错误 (Segmentation Violation)。如果一个程序非法
使用内存，就会发送这个信号。也就是说，程序试图
写入内存，而这个内存空间是不允许此程序写入的。
132
20 TSTP终端停止 (Terminal Stop)。当按下 Ctrl-z组合键后，
终端发送这个信号。不像 STOP信号，TSTP信号由
目标进程接收，且可能被忽略。
28 WINCH改变窗口大小 (Window Change)。当改变窗口大小
时，系统会发送这个信号。一些程序，像 top和 less
程序会响应这个信号，按照新窗口的尺寸，刷新显示
的内容。
表 11-5:其它常用信号
为了满足读者的好奇心，通过下面的命令可以得到一个完整的信号列表：
[me@linuxbox~]$kill-l
11.11通过killall命令给多个进程发送信号
也有可能通过 killall命令，给匹配特定程序或用户名的多个进程发送信号。下面是 killall命令
的语法形式：
killall[-uuser][-signal]name...
为了说明情况，我们将启动一对 xlogo程序的实例，然后再终止它们：
[me@linuxbox~]$xlogo&
[1]18801
[me@linuxbox~]$xlogo&
[2]18802
[me@linuxbox~]$killallxlogo
[1]-Terminatedxlogo
[2]+Terminatedxlogo
记住，和 kill命令一样，你必须拥有超级用户权限才能给不属于你的进程发送信号。
133
11.12更多和进程相关的命令
因为监测进程是一个很重要的系统管理任务，所以有许多命令与它相关。玩玩下面几个命令：
命令名命令描述
pstree输出一个树型结构的进程列表 (processtree)，这个列表展示
了进程间父/子关系。
vmstat输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/
O。为了看到连续的显示结果，则在命令名后加上更新操作
延时的时间（以秒为单位）。例如，“vmstat 5”。，按下 Ctrl-c
组合键,终止输出。
xload一个图形界面程序，可以画出系统负载随时间变化的图形。
tload terminal load与 xload程序相似，但是在终端中画出图形。
使用 Ctrl-c，来终止输出。
表 11-6:其它与进程相关的命令
134
12|shell环境
恰如我们之前所讲的，shell在 shell会话中保存着大量信息。这些信息被称为 (shell的)环境。
程序获取环境中的数据（即环境变量）来了解本机的配置。虽然大多数程序用配置文件来存储
程序设置，一些程序会根据环境变量来调整他们的行为。知道了这些，我们就可以用环境变量
来自定制 shell体验。
在这一章，我们将用到以下命令：
• printenv -打印部分或所有的环境变量
• set -设置 shell选项
• export—导出环境变量，让随后执行的程序知道。
• alias -创建命令别名
12.1什么存储在环境变量中？
shell在环境中存储了两种基本类型的数据，虽然 bash几乎无法分辨这些数据的类型。它们
是环境变量和 shell变量。Shell变量是 bash存放的少量数据。剩下的都是环境变量。除了变
量，shell也存储了一些可编程的数据，即别名和 shell函数。我们已经在第六章讨论了别名，
而 shell函数（涉及到 shell脚本）将会在本章第五部分叙述。
12.2检查环境变量
我们可以用 bash的内建命令 set，或者是 printenv程序来查看环境变量。set命令可以显示
shell或环境变量，而 printenv只是显示环境变量。因为环境变量列表比较长，最好把每个命令
的输出通过管道传递给 less来阅读：
135
[me@linuxbox~]$printenv|less
执行以上命令之后，我们应该能得到类似以下内容：
KDE_MULTIHEAD=false
SSH_AGENT_PID=6666
HOSTNAME=linuxbox
GPG_AGENT_INFO=/tmp/gpg-PdOt7g/S.gpg-agent:6689:1
SHELL=/bin/bash
TERM=xterm
XDG_MENU_PREFIX=kde-
HISTSIZE=1000
XDG_SESSION_COOKIE=6d7b05c65846c3eaf3101b0046bd2b00-1208521990.996705
-1177056199
GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/me/.gtkrc-2.0:/home/me/.kde/sh
are/config/gtkrc-2.0
GTK_RC_FILES=/etc/gtk/gtkrc:/home/me/.gtkrc:/home/me/.kde/share/confi
g/gtkrc
GS_LIB=/home/me/.fonts
WINDOWID=29360136
QTDIR=/usr/lib/qt-3.3
QTINC=/usr/lib/qt-3.3/include
KDE_FULL_SESSION=true
USER=me
LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01
:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:\*.cmd=00;32:\*.exe:
我们所看到的是环境变量及其数值的列表。例如，我们看到一个叫做 USER的变量，这个
变量值是 “me”。printenv命令也能够列出特定变量的数值：
[me@linuxbox~]$printenvUSER
me
当使用没有带选项和参数的 set命令时，shell变量，环境变量，和定义的 shell函数都会被
显示。不同于 printenv命令，set命令的输出很友好地按照首字母顺序排列：
136
[me@linuxbox~]$set|less
也可以通过 echo命令来查看一个变量的内容，像这样：
[me@linuxbox~]$echo$HOME
/home/me
别名无法通过使用 set或 printenv来查看。用不带参数的 alias来查看别名:
[me@linuxbox~]$alias
aliasl.='ls-d.*--color=tty'
aliasll='ls-l--color=tty'
aliasls='ls--color=tty'
aliasvi='vim'
aliaswhich='alias|/usr/bin/which--tty-only--read-alias--show-dot--show-tilde'
12.3一些有趣的环境变量
shell环境中包含相当多的变量。虽然你的 shell环境可能与这里的不同，你可能会看到以下的
环境变量：
变量内容
DISPLAY如果你正在运行图形界面环境，那么这个变量就是你显示器
的名字。通常，它是”:0”，意思是由 X产生的第一个显示
器。
EDITOR文本编辑器的名字。
SHELL shell程序的名字。
HOME用户家目录。
LANG定义了字符集以及语言编码方式。
OLD_PWD先前的工作目录。
PAGER页输出程序的名字。这经常设置为/usr/bin/less。
137
PATH由冒号分开的目录列表，当你输入可执行程序名后，会搜索
这个目录列表。
PS1 Prompt String 1.这个定义了你的 shell提示符的内容。随
后我们可以看到，这个变量内容可以全面地定制。
PWD当前工作目录。
TERM终端类型名。类 Unix的系统支持许多终端协议；这个变量
设置你的终端仿真器所用的协议。
TZ指定你所在的时区。大多数类 Unix的系统按照协调时间时
(UTC)来维护计算机内部的时钟，然后应用一个由这个变
量指定的偏差来显示本地时间。
USER你的用户名
表 12-1:环境变量
如果缺失了一些变量，不要担心，这些变量会因发行版本的不同而不同。
12.4如何建立shell环境？
当我们登录系统后，bash程序启动，并且会读取一系列称为启动文件的配置脚本，这些文件定
义了默认的可供所有用户共享的 shell环境。然后是读取更多位于我们自己家目录中的启动文
件，这些启动文件定义了用户个人的 shell环境。确切的启动顺序依赖于要运行的 shell会话类
型。有两种 shell会话类型：一个是登录 shell会话，另一个是非登录 shell会话。
登录 shell会话会在其中提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会
话。非登录 shell会话通常当我们在 GUI下启动终端会话时出现。
登录 shell会读取一个或多个启动文件，正如表 12－ 2所示：
文件内容
/etc/profile应用于所有用户的全局配置脚本。
˜/.bash_profile用户个人的启动文件。可以用来扩展或重写全局配置脚本
中的设置。
˜/.bash_login如果文件 ˜/.bash_profile没有找到，bash会尝试读取这个
脚本。
138
˜/.profile如果文件 ˜/.bash_profile或文件 ˜/.bash_login都没有找
到，bash会试图读取这个文件。这是基于 Debian发行版的
默认设置，比方说 Ubuntu。
表 12-2:登录 shell会话的启动文件
非登录 shell会话会读取以下启动文件：
文件内容
/etc/bash.bashrc应用于所有用户的全局配置文件。
˜/.bashrc用户个人的启动文件。可以用来扩展或重写全局配置脚本
中的设置。
表 12-3:非登录 shell会话的启动文件
除了读取以上启动文件之外，非登录 shell会话也会继承它们父进程的环境设置，通常是一
个登录 shell。
浏览一下你的系统，看一看系统中有哪些启动文件。记住－因为上面列出的大多数文件名
都以圆点开头（意味着它们是隐藏文件），你需要使用带 “-a”选项的 ls命令。
在普通用户看来，文件/.bashrc可能是最重要的启动文件，因为它几乎总是被读取。非
登录 shell默认会读取它，并且大多数登录 shell的启动文件会以能读取/.bashrc文件的方式
来书写。
12.5一个启动文件的内容
如果我们看一下典型的.bash_profile文件（来自于 CentOS 4系统），它看起来像这样：
#.bash_profile
#Getthealiasesandfunctions
if[-f~/.bashrc];then
.~/.bashrc
fi
#Userspecificenvironmentandstartupprograms
PATH=$PATH:$HOME/bin
exportPATH
139
以 “#”开头的行是注释，shell不会读取它们。它们在那里是为了方便人们阅读。第一件有
趣的事情发生在第四行，伴随着以下代码：
if[-f~/.bashrc];then
.~/.bashrc
fi
这叫做一个 if复合命令，我们将会在第五部分详细地介绍它，现在我们对它翻译一下：
Ifthefile~/.bashrcexists,then
readthe~/.bashrcfile.
我们可以看到这一小段代码就是一个登录 shell得到.bashrc文件内容的方式。在我们启动
文件中，下一件有趣的事与 PATH变量有关系。
是否曾经对 shell怎样知道在哪里找到我们在命令行中输入的命令感到迷惑？例如，当我们
输入 ls后，shell不会查找整个计算机系统来找到 /bin/ls（ls命令的全路径名），相反，它查找
一个目录列表，这些目录包含在 PATH变量中。
PATH变量经常（但不总是，依赖于发行版）在 /etc/profile启动文件中设置，通过这些代
码：
PATH=$PATH:$HOME/bin
修改 PATH变量，添加目录 $HOME/bin到目录列表的末尾。这是一个参数展开的实例，
参数展开我们在第八章中提到过。为了说明这是怎样工作的，试试下面的例子：
[me@linuxbox~]$foo="Thisissome"
[me@linuxbox~]$echo$foo
Thisissome
[me@linuxbox~]$foo="$footext."
[me@linuxbox~]$echo$foo
Thisissometext.
140
使用这种技巧，我们可以把文本附加到一个变量值的末尾。通过添加字符串 $HOME/bin
到 PATH变量值的末尾，则目录 $HOME/bin就添加到了命令搜索目录列表中。这意味着当
我们想要在自己的家目录下，创建一个目录来存储我们自己的私人程序时，shell已经给我们准
备好了。我们所要做的事就是把创建的目录叫做 bin，赶快行动吧。
注意：很多发行版默认地提供了这个 PATH设置。一些基于 Debian的发行版，例如
Ubuntu，在登录的时候，会检测目录/bin是否存在，若找到目录则把它动态地加到 PATH
变量中。
最后，有下面一行代码：
exportPATH
这个 export命令告诉 shell让这个 shell的子进程可以使用 PATH变量的内容。
12.6修改shell环境
既然我们知道了启动文件所在的位置和它们所包含的内容，我们就可以修改它们来定制自己的
shell环境。
12.7我们应该修改哪个文件？
按照通常的规则，添加目录到你的 PATH变量或者是定义额外的环境变量，要把这些更改放置
到.bash_profile文件中（或者其替代文件中，根据不同的发行版。例如，Ubuntu使用.profile
文件）。对于其它的更改，要放到.bashrc文件中。除非你是系统管理员，需要为系统中的所有
用户修改默认设置，那么则限定你只能对自己家目录下的文件进行修改。当然，有可能会更改
/etc目录中的文件，比如说 profile文件，而且在许多情况下，修改这些文件也是明智的，但是
现在，我们要谨慎行事。
12.8文本编辑器
为了编辑（例如，修改）shell的启动文件以及系统中大多数其它配置文件，我们使用一个叫做
文本编辑器的程序。文本编辑器是一个在某些方面类似于文字处理器的程序，允许你使用移动
光标在屏幕上编辑文字。文本编辑器不同于文字处理器之处在于它只能支持纯文本，并且经常
包含为便于写程序而设计的特性。文本编辑器是软件开发人员用来写代码，以及系统管理员用
来管理控制系统的配置文件的重要工具。
141
Linux系统有许多不同类型的文本编辑器可用；你的系统中可能已经安装了几个。为什么会
有这么多种呢？可能因为程序员喜欢编写它们，又因为程序员们会频繁地使用它们，所以程序
员编写编辑器让它们按照程序员自己的愿望工作。
文本编辑器分为两种基本类型：图形化的和基于文本的编辑器。GNOME和 KDE两者都
包含一些流行的图形化编辑器。GNOME自带了一个叫做 gedit的编辑器，这个编辑器通常在
GNOME菜单中称为 “文本编辑器”。KDE通常自带了三种编辑器，分别是（按照复杂度递增
的顺序排列）kedit，kwrite，kate。
有许多基于文本的编辑器。你将会遇到一些流行的编辑器，它们是 nano、vi和 emacs。
nano编辑器是一个简单易用的编辑器，用于替代随 PINE邮件套件提供的 pico编辑器。vi编
辑器（在大多数 Linux系统中被 vim替代，vim是 “Vi IMproved”的简写）是类 Unix操作系
统的传统编辑器。vim是我们下一章节的讨论对象。emacs编辑器最初由 Richard Stallman写
成。它是一个庞大、多用途的，可做任何事情的编程环境。虽然 emacs很容易获取，但是大多
数 Linux系统很少默认安装它。
12.9使用文本编辑器
所有的文本编辑器都可以通过在命令行中输入编辑器的名字，加上你所想要编辑的文件来唤
醒。如果所输入的文件名不存在，编辑器则会假定你想要创建一个新文件。下面是一个使用
gedit的例子：
[me@linuxbox~]$geditsome_file
这条命令将会启动 gedit文本编辑器，同时加载名为 “some_file”的文件，如果这个文件存
在的话。
所有的图形文本编辑器很大程度上都是不需要解释的，所以我们在这里不会介绍它们。反
之，我们将集中精力在我们第一个基于文本的文本编辑器，nano。让我们启动 nano，并且编辑
文件.bashrc。但是在我们这样做之前，先练习一些 “安全计算”。当我们编辑一个重要的配置文
件时，首先创建一个这个文件的备份总是一个不错的主意。这样能避免我们在编辑文件时弄乱
文件。创建文件.bashrc的备份文件，这样做：
[me@linuxbox~]$cp.bashrc.bashrc.bak
142
备份文件的名字无关紧要，只要选择一个容易理解的文件名。扩展名 “.bak”、”.sav”、“.old”
和 “.orig”都是用来指示备份文件的流行方法。哦，记住 cp命令会默默地覆盖已经存在的同名
文件。
现在我们有了一个备份文件，我们启动 nano编辑器吧：
[me@linuxbox~]$nano.bashrc
一旦 nano编辑器启动后，我们将会得到一个像下面一样的屏幕：
GNUnano2.0.3
....
注意：如果你的系统中没有安装 nano编辑器，你可以用一个图形化的编辑器代替。
这个屏幕由上面的标头，中间正在编辑的文件文本和下面的命令菜单组成。因为设计 nano
是为了代替由电子邮件客户端提供的编辑器的，所以它相当缺乏编辑特性。在任一款编辑器中，
你应该学习的第一个命令是怎样退出程序。以 nano为例，你输入 Ctrl-x来退出 nano。在屏幕
底层的菜单中说明了这个命令。“ˆX”表示法意思是 Ctrl-x。这是控制字符的常见表示法，许多
程序都使用它。
第二个我们需要知道的命令是怎样保存我们的劳动成果。对于 nano来说是 Ctrl-o。既然我
们已经获得了这些知识，接下来我们准备做些编辑工作。使用下箭头按键和 /或下翻页按键，
移动鼠标到文件的最后一行，然后添加以下几行到文件.bashrc中：
umask0002
exportHISTCONTROL=ignoredups
exportHISTSIZE=1000
aliasl.='ls-d.*--color=auto'
aliasll='ls-l--color=auto'
注意：你的发行版在这之前可能已经包含其中的一些行，出现重复的代码不会有其他影响。
下表是所添加行的意义：
文本行含义
umask 0002设置掩码来解决共享目录的问题。
143
export HISTCON-使得 shell的历史记录功能忽略一个命令，如果
TROL=ignoredups相同的命令已被记录。
export HISTSIZE=1000增加命令历史的大小，从默认的 500行扩大到
1000行。
alias l.=’ls -d .* --color=auto’创建一个新命令，叫做’l.’，这个命令会显示所有
以点开头的目录项。
alias ll=’ls -l --color=auto’创建一个叫做’ll’的命令，这个命令会显示长格
式目录列表。
表 12-4:
正如我们所看到的，我们添加的许多代码的意思直觉上并不是明显的，所以添加注释到我们
的文件.bashrc中是一个好主意，可以帮助人们理解。使用编辑器，更改我们添加的代码，让它
们看起来像这样：
#Changeumasktomakedirectorysharingeasier
umask0002
#Ignoreduplicatesincommandhistoryandincrease
#historysizeto1000lines
exportHISTCONTROL=ignoredups
exportHISTSIZE=1000
#Addsomehelpfulaliases
aliasl.='ls-d.*--color=auto'
aliasll='ls-l--color=auto'
啊，看起来好多了!当我们完成修改后，输入 Ctrl-o来保存我们修改的.bashrc文件，输入
Ctrl-x退出 nano。
为什么注释很重要？
不管什么时候你修改配置文件时，给你所做的更改加上注释都是一个好主意。的
确，明天你会记得你修改了的内容，但是六个月之后会怎样呢？帮自己一个忙，加
上一些注释吧。当你意识到这一点后，对你所做的修改做个日志是个不错的主意。
Shell脚本和 bash启动文件都使用 “#”符号来开始注释。其它配置文件可能使
用其它的符号。大多数配置文件都有注释。把它们作为指南。
144
你会经常看到配置文件中的一些行被注释掉，以此防止它们被受影响的程序使
用。这样做是为了给读者在可能的配置选项方面一些建议，或者给出正确的配置语
法实例。例如，Ubuntu 8.04中的.bashrc文件包含这些行：
#somemorelsaliases
#aliasll='ls-l'
#aliasla='ls-A'
#aliasl='ls-CF'
最后三行是有效的被注释掉的别名定义。如果你删除这三行开头的 “#”符号，
此技术程称为 uncommenting (取消注释)，这样你就会激活这些别名。相反地，如
果你在一行的开头加上 “#”符号，你可以注销掉这一行，但会保留它所包含的信
息。
12.10激活我们的修改
我们对于文件.bashrc的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话，因
为.bashrc文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash重新读取修改过
的.bashrc文件，使用下面的命令：
[me@linuxbox~]$source.bashrc
运行上面命令之后，我们就应该能够看到所做修改的效果了。试试其中一个新的别名：
[me@linuxbox~]$ll
12.11总结
在这一章中，我们学到了用文本编辑器来编辑配置文件的基本技巧。随着学习的继续，当我们
浏览命令的手册页时，可以记录下该命令所支持的环境变量。这样或许我们能够收获一到两个
145
特别好用的宝贝命令。在随后的章节里面，我们将会学习 shell函数，一个很强大的特性，你可
以把它包含在 bash启动文件里面，以此来添加你自定制的命令宝库。
12.12拓展阅读
bash手册页的 INVOCATION部分非常详细地讨论了 bash启动文件。
146
13|vi简介
有一个古老的笑话，说是一个在纽约的游客向行人打听这座城市中著名古典音乐场馆的方向：
游客：请问一下，我怎样去卡内基音乐大厅？
行人：练习，练习，练习!
学习 Linux命令行，就像要成为一名造诣很深的钢琴家一样，它不是我们一下午就能学会
的技能。这需要经历几年的勤苦练习。在这一章中，我们将介绍 vi（发音“vee eye”）文本编辑
器，它是 Unix传统中核心程序之一。vi因它难用的用户界面而有点声名狼藉，但是当我们看
到一位大师坐在钢琴前开始演奏时，我们的确成了伟大艺术的见证人。虽然我们在这里不能成
为 vi大师，但是当我们学完这一章后，我们会知道怎样在 vi中弹奏像“Chopsticks”那样的钢
琴小品。
13.1为什么我们应该学习vi
在现在这个图形化编辑器和易于使用的基于文本编辑器的时代，比如说 nano，为什么我们还应
该学习 vi呢？下面有三个充分的理由：
• vi很多系统都预装。如果我们的系统没有图形界面，比方说一台远端服务器或者是一个
X配置损坏了的本地系统，那么 vi就成了我们的救星。虽然 nano逐渐流行起来，但是
它还没有普及。POSIX，这套 Unix系统中程序兼容的标准，就要求系统要预装 vi。
• vi轻量级且执行快。对于许多任务来说，启动 vi比起在菜单中找到一个图形化文本编辑
器， 再等待其数倍兆字节的数据加载而言，要容易的多。另外，vi是为了加快输入速度
而设计的。我们将会看到，当一名熟练的 vi用户在编辑文件时，他或她的手从不需要移
开键盘。
•我们不希望其他 Linux和 Unix用户把我们看作胆小鬼。
好吧，可能只有两个充分的理由。
147
13.2一点儿背景介绍
第一版 vi是在 1976由 Bill Joy写成的，当时他是加州大学伯克利分校的学生，后来他共同创
建了 Sun微系统公司。vi这个名字来源于单词“visual”，因为它打算在带有可移动光标的视频
终端上编辑文本。在发明可视化编辑器之前，有一次只能操作一行文本的行编辑器。为了编辑，
我们需要告诉行编辑器到一个特殊行并且说明做什么修改，比方说添加或删除文本。视频终端
（而不是基于打印机的终端，像电传打印机）的出现，使可视化编辑成为可能。vi实际上整合了
一个强大的行编辑器————ex ,所以我们在使用 vi时能运行行编辑命令。
大多数 Linux发行版不包含真正的 vi；而是自带一款高级替代版本，叫做 vim（它是“vi
improved”的简写）由 Bram Moolenaar开发的。vim相对于传统的 Unix vi来说，取得了实
质性进步。通常，vim在 Linux系统中是“vi”的符号链接（或别名）。在随后的讨论中，我们
将会假定我们有一个叫做“vi”的程序，但它其实是 vim。
13.3启动和退出vi
要想启动 vi，只要简单地输入以下命令：
[me@linuxbox~]$vi
一个像这样的屏幕应该出现：
VIM-ViImproved
....
正如我们之前操作 nano时，首先要学的是怎样退出 vi。要退出 vi，输入下面的命令（注意
冒号是命令的一部分）：
:q
shell提示符应该重新出现。如果由于某种原因，vi不能退出（通常因为我们对文件做了修
改，却没有保存文件）。通过给命令加上叹号，我们可以告诉 vi我们真要退出 vi。（注意感叹号
是命令的一部分）
148
:q!
小贴示：如果你在 vi中“迷失”了，试着按下 Esc键两次来回到普通模式。
兼容模式
在上面的截屏中（来自于 Ubuntu 8.04），我们看到一行文字“运行于 Vi兼容模
式。”这意味着 vim将以近似于 vi的普通的模式运行，而不是以 vim的高级的模式
运行。出于本章的教学目的，我们将使用 vim和它的的高级模式。要这样使用 vim，
可以通过如下方法：
用 vim来代替 vi。
如果命令生效，考虑在你的.bashrc文件中添加 alias vi=’vim’。
或者，使用以下命令在你的 vim配置文件中添加一行：
echo“setnocp”>>/.vimrc
不同 Linux发行版自带的 vim软件包各不相同。一些发行版预装了 vim的最简
版，其只支持很有限的 vim特性。在随后练习里，你可能发现你的 vim缺失一些特
性。若是如此，请安装 vim的完整版。
13.4编辑模式
再次启动 vi，这次传递给 vi一个不存在的文件名。这也是用 vi创建新文件的方法。
[me@linuxbox~]$rm-ffoo.txt
[me@linuxbox~]$vifoo.txt
如果一切正常，我们应该获得一个像这样的屏幕：
....
"foo.txt"[NewFile]
每行开头的波浪号（“”）表示那一行没有文本。这里我们有一个空文件。先别进行输入！
149
关于 vi，第二重要的事是知晓 vi是一个模式编辑器。（第一件事是如何退出 vi）vi启动后
会直接进入命令模式。这种模式下，几乎每个按键都是一个命令，所以如果我们直接输入文本，
vi会发疯，弄得一团糟。
13.4.1插入模式
为了在文件中添加文本，我们需要先进入插入模式。按下 “i”键进入插入模式。之后，我们应
当在屏幕底部看到如下的信息，如果 vi运行在高级模式下（vi在兼容模式下不会显示这行信
息）：
--INSERT--
现在我们能输入一些文本了。试着输入这些文本：
Thequickbrownfoxjumpedoverthelazydog.
若要退出插入模式返回命令模式，按下 Esc按键。
13.4.2保存我们的工作
为了保存我们刚才对文件所做的修改，我们必须在命令模式下输入一个 ex命令。通过按下 “:”
键，这很容易完成。按下冒号键之后，一个冒号字符应该出现在屏幕的底部：
:
为了写入我们修改的文件，我们在冒号之后输入 “w”字符，然后按下回车键：
:w
文件将会写入到硬盘，而且我们会在屏幕底部看到一行确认信息，就像这样：
150
"foo.txt"[New]1L,46Cwritten
小贴示：如果你阅读 vim的文档，你会发现命令模式被（令人困惑地）叫做普通模式，ex
命令叫做命令模式。当心。
13.5移动光标
当在 vi命令模式下时，vi提供了大量的移动命令，其中一些与 less阅读器的相同。这里列举
了一些：
按键移动光标
l or右箭头向右移动一个字符
h or左箭头向左移动一个字符
j or下箭头向下移动一行
k or上箭头向上移动一行
0 (零按键)移动到当前行的行首。
^移动到当前行的第一个非空字符。
$移动到当前行的末尾。
w移动到下一个单词或标点符号的开头。
W移动到下一个单词的开头，忽略标点符号。
b移动到上一个单词或标点符号的开头。
B移动到上一个单词的开头，忽略标点符号。
Ctrl-f or Page Down向下翻一页
Ctrl-b or Page Up向上翻一页
numberG移动到第 number行。例如，1G移动到文件的
第一行。
G移动到文件末尾。
表 13-1:光标移动按键
为什么 h，j，k，和 l按键被用来移动光标呢？因为在开发 vi之初，并不是所有的视频终端
都有箭头按键，熟练的打字员可以使用组合键来移动光标，他们的手指从不需要移开键盘。
vi中的许多命令都可以在前面加上一个数字，比方说上面提到的 “G”命令。在命令之前加
151
上一个数字，我们就可以指定命令执行的次数。例如，命令 “5j”将光标下移 5行。
13.6基本编辑
大多数编辑工作由一些基本的操作组成，比如说插入文本，删除文本和通过剪切和粘贴来移动
文本。vi，当然，有它独特方式来实现所有的操作。vi也提供了撤销功能，但有些限制。如果
我们按下“u”按键，当在命令模式下，vi将会撤销你所做的最后一次修改。当我们试着执行一
些基本的编辑命令时，这会很方便。
13.6.1追加文本
vi有几种不同进入插入模式的方法。我们已经使用了 i命令来插入文本。
让我们再次进入到我们的 foo.txt文件：
Thequickbrownfoxjumpedoverthelazydog.
如果我们想要在这个句子的末尾添加一些文本，我们会发现 i命令不能完成任务，因为我们
不能把光标移到行尾。vi提供了追加文本的命令，明智地命名为 “a”。如果我们把光标移动到
行尾，输入”a”,光标就会越过行尾，同时 vi会进入插入模式。这让我们能添加文本到行末：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
记得按 Esc键来退出插入模式。
因为我们几乎总是想要在行尾添加文本，所以 vi提供了一个快捷键。光标将移动到行尾，
同时 vi进入输入模式。它是 “A”命令。试着用一下它，向文件添加更多行。
首先，使用 “0”(零)命令，将光标移动到行首。现在我们输入”A”，然后输入下面这些文本：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Line5
152
再一次，按下 Esc键退出插入模式。
正如我们所看到的，“A”命令非常有用，因为它在进入到插入模式前，先将光标移到了行
尾。
13.6.2打开一行
我们插入文本的另一种方式是“打开（open）”一行。这会在两行之间插入一个空白行，并且进
入到插入模式。这种方式有两个变体：
命令打开行
o当前行的下方打开一行。
O当前行的上方打开一行。
表 13-2:文本行打开按键
我们可以演示一下：把光标移到 “Line 3”上，再按下小 o按键。
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
line4
line5
在第三行之下打开了新的一行，并且进入插入模式。按下 Esc，退出插入模式。按下 u按
键，撤销我们的修改。
按下大 O按键在光标之上打开新的一行：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Line5
按下 Esc按键，退出插入模式，并且按下 u按键，撤销我们的更改。
153
13.6.3删除文本
正如我们所愿，vi提供了各种删除文本到的方法，而且只需一或两个按键。首先，x按键会删
除光标位置的一个字符。可以在 x命令之前带上一个数字，来指明要删除的字符个数。d按键
更通用一些。跟 x命令一样，d命令之前可以带上一个数字，来指定要执行的删除次数。另外，
d命令之后总是带上一个移动命令，用来控制删除的范围。这里有些实例：
命令删除的文本
x当前字符
3x当前字符及其后的两个字符。
dd当前行。
5dd当前行及随后的四行文本。
dW从光标位置开始到下一个单词的开头。
d$从光标位置开始到当前行的行尾。
d0从光标位置开始到当前行的行首。
d^从光标位置开始到文本行的第一个非空字符。
dG从当前行到文件的末尾。
d20G从当前行到文件的第 20行。
表 13-3:文本删除命令
把光标放到第一行单词“It”之上。重复按下 x按键直到删除剩下的部分。下一步，重复按
下 u按键直到恢复原貌。
注意：真正的 vi只是支持单层面的 undo命令。vim则支持多个层面的。
我们再次执行删除命令，这次使用 d命令。还是移动光标到单词 “It”之上，按下的 dW来
删除单词：
Thequickbrownfoxjumpedoverthelazydog.wascool.
Line2
Line3
Line4
Line5
按下 d$删除从光标位置到行尾的文本：
154
Thequickbrownfoxjumpedoverthelazydog.
Line2
Line3
Line4
Line5
按下 dG按键删除从当前行到文件末尾的所有行：
~
....
连续按下 u按键三次，来恢复删除部分。
13.6.4剪切，复制和粘贴文本
这个 d命令不仅删除文本，它还“剪切”文本。每次我们使用 d命令，删除的部分被复制到一
个粘贴缓冲区中（看作剪切板）。过后我们执行小 p命令把剪切板中的文本粘贴到光标位置之
后，或者是大 P命令把文本粘贴到光标之前。
y命令用来“拉”（复制）文本，和 d命令剪切文本的方式差不多。这里有些把 y命令和各
种移动命令结合起来使用的实例：
命令复制的内容
yy当前行。
5yy当前行及随后的四行文本。
yW从当前光标位置到下一个单词的开头。
y$从当前光标位置到当前行的末尾。
y0从当前光标位置到行首。
y^从当前光标位置到文本行的第一个非空字符。
yG从当前行到文件末尾。
y20G从当前行到文件的第 20行。
表 13-4:复制命令
我们试着做些复制和粘贴工作。把光标放到文本第一行，输入 yy来复制当前行。下一步，
155
把光标移到最后一行（G），输入小写的 p把复制的一行粘贴到当前行的下面：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Line5
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
和以前一样，u命令会撤销我们的修改。这时光标仍位于文件的最后一行，输入大写的 P
命令把所复制的文本粘贴到当前行之上：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line5
试着执行上表中其他的一些 y命令，了解小写 p和大写 P命令的行为。当你完成练习之后，
把文件恢复原样。
13.6.5连接行
vi对于行的概念相当严格。通常，用户不可能通过删除“行尾结束符”（end-of-line character）
来连接当前行和它下面的一行。由于这个原因，vi提供了一个特定的命令，大写的 J（不要与
小写的 j混淆了，j是用来移动光标的）用于链接行与行。
如果我们把光标放到 line 3上，输入大写的 J命令，看看发生什么情况：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3Line4
Line5
156
13.7查找和替换
vi能把光标移到搜索到的匹配项上。vi不仅能在搜索一特定行，还能进行全文搜索。它也可以
在有或没有用户确认的情况下实现文本替换。
13.7.1查找一行
f命令能搜索一特定行，并将光标移动到下一个匹配的字符上。例如，命令 fa会把光标定位到
同一行中下一个出现的 “a”字符上。在进行了一次行内搜索后，输入分号能重复这次搜索。
13.7.2查找整个文件
移动光标到下一个出现的单词或短语上，使用 /命令。这个命令和我们之前在 less程序中学到
的一样。当你输入/命令后，一个 “/”字符会出现在屏幕底部。接下来，输入要查找的单词或
短语，按下回车。光标就会移动到下一个包含所查找字符串的位置。通过 n命令来重复先前的
查找。这里有个例子：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Line5
移动光标到文件的第一行。输入：
/Line
然后敲回车。光标会移动到第二行。然后输入 n，这时光标移动到第三行。重复键入 n命
令，光标会继续向下移动直到遍历所有的匹配项。至此我们只是通过输入单词和短语进行搜索，
但 vi支持正则表达式，一种用于表达复杂文本的方法。我们将会在之后的章节中详细讲解正则
表达式。
13.7.3全局查找和替代
vi使用 ex命令来执行查找和替代操作（vi中叫做“替换”）。将整个文件中的单词“Line”更改
为“line”，输入以下命令：
157
:%s/Line/line/g
我们把这个命令分解为几个单独的部分，看一下每部分的含义：
条目含义
:冒号字符运行一个 ex命令。
%指定要操作的行数。%是一个快捷方式，表示从第一行到最
后一行。另外，操作范围也可以用 1,5来代替（因为我们的
文件只有 5行文本），或者用 1,$来代替，意思是“从第一
行到文件的最后一行。”如果省略了文本行的范围，那么操
作只对当前行生效。
s指定操作。在这种情况下是，替换（查找与替代）。
/Line/line查找类型与替代文本。
g这是“全局”的意思，意味着对文本行中所有匹配的字符串
执行查找和替换操作。如果省略 g，则只替换每个文本行中
第一个匹配的字符串。
执行完查找和替代命令之后，我们的文件看起来像这样：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
line2
line3
line4
line5
我们也可以指定一个需要用户确认的替换命令。通过添加一个 “c”字符到这个命令的末尾，
来完成这个替换命令。例如：
:%s/line/Line/gc
这个命令会把我们的文件恢复先前的模样；然而，在执行每个替换命令之前，vi会停下来，
通过下面的信息，来要求我们确认这个替换：
158
replacewithLine(y/n/a/q/l/^E/^Y)?
括号中的每个字符都是一个可能的选择，如下所示：
按键行为
y执行替换操作
n跳过这个匹配的实例
a对这个及随后所有匹配的字符串执行替换操作。
q or esc退出替换操作。
l执行这次替换并退出。l是“last”的简写。
Ctrl-e, Ctrl-y分别是向下滚动和向上滚动。用于查看建议替换的上下文。
表 13-5:替换确认按键
如果你输入 y，则执行这个替换，输入 n则会导致 vi跳过这个实例，而移到下一个匹配项
上。
13.8编辑多个文件
同时能够编辑多个文件是很有用的。你可能需要更改多个文件或者从一个文件复制内容到另一
个文件。通过 vi，我们可以打开多个文件来编辑，只要在命令行中指定要编辑的文件名。
vifile1file2file3...
我们先退出已经存在的 vi会话，然后创建一个新文件来编辑。输入:wq来退出 vi并且保存
了所做的修改。下一步，我们将在家目录下创建一个额外的用来玩耍的文件。通过获取从 ls命
令的输出，来创建这个文件。
[me@linuxbox~]$ls-l/usr/bin>ls-output.txt
用 vi来编辑我们的原文件和新创建的文件：
159
[me@linuxbox~]$vifoo.txtls-output.txt
vi启动，我们会看到第一个文件显示出来：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Line5
13.8.1文件之间切换
从这个文件切换下一个文件，使用这个 ex命令：
:n
回到先前的文件使用：
:N
当我们从一个文件移到另一个文件时，如果当前文件没有保存修改，vi会阻止我们切换文
件，这是 vi强制执行的政策。在命令之后添加感叹号，可以强迫 vi放弃修改而转换文件。
另外，上面所描述的切换方法，vim（和一些版本的 vi）也提供了一些 ex命令，这些命令
使多个文件更容易管理。我们可以查看正在编辑的文件列表，使用:buffers命令。运行这个命
令后，屏幕顶部就会显示出一个文件列表：
:buffers
1#"foo.txt"line1
2%a"ls-output.txt"line0
PressENTERortypecommandtocontinue
160
要切换到另一个缓冲区（文件），输入:buffer,紧跟着你想要编辑的缓冲器编号。比如，要从
包含文件 foo.txt的 1号缓冲区切换到包含文件 ls-output.txt的 2号缓冲区，我们会这样输入：
:buffer2
我们的屏幕现在会显示第二个文件。
13.8.2打开另一个文件并编辑
在我们的当前的编辑会话里也能添加别的文件。ex命令:e (编辑 (edit)的简写)紧跟要打开的
文件名将会打开另外一个文件。让我们结束当前的会话回到命令行。
重新启动 vi并只打开一个文件
[me@linuxbox~]$vifoo.txt
要加入我们的第二个文件，输入：
:els-output.txt
它应该显示在屏幕上。我们可以这样来确认第一个文件仍然存在：
:buffers
1#"foo.txt"line1
2%a"ls-output.txt"line0
PressENTERortypecommandtocontinue
注意：当文件由：e命令加载，你将无法用:n或:N命令来切换文件。这时要使用:buffer命
令加缓冲区号码，来切换文件。
13.8.3跨文件复制黏贴
当我们编辑多个文件时，经常地要复制文件的一部分到另一个正在编辑的文件。使用之前我们
学到的拉（yank）和粘贴命令，这很容易完成。说明如下。以打开的两个文件为例，首先转换
到缓冲区 1（foo.txt），输入：
161
:buffer1
我们应该得到如下输出：
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Line5
下一步，把光标移到第一行，并且输入 yy来复制这一行。
转换到第二个缓冲区，输入：
:buffer2
现在屏幕会包含一些文件列表（这里只列出了一部分）：
total343700
-rwxr-xr-x1rootroot313162007-12-0508:58[
....
移动光标到第一行，输入 p命令把我们从前面文件中复制的一行粘贴到这个文件中：
total343700
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
-rwxr-xr-x1rootroot313162007-12-0508:58[
....
13.8.4插入整个文件到另一个文件
我们也可以把整个文件插入到我们正在编辑的文件中。看一下实际操作，结束 vi会话，重新启
动一个只打开一个文件的 vi会话：
162
[me@linuxbox~]$vils-output.txt
再一次看到我们的文件列表：
total343700
-rwxr-xr-x1rootroot313162007-12-0508:58[
移动光标到第三行，然后输入以下 ex命令：
:rfoo.txt
这个:r命令（是 “read”的简称）把指定的文件插入到光标位置之前。现在屏幕应该看起来
像这样：
total343700
-rwxr-xr-x1rootroot313162007-12-0508:58[
....
Thequickbrownfoxjumpedoverthelazydog.Itwascool.
Line2
Line3
Line4
Line5
-rwxr-xr-x1rootroot1112762008-01-3113:36a2p
....
13.9保存工作
像 vi中的其它操作一样，有几种不同的方法来保存我们所修改的文件。我们已经研究了:w这
个 ex命令，但还有几种方法，可能我们也觉得有帮助。
在命令模式下，输入 ZZ就会保存并退出当前文件。同样地，ex命令:wq把:w和:q命令结
合到一起，来完成保存和退出任务。
163
这个:w命令也可以指定可选的文件名。这个的作用就如 “Save As…”。例如，如果我们正在
编辑 foo.txt文件，想要保存一个副本，叫做 foo1.txt，那么我们可以执行以下命令：
:wfoo1.txt
注意：当上面的命令以一个新名字保存文件时，它并没有更改你正在编辑的文件的名字。如
果你继续编辑，你还是在编辑文件 foo.txt，而不是 foo1.txt。
13.10拓展阅读
即使把这章所学的内容都加起来，我们也只是学了 vi和 vim的一点儿皮毛而已。这里有一些
在线资料，可以帮助你进一步掌握 vi。
•学习 vi编辑器－一本来自于 Wikipedia的 Wikibook，是一本关于 vi的简要指南，并介
绍了几个类似 vi的程序，其中包括 vim。它可以在以下链接中得到：
http://en.wikibooks.org/wiki/Vi
• The Vim Book－ vim项目包括一本书，570页，（几乎）包含了 vim的全部特性。你能
在下面链接中找到它：
• Wikipedia上关于 Bill Joy（vi创始人）的文章。
http://en.wikipedia.org/wiki/Bill_Joy
• Wikipedia上关于 Bram Moolenaar（vim作者）的文章：
http://en.wikipedia.org/wiki/Bram_Moolenaar
• Wikipedia上关于开头作者提到的 Chopsticks钢琴曲的介绍：
• Youku上视频一段 Chopsticks”(The Celebrated Chop Waltz) on Piano：
164
14|自定制shell提示符
在这一章中，我们将会看一下表面上看来很琐碎的细节－ shell提示符。但这会揭示一些 shell
和终端仿真器的内部工作方式。
和 Linux内的许多程序一样，shell提示符是可高度配置的，虽然我们把它相当多地看作是
理所当然的，但是我们一旦学会了怎样控制它，shell提示符是一个相当有用的工具。
14.1解剖一个提示符
我们默认的提示符看起来像这样：
[me@linuxbox~]$
注意它包含我们的用户名，主机名和当前工作目录，但是它又是怎样得到这些东西的呢？结
果证明非常简单。提示符是由一个环境变量定义的，叫做 PS1（是“prompt string one”的简
写）。我们可以通过 echo命令来查看 PS1的内容。
[me@linuxbox~]$echo$PS1
[\u@\h\W]\$
注意：如果你 shell提示符的内容和上例不是一模一样，也不必担心。每个 Linux发行版定
义的提示符稍微有点不同，其中一些相当异于寻常。
165
从输出结果中，我们看到那个 PS1环境变量包含一些这样的字符，比方说中括号，@符号，
和美元符号，但是剩余部分就是个谜。我们中一些机敏的人会把这些看作是由反斜杠转义的特
殊字符，就像我们在第八章中看到的一样。这里是一部分字符列表，在提示符中 shell会特殊
对待这些字符：
序列显示值
\a以 ASCII格式编码的铃声.当遇到这个转义序列时，计算机
会发出嗡嗡的响声。
\d以日，月，天格式来表示当前日期。例如，“Mon May 26.”
\h本地机的主机名，但不带末尾的域名。
\H完整的主机名。
\j运行在当前 shell会话中的工作数。
\l当前终端设备名。
\n一个换行符。
\r一个回车符。
\s shell程序名。
\t以 24小时制，hours:minutes:seconds的格式表示当前时间.
\T以 12小时制表示当前时间。
\@以 12小时制，AM/PM格式来表示当前时间。
\A以 24小时制，hours:minutes格式表示当前时间。
\u当前用户名。
\v shell程序的版本号。
\V Version and release numbers of the shell.
\w当前工作目录名。
\W当前工作目录名的最后部分。
\!当前命令的历史号。
\#当前 shell会话中的命令数。
\$这会显示一个”$”字符，除非你拥有超级用户权限。在那种
情况下，它会显示一个”#”字符。
\[标志着一系列一个或多个非打印字符的开始。这被用来嵌
入非打印的控制字符，这些字符以某种方式来操作终端仿真
器，比方说移动光标或者是更改文本颜色。
\]标志着非打印字符序列结束。
166
表 14-1: Shell提示符中用到的转义字符
14.2试试一些可替代的提示符设计
参照这个特殊字符列表，我们可以更改提示符来看一下效果。首先，我们把原来提示符字符串
的内容备份一下，以备之后恢复原貌。为了完成备份，我们把已有的字符串复制到另一个 shell
变量中，这个变量是我们自己创造的。
[me@linuxbox~]$ps1_old="$PS1"
我们新创建了一个叫做 ps1_old的变量，并把变量 PS1的值赋 ps1_old。通过 echo命令可
以证明我们的确复制了 PS1的值。
[me@linuxbox~]$echo$ps1_old
[\u@\h\W]\$
在终端会话中，我们能在任一时间复原提示符，只要简单地反向操作就可以了。
[me@linuxbox~]$PS1="$ps1_old"
现在，我们准备开始，让我们看看如果有一个空的字符串会发生什么：
[me@linuxbox~]$PS1=
如果我们没有给提示字符串赋值，那么我们什么也得不到。根本没有提示字符串！提示符仍
然在那里，但是什么也不显示，正如我们所要求的那样。我们将用一个最小的提示符来代替它：
PS1="\$"
167
这样要好一些。至少能看到我们在做什么。注意双引号中末尾的空格。当提示符显示的时
候，这个空格把美元符号和光标分离开。
在提示符中添加一个响铃：
$PS1="\a\$"
现在每次提示符显示的时候，我们应该能听到嗡嗡声。这会变得很烦人，但是它可能会很有
用，特别是当一个需要运行很长时间的命令执行完后，我们要得到通知。
下一步，让我们试着创建一个信息丰富的提示符，包含主机名和当天时间的信息。
$PS1="\A\h\$"
17:33linuxbox$
试试其他上表中列出的转义序列，看看你能否想出精彩的新提示符。
14.3添加颜色
大多数终端仿真器程序支持一定的非打印字符序列来控制，比方说字符属性（像颜色，黑体和
可怕的闪烁）和光标位置。我们会更深入地讨论光标位置，但首先我们要看一下字体颜色。
混乱的终端时代
回溯到终端连接到远端计算机的时代，有许多竞争的终端品牌，它们各自工作
不同。它们有着不同的键盘，以不同的方式来解释控制信息。Unix和类 Unix的
系统有两个相当复杂的子系统来处理终端控制领域的混乱局面（称为 termcap和
terminfo）。如果你查看一下终端仿真器最底层的属性设置，可能会找到一个关于终
端仿真器类型的设置。
为了努力使所有的终端都讲某种通用语言，美国国家标准委员会（ANSI）制定
了一套标准的字符序列集合来控制视频终端。原先 DOS用户会记得 ANSI.SYS文
件，这是一个用来使这些编码解释生效的文件。
字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的 ANSI转义编码来控
制的。这个控制编码不会“打印”到屏幕上，而是被终端解释为一个指令。正如我们在上表看
168
到的字符序列，这个 [和]序列被用来封装这些非打印字符。一个 ANSI转义编码以一个八进
制 033（这个编码是由退出按键产生的）开头，其后跟着一个可选的字符属性，在之后是一个
指令。例如，把文本颜色设为正常（attribute = 0），黑色文本的编码如下：
\033[0;30m
这里是一个可用的文本颜色列表。注意这些颜色被分为两组，由应用程序粗体字符属性（1）
分化开来，这个属性可以描绘出“浅”色文本。
序列文本颜色序列文本颜色
\033[0;30m黑色 \033[1;30m深灰色
\033[0;31m红色 \033[1;31m浅红色
\033[0;32m绿色 \033[1;32m浅绿色
\033[0;33m棕色 \033[1;33m黄色
\033[0;34m蓝色 \033[1;34m浅蓝色
\033[0;35m粉红 \033[1;35m浅粉色
\033[0;36m青色 \033[1;36m浅青色
\033[0;37m浅灰色 \033[1;37m白色
表 14-2:用转义序列来设置文本颜色
让我们试着制作一个红色提示符。我们将在开头加入转义编码：
<me@linuxbox~>$PS1='\[\033[0;31m\]<\u@\h\W>\$'
<me@linuxbox~>$
我们的提示符生效了，但是注意我们在提示符之后输入的文本也是红色的。为了修改这个
问题，我们将添加另一个转义编码到这个提示符的末尾来告诉终端仿真器恢复到原来的颜色。
<me@linuxbox~>$PS1='\[\033[0;31m\]<\u@\h\W>\$\[\033[0m\]'
<me@linuxbox~>$
这看起来要好些！
169
也有可能要设置文本的背景颜色，使用下面列出的转义编码。这个背景颜色不支持黑体属
性。
\033[0;40m蓝色 \033[1;44m黑色
\033[0;41m红色 \033[1;45m紫色
\033[0;42m绿色 \033[1;46m青色
\033[0;43m棕色 \033[1;47m浅灰色
表 14-3:用转义序列来设置背景颜色
我们可以创建一个带有红色背景的提示符，只是对第一个转义编码做个简单的修改。
<me@linuxbox~>$PS1='\[\033[0;41m\]<\u@\h\W>\$\[\033[0m\]'
<me@linuxbox~>$
试试这些颜色编码，看看你能定制出怎样的提示符！
注意：除了正常的 (0)和黑体 (1)字符属性之外，文本也可以具有下划线 (4)，闪烁 (5)，和
反向 (7)属性。为了拥有好品味，然而，许多终端仿真器拒绝使用这个闪烁属性。
14.4移动光标
转义编码也可以用来定位光标。这些编码被普遍地用来，每次当提示符出现的时候，会在屏幕
的不同位置比如说上面一个角落，显示一个时钟或者其它一些信息。这里是一系列用来定位光
标的转义编码：
转义编码行动
\033[l;cH把光标移到第 l行，第 c列。
\033[nA把光标向上移动 n行。
\033[nB把光标向下移动 n行。
\033[nC把光标向前移动 n个字符。
\033[nD把光标向后移动 n个字符。
170
\033[2J清空屏幕，把光标移到左上角（第零行，第零列）。
\033[K清空从光标位置到当前行末的内容。
\033[s存储当前光标位置。
\033[u唤醒之前存储的光标位置。
表 14-4:光标移动转义序列
使用上面的编码，我们将构建一个提示符，每次当这个提示符出现的时候，会在屏幕的上方
画出一个包含时钟（由黄色文本渲染）的红色长条。构建好的提示符的编码就是这串看起来令
人敬畏的字符串：
PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]
<\u@\h\W>\$'
让我们分别看一下这个字符串的每一部分所表示的意思：
序列行动
\[开始一个非打印字符序列。其真正的目的是为了让 bash能
够正确地计算提示符的大小。如果没有这个转义字符的话，
命令行编辑功能会弄错光标的位置。
\033[s存储光标位置。这个用来使光标能回到原来提示符的位置，
当长条和时钟显示到屏幕上方之后。当心一些终端仿真器
不推崇这个编码。
\033[0;0H把光标移到屏幕左上角，也就是第零行，第零列的位置。
\033[0;41m把背景设置为红色。
\033[K清空从当前光标位置到行末的内容。因为现在背景颜色是
红色，则被清空行背景成为红色，以此来创建长条。注意虽
然一直清空到行末，但是不改变光标位置，它仍然在屏幕左
上角。
\033[1;33m把文本颜色设为黄色。
\t显示当前时间。虽然这是一个可“打印”的元素，但我们仍
把它包含在提示符的非打印部分，因为我们不想 bash在计
算可见提示符的真正大小时包括这个时钟在内。
171
\033[0m关闭颜色设置。这对文本和背景都起作用。
\033[u恢复到之前保存过的光标位置处。
\]结束非打印字符序列。
<\u@\h \W>\$提示符字符串。
14.5保存提示符
显然地，我们不想总是敲入那个怪物，所以我们将要把这个提示符存储在某个地方。通过把它
添加到我们的.bashrc文件，可以使这个提示符永久存在。为了达到目的，把下面这两行添加
到.bashrc文件中。
PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h\W>\$'
exportPS1
14.6总结归纳
不管你信不信，如果加上我们在这里没有论及的 shell函数和脚本，还有许多事情可以由提示
符来完成。但这是一个好的开始。并不是每个人都会花心思来更改提示符，因为通常默认的提
示符就很让人满意。但是对于我们这些喜欢思考的人们来说，shell却提供了许多制造琐碎乐趣
的机会。
14.7拓展阅读
• The Bash Prompt HOWTO来自于 Linux文档工程，对 shell提示符的用途进行了相当
完备的论述。可在以下链接中得到：
http://tldp.org/HOWTO/Bash-Prompt-HOWTO/
• Wikipedia上有一篇关于 ANSI Escape Codes的好文章：
http://en.wikipedia.org/wiki/ANSI_escape_code
172
15|软件包管理
如果我们花些时间在 Linux社区里，我们会看到很多像 Linux发行版中哪一个是“最佳”之类
的观点。这些讨论通常非常可笑，集中在一些像桌面背景的漂亮程度（一些人不使用 Ubuntu，
只是因为 Ubuntu默认主题颜色是棕色的！）和其它的琐碎东西上。
Linux发行版本质量最重要的决定因素是软件包管理系统和其支持社区的持久性。随着我
们花更多的时间在 Linux上，我们会发现它的变化是非常快的。大多数一线 Linux发行版每隔
六个月发布一个新版本，并且许多独立的程序每天都会更新。为了能和这些如暴风雪一般多的
软件保持联系，我们需要一些好工具来进行软件包管理。
软件包管理是指系统中一种安装和维护软件的方法。今天，通过从 Linux发行版中安装的
软件包，已能满足许多人所有的软件需求。这不同于早期的 Linux，人们需要下载和编译源码
来安装软件。编译源码没有任何问题，事实上，拥有对源码的访问权限是 Linux的伟大奇迹。
它赋予我们（其它每个人）检测和提高系统性能的能力。只是若有一个预先编译好的软件包处
理起来要相对容易快速些。这章中，我们将查看一些用于包管理的命令行工具。虽然所有主流
Linux发行版都提供了强大且精致的图形管理程序来维护系统，但是学习命令行程序也非常重
要。因为它们可以完成许多让图形化管理程序处理起来困难（或者不可能）的任务。
15.1打包系统
不同的 Linux发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术
阵营：Debian的 “.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo，Slackware，
和 Foresight，但大多数会使用这两个基本系统中的一个。
包管理系统发行版 (部分列表)
Debian Style (.deb) Debian, Ubuntu, Xandros, Linspire
Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux,
OpenSUSE, Mandriva, PCLinuxOS
表 15-1:主要的包管理系统家族
173
15.2软件包管理系统是怎样工作的
在商业化软件中，获取软件的最新版本通常需要买一张安装媒介，比方说 “安装盘”，然后运行
一个 “安装向导”，来在系统中安装新的应用程序。
Linux不是这样。Linux系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由
发行商以包文件的形式提供，剩下的则以源码形式存在，可以手动安装。在后面章节里，我们
将会谈谈怎样通过编译源码来安装软件。
15.3包文件
在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软
件包可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包
括关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安
装后脚本，这些脚本用来在软件安装之前和之后执行配置任务。
软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件
维护者从上游提供商（程序作者）那里得到软件源码，然后编译源码，创建软件包元数据以及
所需要的安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软
件与 Linux发行版其它部分的融合性。
15.4资源库
虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和
感兴趣的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资
源库可能包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。
因软件开发生命周期不同阶段的需要，一个系统发行版可能维护着几个不同的资源库。例
如，通常会有一个 “测试”资源库，其中包含刚刚建立的软件包，它们想要勇敢的用户来使用，
在这些软件包正式发布之前，让用户查找错误。系统发行版经常会有一个 “开发”资源库，这
个资源库中保存着注定要包含到下一个主要版本中的半成品软件包。
一个系统发行版可能也会拥有相关第三方的资源库。这些资源库需要支持一些因法律原因，
比如说专利或者是 DRM反规避问题，而不能被包含到发行版中的软件。可能最著名的案例就
是对加密 DVD的播放支持，在美国这是不合法的。第三方资源库在一些软件专利和反规避法
案不生效的国家中设立并分发资源。这些资源库通常完全地独立于它们所支持的资源库，要想
使用它们，你必须了解它们，手动地把它们包含到软件包管理系统的配置文件中。
174
15.5依赖性
程序很少独立工作；他们需要依靠其他程序的组件来完成他们的工作。程序所共有的活动，如
输入/输出，就是由一个被多个程序调用的子例程处理的。这些子例程存储在动态链接库中。动
态链接库为多个程序提供基本服务。如果一个软件包需要一些共享的资源，如一个动态链接库，
它就被称作有一个依赖。现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软
件包时，其所有的依赖也被安装。
15.6上层和底层软件包工具
软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软
件包文件，和上层工具，完成元数据搜索和依赖解析。在这一章中，我们将看一下由 Debian风
格的系统（比如说 Ubuntu，还有许多其它系统）提供的工具，还有那些由 Red Hat产品使用
的工具。虽然所有基于 Red Hat风格的发行版都依赖于相同的底层程序（rpm）,但是它们却
使用不同的上层工具。在我们的讨论中，我们将研究 Fedora, Red Hat企业版，和 CentOs所
使用的 yum。其它 Red Hat风格的发行版提供了带有类似 yum的其他上层工具。
发行版底层工具上层工具
Debian-Style dpkg apt-get, aptitude
Fedora, Red Hat Enterprise Linux, CentOS rpm yum
表 15-2:包管理工具
15.7常见软件包管理任务
通过命令行软件包管理工具可以完成许多操作。我们将会看一下最常用的工具。注意底
层工具也支持软件包文件的创建，这个话题超出了本书叙述的范围。在以下的讨论中，
“package_name”这个术语是指软件包实际名称，而不是指 “package_file”，它是包含在软件包
中的文件名。
15.8查找资源库中的软件包
使用上层工具来搜索资源库元数据，可以根据软件包的名字和说明来定位它。
风格命令
175
Debian apt-get update; apt-cache search search_string
Red Hat yum search search_string
表 15-3:软件包查找工具
例如：搜索一个 yum资源库来查找 emacs文本编辑器，使用以下命令：
yumsearchemacs
15.9从资源库中安装一个软件包
上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。
风格命令
Debian apt-get update; apt-get install package_name
Red Hat yum install package_name
表 15-4:软件包安装命令
例如：从一个 apt资源库来安装 emacs文本编辑器：
apt-getupdate;apt-getinstallemacs
15.10通过软件包文件来安装软件
如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依
赖解析）安装它。
风格命令
Debian dpkg --install package_file
Red Hat rpm -i package_file
表 15-5:底层软件包安装命令
176
例如：如果已经从一个并非资源库的网站下载了软件包文件 emacs-22.1-7.fc7-i386.rpm，则
可以通过这种方法来安装它：
rpm-iemacs-22.1-7.fc7-i386.rpm
注意：因为这项技术使用底层的 rpm程序来执行安装任务，所以没有运行依赖解析。如果
rpm程序发现缺少了一个依赖，则会报错并退出。
15.11卸载软件
可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。
风格命令
Debian apt-get remove package_name
Red Hat yum erase package_name
表 15-6:软件包删除命令
例如：从 Debian风格的系统中卸载 emacs软件包：
apt-getremoveemacs
15.12经过资源库来更新软件包
最常见的软件包管理任务是保持系统中的软件包都是最新的。上层工具仅需一步就能完成这个
至关重要的任务。
风格命令
Debian apt-get update; apt-get upgrade
Red Hat yum update
177
表 15-7:软件包更新命令
例如：更新安装在 Debian风格系统中的软件包：
apt-getupdate;apt-getupgrade
15.13经过软件包文件来升级软件
如果已经从一个非资源库网站下载了一个软件包的最新版本，可以安装这个版本，用它来替代
先前的版本：
风格命令
Debian dpkg --install package_file
Red Hat rpm -U package_file
表 15-8:底层软件包升级命令
例如：把 Red Hat系统中所安装的 emacs的版本更新到软件包文件 emacs-22.1-7.fc7-
i386.rpmz所包含的 emacs版本。
rpm-Uemacs-22.1-7.fc7-i386.rpm
注意：rpm程序安装一个软件包和升级一个软件包所用的选项是不同的，而 dpkg程序所用
的选项是相同的。
15.14列出所安装的软件包
下表中的命令可以用来显示安装到系统中的所有软件包列表：
178
风格命令
Debian dpkg --list
Red Hat rpm -qa
表 15-9:列出所安装的软件包命令
15.15确定是否安装了一个软件包
这些底端工具可以用来显示是否安装了一个指定的软件包：
风格命令
Debian dpkg --status package_name
Red Hat rpm -q package_name
表 15-10:软件包状态命令
例如：确定是否 Debian风格的系统中安装了这个 emacs软件包：
dpkg--statusemacs
15.16显示所安装软件包的信息
如果知道了所安装软件包的名字，使用以下命令可以显示这个软件包的说明信息：
风格命令
Debian apt-cache show package_name
Red Hat yum info package_name
表 15-11:查看软件包信息命令
例如：查看 Debian风格的系统中 emacs软件包的说明信息：
apt-cacheshowemacs
179
15.17查找安装了某个文件的软件包
确定哪个软件包对所安装的某个特殊文件负责，使用下表中的命令：
风格命令
Debian dpkg --search file_name
Red Hat rpm -qf file_name
表 15-12:包文件识别命令
例如：在 Red Hat系统中，查看哪个软件包安装了/usr/bin/vim这个文件
rpm-qf/usr/bin/vim
15.18总结归纳
在随后的章节里面，我们将探讨许多不同的程序，这些程序涵盖了广泛的应用程序领域。虽然
大多数程序一般是默认安装的，但是若所需程序没有安装在系统中，那么我们可能需要安装额
外的软件包。通过我们新学到的（和了解的）软件包管理知识，我们应该能够安装和管理所需
程序。
Linux软件安装谣言
从其它平台迁移过来的用户有时会成为谣言的受害者，说是在 Linux系统中，安
装软件有些困难，并且不同系统发行版所使用的各种各样的打包方案是一个障碍。
唉，它是一个障碍，但只是针对于那些希望把他们的秘密软件只以二进制版本发行
的专有软件供应商。
Linux软件生态系统是基于开放源代码理念。如果一个程序开发人员发布了一款
产品的源码，那么与系统发行版相关联的开发人员可能就会把这款产品打包，并把
它包含在他们的资源库中。这种方法保证了这款产品能很好地与系统发行版整合在
一起，同时为用户“一站式采购”软件提供了方便，从而用户不必去搜索每个产品
的网站。
设备驱动差不多也以同样的方式来处理，但它们不是系统发行版资源库中单独的
项目，它们本身是 Linux系统内核的一部分。一般来说，在 Linux当中没有一个类
180
似于“驱动盘”的东西。Linux内核要么支持一个设备，要不就不支持。Linux内核
支持很多设备，事实上，Linux支持的设备数目多于 Windows所支持的。当然，万
一你需要的特定设备不被 Linux支持，也于事无补。当那种情况发生时，你需要查
找一下原因。缺少驱动程序支持通常是由以下三种情况之一导致：
1.设备太新。因为许多硬件供应商没有积极地支持 Linux的发展，那么编写内核
驱动代码的任务就由一些 Linux社区来承担，而这需要花费时间。
2.设备太奇异。不是所有的发行版都包含每个可能的设备驱动。每个发行版会建
立它们自己的内核，因为内核是可以配置的（这使得从手表到主机的每台设备
上运行 Linux成为可能），这样它们可能会忽略某个特殊设备。通过定位和下
载驱动程序的源码，可能需要你自己（是的，由你）来编译和安装驱动。这个
过程不是很难，而是需要参与的。我们将在随后的章节里来讨论编译软件。
3.硬件供应商隐藏信息。他们既不发布应用于 Linux系统的驱动程序代码，也不
发布技术文档来让某人创建它。这意味着硬件供应商试图保密此设备的程序接
口。因为我们不想在计算机中使用保密的设备，所以我建议删除这令人厌恶的
硬件，把它和其它无用的东西都扔到垃圾桶里。
15.19拓展阅读
花些时间来了解你所用发行版中的软件包管理系统。每个发行版都提供了关于自带软件包管理
工具的文档。另外，这里有一些更普遍的资源：
• Debian GNU/Linux FAQ关于软件包管理一章对软件包管理进行了概述：
http://www.debian.org/doc/FAQ/ch-pkgtools.en.html
• RPM工程的主页：
http://www.rpm.org
•杜克大学 YUM工程的主页：
http://linux.duke.edu/projects/yum/
•了解一点儿背景知识，Wikipedia上有一篇关于 metadata的文章：
http://en.wikipedia.org/wiki/Metadata
181
16|存储媒介
在前面章节中，我们已经在文件级别上见识了数据的操作。在这章里，我们将从设备级别来考
虑数据。Linux有着令人惊奇的能力来处理存储设备，不管是物理设备，比如说硬盘，还是网
络设备，或者是虚拟存储设备，像 RAID（独立磁盘冗余阵列)和 LVM（逻辑卷管理器）。
然而，这不是一本关于系统管理的书籍，我们不会试图深入地覆盖整个主题。我们将努力做
的就是介绍一些概念和用来管理存储设备的重要命令。
为了做这一章的练习，我们将会使用 USB闪存，CD-RW光盘（如果系统配备了 CD-ROM
烧录器）和一张软盘（如果系统有这样配备的话）。
我们将看看以下命令：
• mount–挂载一个文件系统
• umount–卸载一个文件系统
• fsck–检查和修复一个文件系统
• fdisk–分区表控制器
• mkfs–创建文件系统
• fdformat–格式化一张软盘
• dd—把面向块的数据直接写入设备
• genisoimage (mkisofs)–创建一个 ISO 9660的映像文件
• wodim (cdrecord)–把数据写入光存储媒介
• md5sum–计算 MD5检验码
182
16.1挂载和卸载存储设备
Linux桌面系统的最新进展已经使存储设备管理对于桌面用户来说极其容易。大多数情况下，
我们只要把设备连接到系统中，它就能工作。在过去（比如说，2004年），这个工作必须手动
完成。在非桌面系统中（例如，服务器中），这仍然是一个主要地手动过程，因为服务器经常有
极端的存储需求和复杂的配置要求。
管理存储设备的第一步是把设备连接到文件系统树中。这个叫做 “挂载”的过程允许设备连
接到操作系统中。回想一下第三章，类 Unix的操作系统，比如 Linux在单一文件系统树中维
护连接在各个节点的各种设备。这与其它操作系统形成对照，比如说 MS-DOS和 Windows系
统中，每个设备（例如 C:\，D:\，等）保持着单独的文件系统树。
有一个叫做/etc/fstab的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。下
面是来自于 Fedora 7系统的/etc/fstab文件实例：
LABEL=/12/ext3defaults11
LABEL=/home/homeext3defaults12
LABEL=/boot/bootext3defaults12
tmpfs/dev/shmtmpfsdefaults00
devpts/dev/ptsdevptsgid=5,mode=62000
sysfs/syssysfsdefaults00
proc/procprocdefaults00
LABEL=SWAP-sda3/swapswapdefaults00
在这个实例中所列出的大多数文件系统是虚拟的，并不适用于我们的讨论。就我们的目的
而言，前三个是我们感兴趣的：
LABEL=/12/ext3defaults11
LABEL=/home/homeext3defaults12
LABEL=/boot/bootext3defaults12
这些是硬盘分区。每行由六个字段组成，如下所示：
字段内容说明
183
1设备名传统上，这个字段包含与物理设备相关联的设备文件
的实际名字，比如说/dev/hda1（第一个 IDE通道上
第一个主设备分区）。然而今天的计算机，有很多热插
拔设备（像 USB驱动设备），许多现代的 Linux发行
版用一个文本标签和设备相关联。当这个设备连接到
系统中时，这个标签（当储存媒介格式化时，这个标
签会被添加到存储媒介中）会被操作系统读取。那样
的话，不管赋给实际物理设备哪个设备文件，这个设
备仍然能被系统正确地识别。
2挂载点设备所连接到的文件系统树的目录。
3文件系统类型 Linux允许挂载许多文件系统类型。大多数本地的
Linux文件系统是 ext3，但是也支持很多其它的，
比方说 FAT16 (msdos), FAT32 (vfat)，NTFS (ntfs)，
CD-ROM (iso9660)，等等。
4选项文件系统可以通过各种各样的选项来挂载。有可能，
例如，挂载只读的文件系统，或者挂载阻止执行任何
程序的文件系统（一个有用的安全特性，避免删除媒
介。）
5频率一位数字，指定是否和在什么时间用 dump命令来备
份一个文件系统。
6次序一位数字，指定 fsck命令按照什么次序来检查文件系
统。
表 16-1: /etc/fstab字段
16.2查看挂载的文件系统列表
这个 mount命令被用来挂载文件系统。执行这个不带参数的命令，将会显示一系列当前挂载的
文件系统：
[me@linuxbox~]$mount
/dev/sda2on/typeext3(rw)
procon/proctypeproc(rw)
184
sysfson/systypesysfs(rw)
devptson/dev/ptstypedevpts(rw,gid=5,mode=620)
/dev/sda5on/hometypeext3(rw)
/dev/sda1on/boottypeext3(rw)
tmpfson/dev/shmtypetmpfs(rw)
noneon/proc/sys/fs/binfmt_misctypebinfmt_misc(rw)
sunrpcon/var/lib/nfs/rpc_pipefstyperpc_pipefs(rw)
fusectlon/sys/fs/fuse/connectionstypefusectl(rw)
/dev/sdd1on/media/disktypevfat(rw,nosuid,nodev,noatime,
uhelper=hal,uid=500,utf8,shortname=lower)
twin4:/musicboxon/misc/musicboxtypenfs4(rw,addr=192.168.1.4)
这个列表的格式是：设备 on挂载点 type文件系统类型（选项）。例如，第一行所示设备/
dev/sda2作为根文件系统被挂载，文件系统类型是 ext3，并且可读可写（这个“rw”选项）。
在这个列表的底部有两个有趣的条目。倒数第二行显示了在读卡器中的一张 2G的 SD内存卡，
挂载到了/media/disk上。最后一行是一个网络设备，挂载到了/misc/musicbox上。
第一次实验，我们将使用一张 CD-ROM。首先，在插入 CD-ROM之前，我们将看一下系
统：
[me@linuxbox~]$mount
/dev/mapper/VolGroup00-LogVol00on/typeext3(rw)
procon/proctypeproc(rw)
sysfson/systypesysfs(rw)
devptson/dev/ptstypedevpts(rw,gid=5,mode=620)
/dev/hda1on/boottypeext3(rw)
tmpfson/dev/shmtypetmpfs(rw)
noneon/proc/sys/fs/binfmt_misctypebinfmt_misc(rw)
sunrpcon/var/lib/nfs/rpc_pipefstyperpc_pipefs(rw)
这个列表来自于 CentOS 5系统，使用 LVM（逻辑卷管理器）来创建它的根文件系统。正
如许多现在的 Linux发行版一样，这个系统试图自动挂载插入的 CD-ROM。当我们插入光盘
后，我们看看下面的输出：
[me@linuxbox~]$mount
185
/dev/mapper/VolGroup00-LogVol00on/typeext3(rw)
procon/proctypeproc(rw)
sysfson/systypesysfs(rw)
devptson/dev/ptstypedevpts(rw,gid=5,mode=620)
/dev/hda1on/boottypeext3(rw)
tmpfson/dev/shmtypetmpfs(rw)
noneon/proc/sys/fs/binfmt_misctypebinfmt_misc(rw)
sunrpcon/var/lib/nfs/rpc_pipefstyperpc_pipefs(rw)
/dev/hdcon/media/live-1.0.10-8typeiso9660(ro,noexec,nosuid,
nodev,uid=500)
当我们插入光盘后，除了额外的一行之外，我们看到和原来一样的列表。在列表的末尾，我
们看到 CD-ROM已经挂载到了/media/live-1.0.10-8上，它的文件类型是 iso9660（CD-ROM）。
就我们的实验目的而言，我们对这个设备的名字感兴趣。当你自己进行这个实验时，这个设备
名字是最有可能不同的。
警告：在随后的实例中，至关重要的是你要密切注意用在你系统中的实际设备名，并且不要
使用此文本中使用的名字！
还要注意音频 CD和 CD-ROM不一样。音频 CD不包含文件系统，这样在通常意义上，它
就不能被挂载了。
现在我们拥有 CD-ROM光盘的设备名字，让我们卸载这张光盘，并把它重新挂载到文件
系统树的另一个位置。我们需要超级用户身份（使用系统相应的命令）来进行操作，并且用
umount（注意这个命令的拼写）来卸载光盘：
[me@linuxbox~]$su-
Password:
[root@linuxbox~]#umount/dev/hdc
下一步是创建一个新的光盘挂载点。简单地说，一个挂载点就是文件系统树中的一个目录。
它没有什么特殊的。它甚至不必是一个空目录，如果你把设备挂载到了一个非空目录上，你将
不能看到这个目录中原来的内容，直到你卸载这个设备。就我们的目的而言，我们将创建一个
新目录：
[root@linuxbox~]#mkdir/mnt/cdrom
186
最后，我们把这个 CD-ROW挂载到一个新的挂载点上。这个-t选项用来指定文件系统类
型：
[root@linuxbox~]#mount-tiso9660/dev/hdc/mnt/cdrom
之后，我们可以通过这个新挂载点来查看 CD-ROW的内容：
[root@linuxbox~]#cd/mnt/cdrom
[root@linuxboxcdrom]#ls
注意当我们试图卸载这个 CD-ROW时，发生了什么事情。
[root@linuxboxcdrom]#umount/dev/hdc
umount:/mnt/cdrom:deviceisbusy
这是怎么回事呢？原因是我们不能卸载一个设备，如果某个用户或进程正在使用这个设备
的话。在这种情况下，我们把工作目录更改到了 CD-ROW的挂载点，这个挂载点导致设备忙
碌。我们可以很容易地修复这个问题通过把工作目录改到其它目录而不是这个挂载点。
[root@linuxboxcdrom]#cd
[root@linuxbox~]#umount/dev/hdc
现在这个设备成功卸载了。
为什么卸载重要
如果你看一下 free命令的输出结果，这个命令用来显示关于内存使用情况的统
计信息，你会看到一个统计值叫做”buffers“。计算机系统旨在尽可能快地运行。系
统运行速度的一个阻碍是缓慢的设备。打印机是一个很好的例子。即使最快速的打
印机相比于计算机标准也极其地缓慢。一台计算机确实会运行得非常慢，如果它要
停下来等待一台打印机打印完一页。在早期的个人电脑时代（多任务之前），这真
187
是个问题。如果你正在编辑电子表格或者是文本文档，每次你要打印文件时，计算
机都会停下来而且变得不能使用。计算机能以打印机可接受的最快速度把数据发送
给打印机，但由于打印机不能快速地打印，这个发送速度会非常慢。由于打印机缓
存的出现，这个问题被解决了。打印机缓存是一个包含一些 RAM内存的设备，位
于计算机和打印机之间。通过打印机缓存，计算机把要打印的结果发送到这个缓存
区，数据会迅速地存储到这个 RAM中，这样计算机就能回去工作，而不用等待。
与此同时，打印机缓存将会以打印机可接受的速度把缓存中的数据缓慢地输出给打
印机。
缓存被广泛地应用于计算机中，使其运行得更快。别让偶尔地的读取或写入慢
设备的需求阻碍了系统的运行速度。在真正与比较慢的设备交互之前，操作系统会
尽可能多的读取或写入数据到内存中的存储设备里。以 Linux操作系统为例，你会
注意到系统看似填充了多于它所需要的内存。这不意味着 Linux正在使用所有的内
存，它意味着 Linux正在利用所有可用的内存，来作为缓存区。
这个缓存区允许非常快速地对存储设备进行写入，因为写入物理设备的操作被延
迟到后面进行。同时，这些注定要传送到设备中的数据正在内存中堆积起来。时不
时地，操作系统会把这些数据写入物理设备。
卸载一个设备需要把所有剩余的数据写入这个设备，所以设备可以被安全地移
除。如果没有卸载设备，就移除了它，就有可能没有把注定要发送到设备中的数据
输送完毕。在某些情况下，这些数据可能包含重要的目录更新信息，这将导致文件
系统损坏，这是发生在计算机中的最坏的事情之一。
16.3确定设备名称
有时很难来确定设备名称。在以前，这并不是很难。一台设备总是在某个固定的位置，也不会
挪动它。类 Unix的系统喜欢设备那样安排。退回到 Unix系统的时代，“更改一个磁盘驱动器”
更像是要用一辆叉车从机房中移除一台如洗衣机大小的设备那样困难。最近几年，典型的桌面
硬件配置已经变得相当动态，并且 Linux已经发展地比其祖先更加灵活。在以上事例中，我们
利用现代 Linux桌面系统的功能来“自动地”挂载设备，然后再确定设备名称。但是如果我们
正在管理一台服务器或者是其它一些（这种自动挂载功能）不会发生的环境，我们又如何能查
清设备名呢？
首先，让我们看一下系统怎样来命名设备。如果我们列出目录/dev（所有设备的住所）的内
容，我们会看到许许多多的设备：
188
[me@linuxbox~]$ls/dev
这个列表的内容揭示了一些设备命名的模式。这里有几个：
模式设备
/dev/fd*软盘驱动器
/dev/hd*老系统中的 IDE(PATA)磁盘。典型的主板包含两个 IDE
连接器或者是通道，每个连接器带有一根缆线，每根缆线上
有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主
设备，第二个叫做从设备。设备名称这样安排，/dev/hda
是指第一通道上的主设备名；/dev/hdb是第一通道上的从
设备名；/dev/hdc是第二通道上的主设备名，等等。末尾
的数字表示硬盘驱动器上的分区。例如，/dev/hda1是指系
统中第一硬盘驱动器上的第一个分区，而 /dev/hda则是指
整个硬盘驱动器。
/dev/lp*打印机
/dev/sd* SCSI磁盘。在最近的 Linux系统中，内核把所有类似于磁
盘的设备（包括 PATA/SATA硬盘，闪存，和 USB存储设
备，比如说可移动的音乐播放器和数码相机）看作 SCSI磁
盘。剩下的命名系统类似于上述所描述的旧的/dev/hd*命
名方案。
/dev/sr*光盘（CD/DVD读取器和烧写器）
表 16-2: Linux存储设备名称
另外，我们经常看到符号链接比如说/dev/cdrom，/dev/dvd和/dev/floppy，它们指向实际
的设备文件，提供这些链接是为了方便使用。如果你工作的系统不能自动挂载可移动的设备，
你可以使用下面的技巧来决定当可移动设备连接后，它是怎样被命名的。首先，启动一个实时
查看文件/var/log/messages（你可能需要超级用户权限）：
[me@linuxbox~]$sudotail-f/var/log/messages
189
这个文件的最后几行会被显示，然后停止。下一步，插入这个可移动的设备。在这个例子
里，我们将使用一个 16MB闪存。瞬间，内核就会发现这个设备，并且探测它：
Jul2310:07:53linuxboxkernel:usb3-2:newfullspeedUSBdevice
usinguhci_hcdandaddress2
Jul2310:07:53linuxboxkernel:usb3-2:configuration#1chosen
from1choice
Jul2310:07:53linuxboxkernel:scsi3:SCSIemulationforUSBMass
Storagedevices
Jul2310:07:58linuxboxkernel:scsiscan:INQUIRYresulttooshort
(5),using36
Jul2310:07:58linuxboxkernel:scsi3:0:0:0:Direct-AccessEasy
Disk1.00PQ:0ANSI:2
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]31263512-byte
hardwaresectors(16MB)
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]WriteProtectis
off
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]Assumingdrive
cache:writethrough
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]31263512-byte
hardwaresectors(16MB)
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]WriteProtectis
off
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]Assumingdrive
cache:writethrough
Jul2310:07:59linuxboxkernel:sdb:sdb1
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]AttachedSCSI
removabledisk
Jul2310:07:59linuxboxkernel:sd3:0:0:0:Attachedscsigeneric
sg3type0
显示再次停止之后，输入 Ctrl-c，重新得到提示符。输出结果的有趣部分是一再提及“[sdb]”，
这正好符和我们期望的 SCSI磁盘设备名称。知道这一点后，有两行输出变得颇具启发性：
Jul2310:07:59linuxboxkernel:sdb:sdb1
Jul2310:07:59linuxboxkernel:sd3:0:0:0:[sdb]AttachedSCSI
removabledisk
190
这告诉我们这个设备名称是/dev/sdb指整个设备，/dev/sdb1是这个设备的第一分区。正
如我们所看到的，使用 Linux系统充满了有趣的监测工作。
小贴士：使用这个 tail -f /var/log/messages技巧是一个很不错的方法，可以实时观察系统
的一举一动。
既然知道了设备名称，我们就可以挂载这个闪存驱动器了：
[me@linuxbox~]$sudomkdir/mnt/flash
[me@linuxbox~]$sudomount/dev/sdb1/mnt/flash
[me@linuxbox~]$df
Filesystem1K-blocksUsedAvailableUse%Mountedon
/dev/sda2151154525186944977516435%/
/dev/sda559631908317773762477648057%/home
/dev/sda11477641727712285813%/boot
tmpfs77680807768080%/dev/shm
/dev/sdb1155600155600%/mnt/flash
这个设备名称会保持不变只要设备与计算机保持连接并且计算机不会重新启动。
16.4创建新的文件系统
假若我们想要用 Linux本地文件系统来重新格式化这个闪存驱动器，而不是它现用的 FAT32
系统。这涉及到两个步骤：1.（可选的）创建一个新的分区布局若已存在的分区不是我们喜欢
的。2.在这个闪存上创建一个新的空的文件系统。
注意！在下面的练习中，我们将要格式化一个闪存驱动器。拿一个不包含有用数据的驱动
器作为实验品，因为它将会被擦除！再次，请确定你指定了正确的系统设备名称。未能注意此
警告可能导致你格式化（即擦除）错误的驱动器！
16.5用fdisk命令操作分区
这个 fdisk程序允许我们直接在底层与类似磁盘的设备（比如说硬盘驱动器和闪存驱动器）进
行交互。使用这个工具可以在设备上编辑，删除，和创建分区。以我们的闪存驱动器为例，首
先我们必须卸载它（如果需要的话），然后调用 fdisk程序，如下所示：
[me@linuxbox~]$sudoumount/dev/sdb1
[me@linuxbox~]$sudofdisk/dev/sdb
191
注意我们必须指定设备名称，就整个设备而言，而不是通过分区号。这个程序启动后，我们
将看到以下提示：
Command(mforhelp):
输入 “m”会显示程序菜单：
Commandaction
atoggleabootableflag
....
我们想要做的第一件事情是检查已存在的分区布局。输入 “p”会打印出这个设备的分区表：
Command(mforhelp):p
Disk/dev/sdb:16MB,16006656bytes
1heads,31sectors/track,1008cylinders
Units=cylindersof31*512=15872bytes
DeviceBootStartEndBlocksIdSystem
/dev/sdb12100815608+bw95FAT32
在此例中，我们看到一个 16MB的设备只有一个分区 (1)，此分区占用了可用的 1008个柱
面中的 1006个,并被标识为 Windows 95 FAT32分区。有些程序会使用这个标志符来限制一些
可以对磁盘所做的操作，但大多数情况下更改这个标志符没有危害。然而，为了叙述方便，我
们将会更改它，以此来表明是个 Linux分区。在更改之前，首先我们必须找到被用来识别一个
Linux分区的 ID号码。在上面列表中，我们看到 ID号码“b”被用来指定这个已存在的分区。
要查看可用的分区类型列表，参考之前的程序菜单。我们会看到以下选项：
llistknownpartitiontypes
192
如果我们在提示符下输入“l”，就会显示一个很长的可能类型列表。在它们之中会看到“b”
为已存在分区类型的 ID号，而“83”是针对 Linux系统的 ID号。
回到之前的菜单，看到这个选项来更改分区 ID号：
tchangeapartition'ssystemid
我们先输入“t”，再输入新的 ID号：
Command(mforhelp):t
Selectedpartition1
Hexcode(typeLtolistcodes):83
Changedsystemtypeofpartition1to83(Linux)
这就完成了我们需要做得所有修改。到目前为止，还没有接触这个设备（所有修改都存储在
内存中，而不是在此物理设备中），所以我们将会把修改过的分区表写入此设备，再退出。为
此，我们输入在提示符下输入 “w”:
Command(mforhelp):w
Thepartitiontablehasbeenaltered!
Callingioctl()tore-readpartitiontable.
WARNING:IfyouhavecreatedormodifiedanyDOS6.x
partitions,pleaseseethefdiskmanualpageforadditional
information.
Syncingdisks.
[me@linuxbox~]$
如果我们已经决定保持设备不变，可在提示符下输入 “q”，这将退出程序而没有写更改。我
们可以安全地忽略这些不祥的警告信息。
16.6用mkfs命令创建一个新的文件系统
完成了分区编辑工作（它或许是轻量级的），是时候在我们的闪存驱动器上创建一个新的文件系
统了。为此，我们会使用 mkfs（“make file system”的简写），它能创建各种格式的文件系统。
193
在此设备上创建一个 ext3文件系统，我们使用 “-t”选项来指定这个 “ext3”系统类型，随后是
我们要格式化的设备分区名称：
[me@linuxbox~]$sudomkfs-text3/dev/sdb1
mke2fs1.40.2(12-Jul-2007)
Filesystemlabel=
OStype:Linux
Blocksize=1024(log=0)
Fragmentsize=1024(log=0)
3904inodes,15608blocks
780blocks(5.00%)reservedforthesuperuser
Firstdatablock=1
Maximumfilesystemblocks=15990784
2blockgroups
8192blockspergroup,8192fragmentspergroup
1952inodespergroup
Superblockbackupsstoredonblocks:
8193
Writinginodetables:done
Creatingjournal(1024blocks):done
Writingsuperblocksandfilesystemaccountinginformation:done
Thisfilesystemwillbeautomaticallycheckedevery34mountsor
180days,whichevercomesfirst.Usetune2fs-cor-itooverride.
[me@linuxbox~]$
当 ext3被选为文件系统类型时，这个程序会显示许多信息。若把这个设备重新格式化为它
最初的 FAT32文件系统，指定 “vfat”作为文件系统类型：
[me@linuxbox~]$sudomkfs-tvfat/dev/sdb1
任何时候添加额外的存储设备到系统中时，都可以使用这个分区和格式化的过程。虽然我
们只以一个小小的闪存驱动器为例，同样的操作可以被应用到内部硬盘和其它可移动的存储设
备上像 USB硬盘驱动器。
194
16.7测试和修复文件系统
在之前讨论文件/etc/fstab时，我们会在每行的末尾看到一些神秘的数字。每次系统启动时，
在挂载系统之前，都会按照惯例检查文件系统的完整性。这个任务由 fsck程序（是”file system
check”的简写）完成。每个 fstab项中的最后一个数字指定了设备的检查顺序。在上面的实例
中，我们看到首先检查根文件系统，然后是 home和 boot文件系统。若最后一个数字是零则
相应设备不会被检查。
除了检查文件系统的完整性之外，fsck还能修复受损的文件系统，其成功度依赖于损坏的数
量。在类 Unix的文件系统中，文件恢复的部分被放置于 lost+found目录里面，位于每个文件
系统的根目录下面。
检查我们的闪存驱动器（首先应该卸载），我们能执行下面的操作：
[me@linuxbox~]$sudofsck/dev/sdb1
fsck1.40.8(13-Mar-2008)
e2fsck1.40.8(13-Mar-2008)
/dev/sdb1:clean,11/3904files,1661/15608blocks
以我的经验，文件系统损坏情况相当罕见，除非硬件存在问题，如磁盘驱动器故障。在大多
数系统中，系统启动阶段若探测到文件系统已经损坏了，则会导致系统停止下来，在系统继续
执行之前，会指导你运行 fsck程序。
什么是 fsck?
在 Unix文化中，“fsck”这个单词往往会被用来指代另一个和它仅有一个字母差
别的常用词。因为如果你遇到了迫不得已需要运行 fsck命令的糟糕境遇时，这个词
经常会脱口而出。
16.8格式化软盘
对于那些还在使用配备了软盘驱动器的计算机的用户，我们也能管理这些设备。准备一张
可用的空白软盘要分两个步骤。首先，对这张软盘执行低级格式化，然后创建一个文件系统。
为了完成格式化，我们使用 fdformat程序，同时指定软盘设备名称（通常为/dev/fd0）：
195
[me@linuxbox~]$sudofdformat/dev/fd0
Double-sided,80tracks,18sec/track.Totalcapacity1440kB.
Formatting...done
Verifying...done
接下来，通过 mkfs命令，给这个软盘创建一个 FAT文件系统：
[me@linuxbox~]$sudomkfs-tmsdos/dev/fd0
注意我们使用这个“msdos”文件系统类型来得到旧（小的）风格的文件分配表。当一个软
磁盘被准备好之后，则可能像其它设备一样挂载它。
16.9直接把数据移入/出设备
虽然我们通常认为计算机中的数据以文件形式来组织数据，也可以“原始的”形式来考虑数据。
如果我们看一下磁盘驱动器，例如，我们看到它由大量的数据“块”组成，而操作系统却把这
些数据块看作目录和文件。然而，如果把磁盘驱动器简单地看成一个数据块大集合，我们就能
执行有用的任务，如克隆设备。
这个 dd程序能执行此任务。它可以把数据块从一个地方复制到另一个地方。它使用独特的
语法（由于历史原因），经常它被这样使用：
ddif=input_fileof=output_file[bs=block_size[count=blocks]]
比方说我们有两个相同容量的 USB闪存驱动器，并且要精确地把第一个驱动器（中的内容）
复制给第二个。如果连接两个设备到计算机上，它们各自被分配到设备/dev/sdb和 /dev/sdc
上，这样我们就能通过下面的命令把第一个驱动器中的所有数据复制到第二个驱动器中。
ddif=/dev/sdbof=/dev/sdc
或者，如果只有第一个驱动器被连接到计算机上，我们可以把它的内容复制到一个普通文件
中供以后恢复或复制数据：
196
ddif=/dev/sdbof=flash_drive.img
警告！这个 dd命令非常强大。虽然它的名字来自于“数据定义”，有时候也把它叫做“清
除磁盘”因为用户经常会误输入 if或 of的规范。在按下回车键之前，要再三检查输入与输出
规范！
16.10创建CD-ROM映像
写入一个可记录的 CD-ROM（一个 CD-R或者是 CD-RW）由两步组成；首先，构建一个 iso
映像文件，这就是一个 CD-ROM的文件系统映像，第二步，把这个映像文件写入到 CD-ROM
媒介中。
16.10.1创建一个CD-ROM的映像拷贝
如果想要制作一张现有 CD-ROM的 iso映像，我们可以使用 dd命令来读取 CD-ROW中的所
有数据块，并把它们复制到本地文件中。比如说我们有一张 Ubuntu CD，用它来制作一个 iso
文件，以后我们可以用它来制作更多的拷贝。插入这张 CD之后，确定它的设备名称（假定是/
dev/cdrom），然后像这样来制作 iso文件：
ddif=/dev/cdromof=ubuntu.iso
这项技术也适用于 DVD光盘，但是不能用于音频 CD，因为它们不使用文件系统来存储数
据。对于音频 CD，看一下 cdrdao命令。
16.10.2从文件集合中创建一个映像
创建一个包含目录内容的 iso映像文件，我们使用 genisoimage程序。为此，我们首先创建一
个目录，这个目录中包含了要包括到此映像中的所有文件，然后执行这个 genisoimage命令来
创建映像文件。例如，如果我们已经创建一个叫做/cd-rom-files的目录，然后用文件填充此
目录，再通过下面的命令来创建一个叫做 cd-rom.iso映像文件：
197
genisoimage-ocd-rom.iso-R-J~/cd-rom-files
“-R”选项添加元数据为 Rock Ridge扩展，这允许使用长文件名和 POSIX风格的文件权
限。同样地，这个 “-J”选项使 Joliet扩展生效，这样 Windows中就支持长文件名了。
一个有着其它名字的程序。。。
如果你看一下关于创建和烧写光介质如 CD-ROMs和 DVD的在线文档，你会
经常碰到两个程序叫做 mkisofs和 cdrecord。这些程序是流行软件包 “cdrtools”的
一部分，”cdrtools”由 Jorg Schilling编写成。在 2006年春天，Schilling先生更改
了部分 cdrtools软件包的协议，Linux社区许多人的看法是，这创建了一个与 GNU
GPL不相兼容的协议。结果，就 fork了这个 cdrtools项目，目前新项目里面包含
了 cdrecord和 mkisofs的替代程序，分别是 wodim和 genisoimage。
16.11写入CD-ROM镜像
有了一个映像文件之后，我们可以把它烧写到光盘中。下面讨论的大多数命令对可记录的
CD-ROW和 DVD媒介都适用。
16.11.1直接挂载一个ISO镜像
有一个诀窍，我们可以用它来挂载 iso映像文件，虽然此文件仍然在我们的硬盘中，但我们当作
它已经在光盘中了。添加 “-o loop”选项来挂载（同时带有必需的 “-t iso9660”文件系统类型），
挂载这个映像文件就好像它是一台设备，把它连接到文件系统树上：
mkdir/mnt/iso_image
mount-tiso9660-oloopimage.iso/mnt/iso_image
上面的示例中，我们创建了一个挂载点叫做/mnt/iso_image，然后把此映像文件 image.iso
挂载到挂载点上。映像文件被挂载之后，可以把它当作，就好像它是一张真正的 CD-ROM或
者 DVD。当不再需要此映像文件后，记得卸载它。
198
16.11.2清除一张可重写入的CD-ROM
可重写入的 CD-RW媒介在被重使用之前需要擦除或清空。为此，我们可以用 wodim命令，指
定设备名称和清空的类型。此 wodim程序提供了几种清空类型。最小（且最快）的是 “fast”类
型：
wodimdev=/dev/cdrwblank=fast
16.11.3写入镜像
写入一个映像文件，我们再次使用 wodim命令，指定光盘设备名称和映像文件名：
wodimdev=/dev/cdrwimage.iso
除了设备名称和映像文件之外，wodim命令还支持非常多的选项。常见的两个选项是，“-v”
可详细输出，和 “－ dao”以 disk-at-once模式写入光盘。如果你正在准备一张光盘为的是商业
复制，那么应该使用这种模式。wodim命令的默认模式是 track-at-once，这对于录制音乐很有
用。
16.12拓展阅读
我们刚才谈到了很多方法，可以使用命令行管理存储介质。看看我们所讲过命令的手册页。一
些命令支持大量的选项和操作。此外，寻找一些如何添加硬盘驱动器到 Linux系统（有许多）
的在线教程，这些教程也要适用于光介质存储设备。
16.13友情提示
通常验证一下我们已经下载的 iso映像文件的完整性很有用处。在大多数情况下，iso映像文
件的贡献者也会提供一个 checksum文件。一个 checksum是一个神奇的数学运算的计算结果，
这个数学计算会产生一个能表示目标文件内容的数字。如果目标文件的内容即使更改一个二进
制位，checksum的结果将会非常不一样。生成 checksum数字的最常见方法是使用 md5sum程
序。当你使用 md5sum程序的时候，它会产生一个独一无二的十六进制数字：
199
md5sumimage.iso
34e354760f9bb7fbf85c96f6a3f94eceimage.iso
当你下载完映像文件之后，你应该对映像文件执行 md5sum命令，然后把运行结果与发行
商提供的 md5sum数值作比较。
除了检查下载文件的完整性之外，我们也可以使用 md5sum程序验证新写入的光学存储介
质。为此，首先我们计算映像文件的 checksum数值，然后计算此光学存储介质的 checksum数
值。这种验证光学介质的技巧是限定只对光学存储介质中包含映像文件的部分计算 checksum
数值。通过确定映像文件所包含的 2048个字节块的数目（光学存储介质总是以 2048个字节块
的方式写入）并从存储介质中读取那么多的字节块，我们就可以完成操作。某些类型的存储介
质，并不需要这样做。一个以 disk-at-once模式写入的 CD-R，可以用下面的方式检验：
md5sum/dev/cdrom
34e354760f9bb7fbf85c96f6a3f94ece/dev/cdrom
许多存储介质类型，如 DVD需要精确地计算字节块的数目。在下面的例子中，我们检验了
映像文件 dvd-image.iso以及 DVD光驱中磁盘 /dev/dvd文件的完整性。你能弄明白这是怎么
回事吗？
md5sumdvd-image.iso;ddif=/dev/dvdbs=2048count=$(($(stat-c"%s"dvd-
image.iso)/2048))|md5sum
200
17|网络系统
当谈及到网络系统层面，几乎任何东西都能由 Linux来实现。Linux被用来创建各式各样的网
络系统和装置，包括防火墙，路由器，名称服务器，网络连接式存储设备等等。
被用来配置和操作网络系统的命令数目，就如网络系统一样巨大。我们仅仅会关注一些最
经常使用到的命令。我们要研究的命令包括那些被用来监测网络和传输文件的命令。另外，我
们还会探讨用来远端登录的 ssh程序。这章会介绍：
• ping -发送 ICMP ECHO_REQUEST数据包到网络主机
• traceroute -打印到一台网络主机的路由数据包
• netstat -打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员
• ftp -因特网文件传输程序
• wget -非交互式网络下载器
• ssh - OpenSSH SSH客户端（远程登录程序）
我们假定你已经知道了一点网络系统背景知识。在这个因特网时代，每个计算机用户需要
理解基本的网络系统概念。为了能够充分利用这一章节的内容，我们应该熟悉以下术语：
• IP (网络协议)地址
•主机和域名
• URI（统一资源标识符）
请查看下面的“拓展阅读”部分，有几篇关于这些术语的有用文章。
注意：一些将要讲到的命令可能（取决于系统发行版）需要从系统发行版的仓库中安装额外
的软件包，并且一些命令可能需要超级用户权限才能执行。
201
17.1检查和监测网络
即使你不是一名系统管理员，检查一个网络的性能和运作情况也是经常有帮助的。
17.1.1ping
最基本的网络命令是 ping。这个 ping命令发送一个特殊的网络数据包，叫做 ICMP
ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来
允许网络连接验证。
注意：大多数网络设备（包括 Linux主机）都可以被配置为忽略这些数据包。通常，这样
做是出于网络安全原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞
IMCP流量也很普遍。
例如，看看我们能否连接到网站 linuxcommand.org（我们最喜欢的网站之一），我们可以这
样使用 ping命令：
[me@linuxbox~]$pinglinuxcommand.org
一旦启动，ping命令会持续在特定的时间间隔内（默认是一秒）发送数据包，直到它被中断：
[me@linuxbox~]$pinglinuxcommand.org
PINGlinuxcommand.org(66.35.250.210)56(84)bytesofdata.
64bytesfromvhost.sourceforge.net(66.35.250.210):icmp\_seq=1
ttl=43time=107ms
64bytesfromvhost.sourceforge.net(66.35.250.210):icmp\_seq=2
ttl=43time=108ms
64bytesfromvhost.sourceforge.net(66.35.250.210):icmp\_seq=3
ttl=43time=106ms
64bytesfromvhost.sourceforge.net(66.35.250.210):icmp\_seq=4
ttl=43time=106ms
64bytesfromvhost.sourceforge.net(66.35.250.210):icmp\_seq=5
ttl=43time=105ms
...
202
按下组合键 Ctrl-c，中断这个命令之后，ping打印出运行统计信息。一个正常工作的网络
会报告零个数据包丢失。一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，
路由，网关）都处于正常的工作状态。
17.1.2traceroute
这个 traceroute程序（一些系统使用相似的 tracepath程序来代替）会显示从本地到指定主机
要经过的所有“跳数”的网络流量列表。例如，看一下到达 slashdot.org需要经过的路由，我
们将这样做：
[me@linuxbox~]$tracerouteslashdot.org
命令输出看起来像这样：
traceroutetoslashdot.org(216.34.181.45),30hopsmax,40byte
packets
1ipcop.localdomain(192.168.1.1)1.066ms1.366ms1.720ms
2***
3ge-4-13-ur01.rockville.md.bad.comcast.net(68.87.130.9)14.622
ms14.885ms15.169ms
4po-30-ur02.rockville.md.bad.comcast.net(68.87.129.154)17.634
ms17.626ms17.899ms
5po-60-ur03.rockville.md.bad.comcast.net(68.87.129.158)15.992
ms15.983ms16.256ms
6po-30-ar01.howardcounty.md.bad.comcast.net(68.87.136.5)22.835
...
从输出结果中，我们可以看到连接测试系统到 slashdot.org网站需要经由 16个路由器。对
于那些提供标识信息的路由器，我们能看到它们的主机名，IP地址和性能数据，这些数据包括
三次从本地到此路由器的往返时间样本。对于那些没有提供标识信息的路由器（由于路由器配
置，网络拥塞，防火墙等方面的原因），我们会看到几个星号，正如行中所示。
17.1.3netstat
netstat程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们可以看
看网络设置中的各种特性。使用“-ie”选项，我们能够查看系统中的网络接口：
203
[me@linuxbox~]$netstat-ie
eth0Linkencap:EthernetHWaddr00:1d:09:9b:99:67
inetaddr:192.168.1.2Bcast:192.168.1.255Mask:255.255.255.0
inet6addr:fe80::21d:9ff:fe9b:9967/64Scope:Link
UPBROADCASTRUNNINGMULTICASTMTU:1500Metric:1
RXpackets:238488errors:0dropped:0overruns:0frame:0
TXpackets:403217errors:0dropped:0overruns:0carrier:0
collisions:0txqueuelen:100RXbytes:153098921(146.0MB)TX
bytes:261035246(248.9MB)Memory:fdfc0000-fdfe0000
loLinkencap:LocalLoopback
inetaddr:127.0.0.1Mask:255.0.0.0
...
在上述实例中，我们看到我们的测试系统有两个网络接口。第一个，叫做 eth0，是以太网接
口，和第二个，叫做 lo，是内部回环网络接口，它是一个虚拟接口，系统用它来“自言自语”。
当执行日常网络诊断时，要查看的重要信息是每个网络接口第四行开头出现的单词“UP”，
说明这个网络接口已经生效，还要查看第二行中 inet addr字段出现的有效 IP地址。对于使用
DHCP（动态主机配置协议）的系统，在这个字段中的一个有效 IP地址则证明了 DHCP工作
正常。
使用这个“-r”选项会显示内核的网络路由表。这展示了系统是如何配置网络之间发送数据
包的。
[me@linuxbox~]$netstat-r
KernelIProutingtable
DestinationGatewayGenmaskFlagsMSSWindowirttIface
192.168.1.0*255.255.255.0U000eth0
default192.168.1.10.0.0.0UG000eth0
在这个简单的例子里面，我们看到了，位于防火墙之内的局域网中，一台客户端计算机的典
型路由表。第一行显示了目的地 192.168.1.0。IP地址以零结尾是指网络，而不是独立主机，所
以这个目的地意味着局域网中的任何一台主机。下一个字段，Gateway，是网关（路由器）的
名字或 IP地址，用它来连接当前的主机和目的地的网络。若这个字段显示一个星号，则表明
不需要网关。
204
最后一行包含目的地 default。指的是发往任何表上没有列出的目的地网络的流量。在我们
的实例中，我们看到网关被定义为地址 192.168.1.1的路由器，它应该能知道怎样来处理目的地
流量。
netstat程序有许多选项，我们仅仅讨论了几个。查看 netstat命令的手册，可以得到所有
选项的完整列表。
17.2网络中传输文件
网络有什么用处呢？除非我们知道了怎样通过网络来传输文件。有许多程序可以用来在网络中
传送数据。我们先讨论两个，随后的章节里再介绍几个。
17.2.1ftp
ftp命令属于真正的“经典”程序之一，它的名字来源于其所使用的协议，就是文件传输协议。
FTP被广泛地用来从因特网上下载文件。大多数，并不是所有的，网络浏览器都支持 FTP，你
经常可以看到它们的 URI以协议 ftp://开头。在出现网络浏览器之前，ftp程序已经存在了。
ftp程序可用来与 FTP服务器进行通信，FTP服务器就是存储文件的计算机，这些文件能够
通过网络下载和上传。
FTP（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意
味着这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 FTP
服务器都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码
登录系统。
在下面的例子中，我们将展示一个典型的会话，从匿名 FTP服务器，其名字是 fileserver，
的/pub/_images/Ubuntu-8.04的目录下，使用 ftp程序下载一个 Ubuntu系统映像文件。
[me@linuxbox~]$ftpfileserver
Connectedtofileserver.localdomain.
220(vsFTPd2.0.1)
Name(fileserver:me):anonymous
331Pleasespecifythepassword.
Password:
230Loginsuccessful.
RemotesystemtypeisUNIX.
Usingbinarymodetotransferfiles.
ftp>cdpub/cd\_images/Ubuntu-8.04
250Directorysuccessfullychanged.
205
ftp>ls
200PORTcommandsuccessful.ConsiderusingPASV.
150Herecomesthedirectorylisting.
-rw-rw-r--1500500733079552Apr2503:53ubuntu-8.04-desktop-i386.iso
226DirectorysendOK.
ftp>lcdDesktop
Localdirectorynow/home/me/Desktop
ftp>getubuntu-8.04-desktop-i386.iso
local:ubuntu-8.04-desktop-i386.isoremote:ubuntu-8.04-desktop-
i386.iso
200PORTcommandsuccessful.ConsiderusingPASV.
150OpeningBINARYmodedataconnectionforubuntu-8.04-desktop-
i386.iso(733079552bytes).
226FilesendOK.
733079552bytesreceivedin68.56secs(10441.5kB/s)
ftp>bye
这里是对会话期间所输入命令的解释说明：
命令意思
ftp fileserver唤醒 ftp程序，让它连接到 FTP服务器，file-
server。
anonymous登录名。输入登录名后，将出现一个密码提示。
一些服务器将会接受空密码，其它一些则会要
求一个邮件地址形式的密码。如果是这种情况，
试着输入“user@example.com”。
cd pub/cd_images/Ubuntu-跳转到远端系统中，要下载文件所在的目录下，
8.04注意在大多数匿名的 FTP服务器中，支持公共
下载的文件都能在目录 pub下找到
ls列出远端系统中的目录。
lcd Desktop跳转到本地系统中的 ˜/Desktop目录下。在实
例中，ftp程序在工作目录 ˜下被唤醒。这个命
令把工作目录改为 ˜/Desktop
206
get ubuntu-8.04-desktop-告诉远端系统传送文件到本地。因为本地系统
i386.iso的工作目录已经更改到了 ˜/Desktop，所以文件
会被下载到此目录。
bye退出远端服务器，结束 ftp程序会话。也可以使
用命令 quit和 exit。
表 17-1:
在“ftp>”提示符下，输入“help”，会显示所支持命令的列表。使用 ftp登录到一台授予了
用户足够权限的服务器中，则可以执行很多普通的文件管理任务。虽然很笨拙，但它真能工作。
17.2.2lftp-更好的ftp
ftp并不是唯一的命令行形式的 FTP客户端。实际上，还有很多。其中比较好（也更流行的）
是 lftp程序，由 Alexander Lukyanov编写完成。虽然 lftp工作起来与传统的 ftp程序很相似，
但是它带有额外的便捷特性，包括多协议支持（包括 HTTP），若下载失败会自动地重新下载，
后台处理，用 tab按键来补全路径名，还有很多。
17.2.3wget
另一个流行的用来下载文件的命令行程序是 wget。若想从网络和 FTP网站两者上都能下载
数据，wget是很有用处的。不只能下载单个文件，多个文件，甚至整个网站都能下载。下载
linuxcommand.org网站的首页，我们可以这样做：
[me@linuxbox~]$wgethttp://linuxcommand.org/index.php
--11:02:51--http://linuxcommand.org/index.php
=>`index.php'
Resolvinglinuxcommand.org...66.35.250.210
Connectingtolinuxcommand.org|66.35.250.210|:80...connected.
HTTPrequestsent,awaitingresponse...200OK
Length:unspecified[text/html]
[<=>]3,120--.--K/s
11:02:51(161.75MB/s)-'index.php'saved[3120]
207
这个程序的许多选项允许 wget递归地下载，在后台下载文件（你退出后仍在下载），能完
成未下载全的文件。这些特性在其优秀的命令手册中有着详尽地说明。
17.3与远程主机安全通信
通过网络来远程操控类 Unix的操作系统已经有很多年了。早些年，在因特网普遍推广之前，
有一些受欢迎的程序被用来登录远程主机。它们是 rlogin和 telnet程序。然而这些程序，拥有
和 ftp程序一样的致命缺点；它们以明码形式来传输所有的交流信息（包括登录命令和密码）。
这使它们完全不适合使用在因特网时代。
17.3.1ssh
为了解决这个问题，开发了一款新的协议，叫做 SSH（Secure Shell）。SSH解决了这两个基本
的和远端主机安全交流的问题。首先，它要认证远端主机是否为它所知道的那台主机（这样就
阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间所有的通讯信息。
SSH由两部分组成。SSH服务端运行在远端主机上，在端口 22上监听收到的外部连接，而
SSH客户端用在本地系统中，用来和远端服务器通信。
大多数 Linux发行版自带一个提供 SSH功能的软件包，叫做 OpenSSH，来自于 BSD项
目。一些发行版默认包含客户端和服务端两个软件包（例如 Red Hat），而另一些（比方说
Ubuntu）则只提供客户端。为了能让系统接受远端的连接，它必须安装 OpenSSH-server软件
包，配置，运行它，并且（如果系统正在运行，或者系统在防火墙之后）它必须允许在 TCP端
口 22上接收网络连接。
小贴示：如果你没有远端系统去连接，但还想试试这些实例，则确认安装了 OpenSSH-server
软件包，则可使用 localhost作为远端主机的名字。这种情况下，计算机会和它自己创建网络连
接。
用来与远端 SSH服务器相连接的 SSH客户端程序，顺理成章，叫做 ssh。想要连接到名叫
remote-sys的远端主机，我们可以这样使用 ssh客户端程序：
208
[me@linuxbox~]$sshremote-sys
Theauthenticityofhost'remote-sys(192.168.1.4)'can'tbe
established.
RSAkeyfingerprintis
41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.
Areyousureyouwanttocontinueconnecting(yes/no)?
第一次尝试连接，提示信息表明远端主机的真实性不能确立。这是因为客户端程序以前从
没有看到过这个远端主机。为了接受远端主机的身份验证凭据，输入“yes”。一旦建立了连接，
会提示用户输入他或她的密码：
Warning:Permanentlyadded'remote-sys,192.168.1.4'(RSA)tothelist
ofknownhosts.
me@remote-sys'spassword:
成功地输入密码之后，我们会接收到远端系统的 shell提示符：
Lastlogin:SatAug3013:00:482008
[me@remote-sys~]$
远端 shell会话一直存在，直到用户输入 exit命令后，则关闭了远程连接。这时候，本地的
shell会话恢复，本地 shell提示符重新出现。
也有可能使用不同的用户名连接到远程系统。例如，如果本地用户“me”，在远端系统中有
一个帐号名“bob”，则用户 me能够用 bob帐号登录到远端系统，如下所示：
[me@linuxbox~]$sshbob@remote-sys
bob@remote-sys'spassword:
Lastlogin:SatAug3013:03:212008
[bob@remote-sys~]$
正如之前所讲到的，ssh验证远端主机的真实性。如果远端主机不能成功地通过验证，则会
提示以下信息：
209
[me@linuxbox~]$sshremote-sys
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
WARNING:REMOTEHOSTIDENTIFICATIONHASCHANGED!
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
ITISPOSSIBLETHATSOMEONEISDOINGSOMETHINGNASTY!
Someonecouldbeeavesdroppingonyourightnow(man-in-the-middle
attack)!
...
有两种可能的情形会提示这些信息。第一，某个攻击者企图制造“中间人”袭击。这很少
见，因为每个人都知道 ssh会针对这种状况发出警告。最有可能的罪魁祸首是远端系统已经改
变了；例如，它的操作系统或者是 SSH服务器重新安装了。然而，为了安全起见，第一个可能
性不应该被轻易否定。当这条消息出现时，总要与远端系统的管理员查对一下。
当确定了这条消息归结为一个良性的原因之后，那么在客户端更正问题就很安全了。使用
文本编辑器（可能是 vim）从文件/.ssh/known_hosts中删除废弃的钥匙，就解决了问题。在
上面的例子里，我们看到这样一句话：
Offendingkeyin/home/me/.ssh/known_hosts:1
这意味着 known_hosts文件的第一行包含那个冲突的钥匙。从文件中删除这一行，则 ssh
程序就能够从远端系统接受新的身份验证凭据。
除了能够在远端系统中打开一个 shell会话，ssh程序也允许我们在远端系统中执行单个命
令。例如，在名为 remote-sys的远端主机上，执行 free命令，并把输出结果显示到本地系统
shell会话中。
[me@linuxbox~]$sshremote-sysfree
me@twin4'spassword:
totalusedfreesharedbufferscached
Mem:7755365071842683520110068154596
210
-/+buffers/cache:242520533016
Swap:015728560110068154596
[me@linuxbox~]$
有可能以更有趣的方式来利用这项技术，比方说下面的例子，我们在远端系统中执行 ls命
令，并把命令输出重定向到本地系统中的一个文件里面。
[me@linuxbox~]$sshremote-sys'ls\*'>dirlist.txt
me@twin4'spassword:
[me@linuxbox~]$
注意，上面的例子中使用了单引号。这样做是因为我们不想路径名展开操作在本地执行，而
希望它在远端系统中被执行。同样地，如果我们想要把输出结果重定向到远端主机的文件中，
我们可以把重定向操作符和文件名都放到单引号里面。
[me@linuxbox~]$sshremote-sys'ls*>dirlist.txt'
SSH通道
当你通过 SSH协议与远端主机建立连接的时候，其中发生的事就是在本地与远
端系统之间创建了一条加密通道。通常，这条通道被用来把在本地系统中输入的命
令安全地传输到远端系统，同样地，再把执行结果安全地发送回来。除了这个基本
功能之外，SSH协议允许大多数网络流量类型通过这条加密通道来被传送，在本地
与远端系统之间创建一种 VPN（虚拟专用网络）。
可能这个特性的最普遍的用法是允许传递 X窗口系统流量。在运行着 X服务端
的系统（也就是，能显示 GUI的机器）上，能登录远端系统并运行一个 X客户端程
序（一个图形化应用），而应用程序的显示结果出现在本地。这很容易完成，这里有
个例子：假设我们正坐在一台名为 linuxbox的 Linux系统前，且系统中运行着 X
服务端，现在我们想要在名为 remote-sys的远端系统中运行 xload程序，但是要在
我们的本地系统中看到这个程序的图形化输出。我们可以这样做：
211
[me@linuxbox~]$ssh-Xremote-sys
me@remote-sys'spassword:
Lastlogin:MonSep0813:23:112008
[me@remote-sys~]$xload
这个 xload命令在远端执行之后，它的窗口就会出现在本地。在某些系统中，你
可能需要使用“－ Y”选项，而不是“－ X”选项来完成这个操作。
17.3.2scp和sftp
OpenSSH软件包也包含两个程序，它们可以利用 SSH加密通道在网络间复制文件。第一个，
scp（安全复制）被用来复制文件，与熟悉的 cp程序非常相似。最显著的区别就是源或者目标
路径名要以远端主机的名字，后跟一个冒号字符开头。例如，如果我们想要从 remote-sys远端
系统的家目录下复制文档 document.txt，到我们本地系统的当前工作目录下，可以这样操作：
[me@linuxbox~]$scpremote-sys:document.txt.
me@remote-sys'spassword:
document.txt
100%55815.5KB/s00:00
[me@linuxbox~]$
和 ssh命令一样，如果所需的远端主机帐户名与本地系统中的不一致，那么你可以把用户名
添加到远端主机名的开头：
[me@linuxbox~]$scpbob@remote-sys:document.txt.
第二个 SSH文件复制程序是 sftp，顾名思义，它是 ftp程序的安全替代品。sftp工作起来
与我们之前使用的 ftp程序很相似；然而，它不用明码形式来传递数据，它使用加密的 SSH通
道。sftp有一个重要特性强于传统的 ftp命令，就是 sftp不需要远端系统中运行 FTP服务端。
它仅仅需要 SSH服务端。这意味着任何一台能用 SSH客户端连接的远端机器，也可当作类似
于 FTP的服务器来使用。这里是一个样本会话：
212
[me@linuxbox~]$sftpremote-sys
Connectingtoremote-sys...
me@remote-sys'spassword:
sftp>ls
ubuntu-8.04-desktop-i386.iso
sftp>lcdDesktop
sftp>getubuntu-8.04-desktop-i386.iso
Fetching/home/me/ubuntu-8.04-desktop-i386.isotoubuntu-8.04-
desktop-i386.iso
/home/me/ubuntu-8.04-desktop-i386.iso100%699MB7.4MB/s01:35
sftp>bye
小贴示：SFTP协议被许多 Linux发行版中的图形化文件管理器支持。使用 Nautilus
(GNOME),或者是 Konqueror (KDE)，我们都能在位置栏中输入以 sftp://开头的 URI，来操
作存储在运行着 SSH服务端的远端系统中的文件。
Windows中的SSH客户端
比方说你正坐在一台 Windows机器前面，但是你需要登录到你的 Linux服务器
中，去完成一些实际的工作，那该怎么办呢？当然是找一个 Windows平台下的 SSH
客户端！有很多这样的工具。最流行的可能就是由 Simon Tatham和他的团队开发
的 PuTTY了。PuTTY程序能够显示一个终端窗口，而且允许 Windows用户在远
端主机中打开一个 SSH（或者 telnet）会话。这个程序也提供了 scp和 sftp程序的
类似物。
PuTTY可在链接 http://www.chiark.greenend.org.uk/sgtatham/putty/处得
到。
17.4拓展阅读
• Linux文档项目提供了 Linux网络管理指南，可以广泛地（虽然过时了）了解网络管理方
面的知识。
213
http://tldp.org/LDP/nag2/index.html
• Wikipedia上包含了许多网络方面的优秀文章。这里有一些基础的：
http://en.wikipedia.org/wiki/Internet_protocol_address
http://en.wikipedia.org/wiki/Host_name
http://en.wikipedia.org/wiki/Uniform_Resource_Identifier
214
18|查找文件
随着我们在 Linux系统中的不断探索，一件事已经变得非常清楚：一个典型的 Linux系统包含
很多文件！这就引发了一个问题，“我们怎样查找东西？”。虽然我们已经知道 Linux文件系统
已经根据类 Unix系统的代代相传的惯例而被良好地组织起来了。但是海量的文件会引起一个
可怕的问题。在这一章中，我们将察看两个用来在系统中查找文件的工具。这些工具是：
• locate–通过名字来查找文件
• find–在一个目录层次结构中搜索文件
我们也将看一个经常与文件搜索命令一起使用的命令，它用来处理搜索到的文件列表：
• xargs–从标准输入生成和执行命令行
另外，我们将介绍两个命令以便在我们探索的过程中协助我们：
• touch–更改文件时间
• stat–显示文件或文件系统状态
18.1locate-查找文件的简单方法
这个 locate程序会执行一次快速的路径名数据库搜索，并且输出每个与给定子字符串相匹配的
路径名。比如说，例如，我们想要找到所有名字以“zip”开头的程序。因为我们正在查找程序，
可以假定包含程序的目录以 “bin/”结尾。因此，我们试着以这种方式使用 locate命令，来找
到我们的文件：
[me@linuxbox~]$locatebin/zip
locate命令将会搜索它的路径名数据库，输出任一个包含字符串“bin/zip”的路径名：
215
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
如果搜索要求没有这么简单，locate可以结合其它工具，比如说 grep命令，来设计更加有
趣的搜索：
[me@linuxbox~]$locatezip|grepbin
/bin/bunzip2
/bin/bzip2
/bin/bzip2recover
/bin/gunzip
/bin/gzip
/usr/bin/funzip
/usr/bin/gpg-zip
/usr/bin/preunzip
/usr/bin/prezip
/usr/bin/prezip-bin
/usr/bin/unzip
/usr/bin/unzipsfx
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
这个 locate程序已经存在了很多年了，它有几个不同的变体被普遍使用着。在现在 Linux
发行版中两个最常见的变体是 slocate和 mlocate，尽管它们通常被名为 locate的符号链接访
问。不同版本的 locate命令拥有重叠的选项集合。一些版本包括正则表达式匹配（我们会在下
一章中讨论）和通配符支持。可以查看 locate命令的手册来确定安装了哪个版本的 locate程
序。
216
locate数据库来自何方？
你可能注意到了，在一些发行版中，仅仅在系统安装之后，locate不能工作，但
是如果你第二天再试一下，它就正常工作了。怎么回事呢？locate数据库由另一个
叫做 updatedb的程序创建。通常，这个程序作为一个定时任务（jobs）周期性运转；
也就是说，一个任务在特定的时间间隔内被 cron守护进程执行。大多数装有 locate
的系统会每隔一天运行一回 updatedb程序。因为数据库不能被持续地更新，所以
当使用 locate时，你会发现目前最新的文件不会出现。为了克服这个问题，通过更
改为超级用户身份，在提示符下运行 updatedb命令，可以手动运行 updatedb程
序。
18.2find-查找文件的复杂方式
locate程序只能依据文件名来查找文件，而 find程序能基于各种各样的属性搜索一个给定目录
（以及它的子目录），来查找文件。我们将要花费大量的时间学习 find命令，因为它有许多有趣
的特性，当我们开始在随后的章节里面讨论编程概念的时候，我们将会重复看到这些特性。
在它的最简单的使用方式中，find命令接收一个或多个目录名来执行搜索。例如，输出我们
的家目录的路径名列表（包括文件及目录，译者注）。
[me@linuxbox~]$find~
在最活跃的用户帐号中，这将产生一张很大的列表。因为这张列表被发送到标准输出，我们
可以把这个列表管道到其它的程序中。让我们使用 wc程序来计算出文件的数量：
[me@linuxbox~]$find~|wc-l
47068
哇，我们一直很忙（在 home路径下执行了很多操作，译者注）！find命令的魅力所在就是
它能够被用来找到符合特定标准的文件。它通过（有点奇怪）应用选项，测试条件，和操作来
做到这一点。我们先看一下测试条件：
217
18.2.1Tests
比如说我们想在我们的搜索中得到目录列表。我们可以添加以下测试条件：
[me@linuxbox~]$find~-typed|wc-l
1695
添加测试条件-type d限制了只搜索目录。相反地，我们可以使用这个测试条件来限定搜索
普通文件：
[me@linuxbox~]$find~-typef|wc-l
38737
这里是 find命令支持的常见文件类型测试条件：
文件类型描述
b块特殊设备文件
c字符特殊设备文件
d目录
f普通文件
l符号链接
表 18-1: find文件类型
我们也可以通过加入一些额外的测试条件，根据文件大小和文件名来搜索：让我们查找所有
文件名匹配通配符模式“*.JPG”和文件大小大于 1M的普通文件：
[me@linuxbox~]$find~-typef-name"*.JPG"-size+1M|wc-l
840
在这个例子里面，我们加入了 -name测试条件，后面跟通配符模式。注意，我们把它用
双引号引起来，从而阻止 shell展开路径名。紧接着，我们加入 -size测试条件，后跟字符串
“+1M”。开头的加号表明我们正在寻找文件大小大于指定数的文件。若字符串以减号开头，则
218
意味着查找小于指定数的文件。若没有符号意味着“精确匹配这个数”。结尾字母“M”表明测
量单位是兆字节。下面的字符可以被用来指定测量单位：
字符单位
b 512个字节块。如果没有指定单位，则这是默认值。
c字节
w两个字节的字
k千字节 (1024个字节单位)
M兆字节 (1048576个字节单位)
G千兆字节 (1073741824个字节单位)
表 18-2: find大小单位
find命令支持大量不同的测试条件。下表是列出了一些常见的测试条件。请注意，在需要
数值参数的情况下，可以应用以上讨论的“+”和“-”符号表示法：
测试条件描述
-cmin n匹配内容或属性最后修改时间正好在 n分钟之前的文件或
目录。指定少于 n分钟之前，使用 -n，指定多于 n分钟之
前，使用 +n。
-cnewer file匹配内容或属性最后修改时间晚于 file的文件或目录。
-ctime n匹配内容和属性最后修改时间在 n*24小时之前的文件和目
录。
-empty匹配空文件和目录。
-group name匹配属于一个组的文件或目录。组可以用组名或组 ID来表
示。
-iname pattern就像-name测试条件，但是不区分大小写。
-inum n匹配 inode号是 n的文件。这对于找到某个特殊 inode的
所有硬链接很有帮助。
-mmin n匹配内容被修改于 n分钟之前的文件或目录。
-mtime n匹配的文件或目录的内容被修改于 n*24小时之前。
-name pattern用指定的通配符模式匹配的文件和目录。
219
-newer file匹配内容晚于指定的文件的文件和目录。这在编写执行备
份的 shell脚本的时候很有帮。每次你制作一个备份，更新
文件（比如说日志），然后使用 find命令来判断哪些文件自
从上一次更新之后被更改了。
-nouser匹配不属于一个有效用户的文件和目录。这可以用来查找
属于被删除的帐户的文件或监测攻击行为。
-nogroup匹配不属于一个有效的组的文件和目录。
-perm mode匹配权限已经设置为指定的 mode的文件或目录。mode可
以用八进制或符号表示法。
-samefile name类似于-inum测试条件。匹配和文件 name享有同样 inode
号的文件。
-size n匹配大小为 n的文件
-type c匹配文件类型是 c的文件。
-user name匹配属于某个用户的文件或目录。这个用户可以通过用户
名或用户 ID来表示。
表 18-3: find测试条件
这不是一个完整的列表。find命令手册有更详细的说明。
18.2.2操作符
即使拥有了 find命令提供的所有测试条件，我们还需要一个更好的方式来描述测试条件之间的
逻辑关系。例如，如果我们需要确定是否一个目录中的所有的文件和子目录拥有安全权限，怎
么办呢？我们可以查找权限不是 0600的文件和权限不是 0700的目录。幸运地是，find命令提
供了一种方法来结合测试条件，通过使用逻辑操作符来创建更复杂的逻辑关系。为了表达上述
的测试条件，我们可以这样做：
[me@linuxbox~]$find~\(-typef-not-perm0600\)-or\(-typed-not-perm0700\)
呀！这的确看起来很奇怪。这些是什么东西？实际上，这些操作符没有那么复杂，一旦你知
道了它们的原理。这里是操作符列表：
操作符描述
220
-and如果操作符两边的测试条件都是真，则匹配。可以简写为
-a。注意若没有使用操作符，则默认使用 -and。
-or若操作符两边的任一个测试条件为真，则匹配。可以简写为
-o。
-not若操作符后面的测试条件是假，则匹配。可以简写为一个感
叹号（!）。
()把测试条件和操作符组合起来形成更大的表达式。这用来
控制逻辑计算的优先级。默认情况下，find命令按照从左到
右的顺序计算。经常有必要重写默认的求值顺序，以得到期
望的结果。即使没有必要，有时候包括组合起来的字符，对
提高命令的可读性是很有帮助的。注意因为圆括号字符对
于 shell来说有特殊含义，所以在命令行中使用它们的时候，
它们必须用引号引起来，才能作为实参传递给 find命令。
通常反斜杠字符被用来转义圆括号字符。
表 18-4: find命令的逻辑操作符
通过这张操作符列表，我们重建 find命令。从最外层看，我们看到测试条件被分为两组，
由一个 -or操作符分开：
(expression1)-or(expression2)
这看起来合理，因为我们正在搜索具有不同权限集合的文件和目录。如果我们文件和目录
两者都查找，那为什么要用 -or来代替 -and呢？因为 find命令扫描文件和目录时，会计算每
一个对象，看看它是否匹配指定的测试条件。我们想要知道它是具有错误权限的文件还是有错
误权限的目录。它不可能同时符合这两个条件。所以如果展开组合起来的表达式，我们能这样
解释它：
(filewithbadperms)-or(directorywithbadperms)
下一个挑战是怎样来检查“错误权限”，这个怎样做呢？事实上我们不从这个角度入手。我
们将测试“不是正确权限”，因为我们知道什么是“正确权限”。对于文件，我们定义正确权限
221
为 0600，目录则为 0700。测试具有“不正确”权限的文件表达式为：
-typef-and-not-perms0600
对于目录，表达式为：
-typed-and-not-perms0700
正如上述操作符列表中提到的，这个-and操作符能够被安全地删除，因为它是默认使用的
操作符。所以如果我们把这两个表达式连起来，就得到最终的命令：
find~(-typef-not-perms0600)-or(-typed-not-perms0700)
然而，因为圆括号对于 shell有特殊含义，我们必须转义它们，来阻止 shell解释它们。在
圆括号字符之前加上一个反斜杠字符来转义它们。
逻辑操作符还有另外一个特性要重点理解。比方说我们有两个由逻辑操作符分开的表达式：
expr1-operatorexpr2
在所有情况下，总会执行表达式 expr1；然而操作符将决定是否执行表达式 expr2。这里列
出了它是怎样工作的：
expr1的结果操作符 expr2 is...
真 -and总要执行
假 -and从不执行
真 -or从不执行
假 -or总要执行
表 18-5: find AND/OR逻辑
为什么这会发生呢？这样做是为了提高性能。以 -and为例，我们知道如果表达式 expr1的
222
结果为假，表达式 expr1 -and expr2不能为真，所以没有必要执行 expr2。同样地，如果我们
有表达式 expr1 -or expr2，并且表达式 expr1的结果为真，那么就没有必要执行 expr2，因为
我们已经知道表达式 expr1 -or expr2为真。好，这样会执行快一些。为什么这个很重要？它很
重要是因为我们能依靠这种行为来控制怎样来执行操作。我们会很快看到…
18.3预定义的操作
让我们做一些工作吧！执行 find命令得到结果列表很有用处，但是我们真正想要做的事情是操
作列表中的某些条目。幸运地是，find命令允许基于搜索结果来执行操作。有许多预定义的操
作和几种方式来应用用户定义的操作。首先，让我们看一下几个预定义的操作：
操作描述
-delete删除当前匹配的文件。
-ls对匹配的文件执行等同的 ls -dils命令。并将结果发送到标
准输出。
-print把匹配文件的全路径名输送到标准输出。如果没有指定其
它操作，这是默认操作。
-quit一旦找到一个匹配，退出。
表 18-6:几个预定义的 find命令操作
和测试条件一样，还有更多的操作。查看 find命令手册得到更多细节。在第一个例子里，
我们这样做：
find~
这个命令输出了我们家目录中包含的每个文件和子目录。它会输出一个列表，因为会默认
使用-print操作，如果没有指定其它操作的话。因此我们的命令也可以这样表述：
find~-print
我们可以使用 find命令来删除符合一定条件的文件。例如，来删除扩展名为“.BAK”（这
通常用来指定备份文件）的文件，我们可以使用这个命令：
223
find~-typef-name'*.BAK'-delete
在这个例子里面，用户家目录（和它的子目录）下的每个文件中搜索以.BAK结尾的文件
名。当找到后，就删除它们。
警告：当使用 -delete操作时，不用说，你应该格外小心。每次都应该首先用 -print操作代
替 -delete测试一下命令，来确认搜索结果。
在我们继续之前，让我们看一下逻辑运算符是怎样影响操作的。考虑以下命令：
find~-typef-name'*.BAK'-print
正如我们所见到的，这个命令会查找每个文件名以.BAK (-name ‘*.BAK’)结尾的普通文件
(-type f)，并把每个匹配文件的相对路径名输出到标准输出 (-print)。然而，此命令按这个方式
执行的原因，是由每个测试和操作之间的逻辑关系决定的。记住，在每个测试和操作之间会默
认应用 -and逻辑运算符。我们也可以这样表达这个命令，使逻辑关系更容易看出：
find~-typef-and-name'*.BAK'-and-print
当命令被充分表达之后，让我们看看逻辑运算符是如何影响其执行的：
测试／行为只有...的时候，才被执行
-print只有 -type f and -name ’*.BAK’为真的时候
-name‘*.BAK’只有 -type f为真的时候
-type f总是被执行，因为它是与 -and关系中的第一个测试／行为。
因为测试和行为之间的逻辑关系决定了哪一个会被执行，我们可以看出知道测试和行为的
顺序很重要。例如，如果我们重新安排测试和行为之间的顺序，让 -print行为是第一个，那么
224
这个命令执行起来会截然不同：
find~-print-and-typef-and-name'*.BAK'
这个版本的命令会打印出每个文件（-print行为总是为真），然后测试文件类型和指定的文
件扩展名。
18.4用户定义的行为
除了预定义的行为之外，我们也可以调用任意的命令。传统方式是通过 -exec行为。这个行为
像这样工作：
-execcommand{};
这里的 command就是指一个命令的名字，{}是当前路径名的符号表示，分号是必要的分
隔符表明命令的结束。这里是一个使用 -exec行为的例子，其作用如之前讨论的 -delete行为：
-execrm'{}'';'
重述一遍，因为花括号和分号对于 shell有特殊含义，所以它们必须被引起来或被转义。
我们也可以交互式地执行一个用户定义的行为。通过使用 -ok行为来代替 -exec，在执行每
个指定的命令之前，会提示用户：
find~-typef-name'foo*'-okls-l'{}'';'
<ls.../home/me/bin/foo>?y
-rwxr-xr-x1meme2242007-10-2918:44/home/me/bin/foo
<ls.../home/me/foo.txt>?y
-rw-r--r--1meme02008-09-1912:53/home/me/foo.txt
在这个例子里面，我们搜索以字符串“foo”开头的文件名，并且对每个匹配的文件执行 ls
-l命令。使用 -ok行为，会在 ls命令执行之前提示用户。
225
18.5提高效率
当 -exec行为被使用的时候，若每次找到一个匹配的文件，它会启动一个新的指定命令的实例。
我们可能更愿意把所有的搜索结果结合起来，再运行一个命令的实例。例如，与其像这样执行
命令：
ls-lfile1
ls-lfile2
我们更喜欢这样执行命令：
ls-lfile1file2
这样就导致命令只被执行一次而不是多次。有两种方法可以这样做。传统方式是使用外部
命令 xargs，另一种方法是，使用 find命令自己的一个新功能。我们先讨论第二种方法。
通过把末尾的分号改为加号，就激活了 find命令的一个功能，把搜索结果结合为一个参数
列表，然后用于所期望的命令的一次执行。再看一下之前的例子，这个例子中：
find~-typef-name'foo*'-execls-l'{}'';'
-rwxr-xr-x1meme2242007-10-2918:44/home/me/bin/foo
-rw-r--r--1meme02008-09-1912:53/home/me/foo.txt
每次找到一个匹配的文件，就会执行一次 ls命令。通过把命令改为：
find~-typef-name'foo*'-execls-l'{}'+
-rwxr-xr-x1meme2242007-10-2918:44/home/me/bin/foo
-rw-r--r--1meme02008-09-1912:53/home/me/foo.txt
虽然我们得到一样的结果，但是系统只需要执行一次 ls命令。
18.5.1xargs
这个 xargs命令会执行一个有趣的函数。它从标准输入接受输入，并把输入转换为一个特定命
令的参数列表。对于我们的例子，我们可以这样使用它：
226
find~-typef-name'foo*'-print|xargsls-l
-rwxr-xr-x1meme2242007-10-2918:44/home/me/bin/foo
-rw-r--r--1meme02008-09-1912:53/home/me/foo.txt
这里我们看到 find命令的输出被管道到 xargs命令，之后，xargs会为 ls命令构建参数列
表，然后执行 ls命令。
注意：当被放置到命令行中的参数个数相当大时，参数个数是有限制的。有可能创建的命令
太长以至于 shell不能接受。当命令行超过系统支持的最大长度时，xargs会执行带有最大参数
个数的指定命令，然后重复这个过程直到耗尽标准输入。执行带有 –show–limits选项的 xargs
命令，来查看命令行的最大值。
处理古怪的文件名
类 Unix的系统允许在文件名中嵌入空格（甚至换行符）。这就给一些程序，如
为其它程序构建参数列表的 xargs程序，造成了问题。一个嵌入的空格会被看作是
一个分隔符，生成的命令会把每个空格分离的单词解释为单独的参数。为了解决这
个问题，find命令和 xarg程序允许使用一个可选的 null字符作为参数分隔符。一
个 null字符被定义在 ASCII码中，由数字零来表示（相反的，例如，空格字符在
ASCII码中由数字 32表示）。find命令提供的 -print0行为，则会产生由 null字符
分离的输出，并且 xargs命令有一个 –null选项，这个选项会接受由 null字符分离
的输入。这里有一个例子：
find  -iname ‘*.jpg’ -print0 xargs –null ls -l
使用这项技术，我们可以保证所有文件，甚至那些文件名中包含空格的文件，都
能被正确地处理。
18.6返回操练场
到实际使用 find命令的时候了。我们将会创建一个操练场，来实践一些我们所学到的知识。
227
首先，让我们创建一个包含许多子目录和文件的操练场：
[me@linuxbox~]$mkdir-pplayground/dir-{00{1..9},0{10..99},100}
[me@linuxbox~]$touchplayground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
惊叹于命令行的强大功能！只用这两行，我们就创建了一个包含一百个子目录，每个子目录
中包含了 26个空文件的操练场。试试用 GUI来创建它！
我们用来创造这个奇迹的方法中包含一个熟悉的命令（mkdir），一个奇异的 shell扩展（花
括号）和一个新命令，touch。通过结合 mkdir命令和-p选项（导致 mkdir命令创建指定路径
的父目录），以及花括号展开，我们能够创建一百个目录。
这个 touch命令通常被用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文
件名参数是一个不存在的文件，则会创建一个空文件。
在我们的操练场中，我们创建了一百个名为 file-A的文件实例。让我们找到它们：
[me@linuxbox~]$findplayground-typef-name'file-A'
注意不同于 ls命令，find命令的输出结果是无序的。其顺序由存储设备的布局决定。为了
确定实际上我们拥有一百个此文件的实例，我们可以用这种方式来确认：
[me@linuxbox~]$findplayground-typef-name'file-A'|wc-l
下一步，让我们看一下基于文件的修改时间来查找文件。当创建备份文件或者以年代顺序
来组织文件的时候，这会很有帮助。为此，首先我们将创建一个参考文件，我们将与其比较修
改时间：
[me@linuxbox~]$touchplayground/timestamp
这个创建了一个空文件，名为 timestamp，并且把它的修改时间设置为当前时间。我们能够
验证它通过使用另一个方便的命令，stat，是一款加大马力的 ls命令版本。这个 stat命令会展
示系统对某个文件及其属性所知道的所有信息：
228
[me@linuxbox~]$statplayground/timestamp
File:'playground/timestamp'
Size:0Blocks:0IOBlock:4096regularemptyfile
Device:803h/2051dInode:14265061Links:1
Access:(0644/-rw-r--r--)Uid:(1001/me)Gid:(1001/me)
Access:2008-10-0815:15:39.000000000-0400
Modify:2008-10-0815:15:39.000000000-0400
Change:2008-10-0815:15:39.000000000-0400
如果我们再次 touch这个文件，然后用 stat命令检测它，我们会发现所有文件的时间已经
更新了。
[me@linuxbox~]$touchplayground/timestamp
[me@linuxbox~]$statplayground/timestamp
File:'playground/timestamp'
Size:0Blocks:0IOBlock:4096regularemptyfile
Device:803h/2051dInode:14265061Links:1
Access:(0644/-rw-r--r--)Uid:(1001/me)Gid:(1001/me)
Access:2008-10-0815:23:33.000000000-0400
Modify:2008-10-0815:23:33.000000000-0400
Change:2008-10-0815:23:33.000000000-0400
下一步，让我们使用 find命令来更新一些操练场中的文件：
[me@linuxbox~]$findplayground-typef-name'file-B'-exectouch'{}'';'
这会更新操练场中所有名为 file-B的文件。接下来我们会使用 find命令通过把所有文件与
参考文件 timestamp做比较，来找到已更新的文件：
[me@linuxbox~]$findplayground-typef-newerplayground/timestamp
搜索结果包含所有一百个文件 file-B的实例。因为我们在更新了文件 timestamp之后，
229
touch了操练场中名为 file-B的所有文件，所以现在它们“新于”timestamp文件，因此能被用
-newer测试条件找到。
最后，让我们回到之前那个错误权限的例子中，把它应用于操练场里：
[me@linuxbox~]$findplayground\(-typef-not-perm0600\)-or\(-typed-not-perm0700\)
这个命令列出了操练场中所有一百个目录和二百六十个文件（还有 timestamp和操练场本
身，共 2702个），因为没有一个符合我们“正确权限”的定义。通过对运算符和行为知识的了
解，我们可以给这个命令添加行为，对实战场中的文件和目录应用新的权限。
[me@linuxbox~]$findplayground\(-typef-not-perm0600-execchmod0600'{}'';'\)
-or\(-typed-not-perm0711-execchmod0700'{}'';'\)
在日常的基础上，我们可能发现运行两个命令会比较容易一些，一个操作目录，另一个操作
文件，而不是这一个长长的复合命令，但是很高兴知道，我们能这样执行命令。这里最重要的
一点是要理解怎样把操作符和行为结合起来使用，来执行有用的任务。
18.6.1选项
最后，我们有这些选项。这些选项被用来控制 find命令的搜索范围。当构建 find表达式的时
候，它们可能被其它的测试条件和行为包含，这里有一个最常被使用的选项的列表：
选项描述
-depth指示 find程序先处理目录中的文件，再处理目录自身。当
指定-delete行为时，会自动应用这个选项。
-maxdepth levels当执行测试条件和行为的时候，设置 find程序陷入目录树
的最大级别数
-mindepth levels在应用测试条件和行为之前，设置 find程序陷入目录数的
最小级别数。
-mount指示 find程序不要搜索挂载到其它文件系统上的目录。
-noleaf指示 find程序不要基于自己在搜索 Unix的文件系统的假
设，来优化它的搜索。在搜索 DOS/Windows文件系统和
CD/ROMS的时候，我们需要这个选项
表 18-7: find命令选项
230
18.7拓展阅读
•程序 locate，updatedb，find和 xargs都是 GNU项目 findutils软件包的一部分。这个
GUN项目提供了大量的在线文档，这些文档相当出色，如果你在高安全性的环境中使用
这些程序，你应该读读这些文档。
http://www.gnu.org/software/findutils/
231
19|归档和备份
计算机系统管理员的一个主要任务就是保护系统的数据安全，其中一种方法是通过时时备份系
统文件，来保护数据。即使你不是一名系统管理员，像做做拷贝或者在各个位置和设备之间移
动大量的文件，通常也是很有帮助的。在这一章中，我们将会看看几个经常用来管理文件集合
的程序。它们就是文件压缩程序：
• gzip–压缩或者展开文件
• bzip2–块排序文件压缩器
归档程序：
• tar–磁带打包工具
• zip–打包和压缩文件
还有文件同步程序：
• rsync–同步远端文件和目录
19.1压缩文件
纵观计算领域的发展历史，人们努力想把最多的数据存放到到最小的可用空间中，不管是内存，
存储设备还是网络带宽。今天我们把许多数据服务都看作是理所当然的事情，但是诸如便携式
音乐播放器，高清电视，或宽带网络之类的存在都应归功于高效的数据压缩技术。
数据压缩就是一个删除冗余数据的过程。让我们考虑一个假想的例子，比方说我们有一张
100*100像素的纯黑的图片文件。根据数据存储方案（假定每个像素占 24位，或者 3个字节），
那么这张图像将会占用 30,000个字节的存储空间：
232
100*100*3=30,000
一张单色图像包含的数据全是多余的。我们要是聪明的话，可以用这种方法来编码这些数
据，我们只要简单地描述这个事实，我们有 3万个黑色的像素数据块。所以，我们不存储包含
3万个 0（通常在图像文件中，黑色由 0来表示）的数据块，取而代之，我们把这些数据压缩
为数字 30,000，后跟一个 0，来表示我们的数据。这种数据压缩方案被称为游程编码，是一种
最基本的压缩技术。今天的技术更加先进和复杂，但是基本目标依然不变——避免多余数据。
压缩算法（数学技巧被用来执行压缩任务）分为两大类，无损压缩和有损压缩。无损压缩保
留了原始文件的所有数据。这意味着，当还原一个压缩文件的时候，还原的文件与原文件一模
一样。而另一方面，有损压缩，执行压缩操作时会删除数据，允许更大的压缩。当一个有损文
件被还原的时候，它与原文件不相匹配;相反，它是一个近似值。有损压缩的例子有 JPEG（图
像）文件和 MP3（音频）文件。在我们的讨论中，我们将看看完全无损压缩，因为计算机中的
大多数数据是不能容忍丢失任何数据的。
19.1.1gzip
这个 gzip程序被用来压缩一个或多个文件。当执行 gzip命令时，则原始文件的压缩版会替代
原始文件。相对应的 gunzip程序被用来把压缩文件复原为没有被压缩的版本。这里有个例子：
[me@linuxbox~]$ls-l/etc>foo.txt
[me@linuxbox~]$ls-lfoo.*
-rw-r--r--1meme157382008-10-1407:15foo.txt
[me@linuxbox~]$gzipfoo.txt
[me@linuxbox~]$ls-lfoo.*
-rw-r--r--1meme32302008-10-1407:15foo.txt.gz
[me@linuxbox~]$gunzipfoo.txt.gz
[me@linuxbox~]$ls-lfoo.*
-rw-r--r--1meme157382008-10-1407:15foo.txt
在这个例子里，我们创建了一个名为 foo.txt的文本文件，其内容包含一个目录的列表清
单。接下来，我们运行 gzip命令，它会把原始文件替换为一个叫做 foo.txt.gz的压缩文件。在
foo.*文件列表中，我们看到原始文件已经被压缩文件替代了，并将这个压缩文件大约是原始文
件的五分之一。我们也能看到压缩文件与原始文件有着相同的权限和时间戳。
233
接下来，我们运行 gunzip程序来解压缩文件。随后，我们能见到压缩文件已经被原始文件
替代了，同样地保留了相同的权限和时间戳。
gzip命令有许多选项。这里列出了一些：
选项说明
-c把输出写入到标准输出，并且保留原始文件。也有可能
用--stdout和--to-stdout选项来指定。
-d解压缩。正如 gunzip命令一样。也可以用--decompress或
者--uncompress选项来指定.
-f强制压缩，即使原始文件的压缩文件已经存在了，也要执
行。也可以用--force选项来指定。
-h显示用法信息。也可用--help选项来指定。
-l列出每个被压缩文件的压缩数据。也可用--list选项。
-r若命令的一个或多个参数是目录，则递归地压缩目录中的文
件。也可用--recursive选项来指定。
-t测试压缩文件的完整性。也可用--test选项来指定。
-v显示压缩过程中的信息。也可用--verbose选项来指定。
-number设置压缩指数。number是一个在 1（最快，最小压缩）到
9（最慢，最大压缩）之间的整数。数值 1和 9也可以各自
用--fast和--best选项来表示。默认值是整数 6。
表 19-1: gzip选项
返回到我们之前的例子中：
[me@linuxbox~]$gzipfoo.txt
[me@linuxbox~]$gzip-tvfoo.txt.gz
foo.txt.gz:OK
[me@linuxbox~]$gzip-dfoo.txt.gz
这里，我们用压缩文件来替代文件 foo.txt，压缩文件名为 foo.txt.gz。下一步，我们测试了
压缩文件的完整性，使用了-t和-v选项。
234
[me@linuxbox~]$ls-l/etc|gzip>foo.txt.gz
这个命令创建了一个目录列表的压缩文件。
这个 gunzip程序，会解压缩 gzip文件，假定那些文件名的扩展名是.gz，所以没有必要指
定它，只要指定的名字与现有的未压缩文件不冲突就可以：
[me@linuxbox~]$gunzipfoo.txt.gz
如果我们的目标只是为了浏览一下压缩文本文件的内容，我们可以这样做：
[me@linuxbox~]$gunzip-cfoo.txt.gz|less
另外，对应于 gzip还有一个程序，叫做 zcat，它等同于带有-c选项的 gunzip命令。它可
以被用来如 cat命令作用于 gzip压缩文件：
[me@linuxbox~]$zcatfoo.txt.gz|less
小贴士:还有一个 zless程序。它与上面的管道线有相同的功能。
19.1.2bzip2
这个 bzip2程序，由 Julian Seward开发，与 gzip程序相似，但是使用了不同的压缩算法，舍
弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 gzip。由
bzip2压缩的文件，用扩展名.bz2来表示：
235
[me@linuxbox~]$ls-l/etc>foo.txt
[me@linuxbox~]$ls-lfoo.txt
-rw-r--r--1meme157382008-10-1713:51foo.txt
[me@linuxbox~]$bzip2foo.txt
[me@linuxbox~]$ls-lfoo.txt.bz2
-rw-r--r--1meme27922008-10-1713:51foo.txt.bz2
[me@linuxbox~]$bunzip2foo.txt.bz2
正如我们所看到的，bzip2程序使用起来和 gzip程序一样。我们之前讨论的 gzip程序的所
有选项（除了-r），bzip2程序同样也支持。注意，然而，压缩级别选项（-number）对于 bzip2
程序来说，有少许不同的含义。伴随着 bzip2程序，有 bunzip2和 bzcat程序来解压缩文件。
bzip2文件也带有 bzip2recover程序，其会试图恢复受损的.bz2文件。
不要强迫性压缩
我偶然见到人们试图用高效的压缩算法，来压缩一个已经被压缩过的文件，通过
这样做：
$gzippicture.jpg
不要这样。你可能只是在浪费时间和空间！如果你再次压缩已经压缩过的文件，
实际上你会得到一个更大的文件。这是因为所有的压缩技术都会涉及一些开销，文
件中会被添加描述此次压缩过程的信息。如果你试图压缩一个已经不包含多余信息
的文件，那么再次压缩不会节省空间，以抵消额外的花费。
19.2归档文件
一个常见的，与文件压缩结合一块使用的文件管理任务是归档。归档就是收集许多文件，并把
它们捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。当把旧数据从一个系
统移到某种类型的长期存储设备中时，也会用到归档程序。
19.2.1tar
在类 Unix的软件世界中，这个 tar程序是用来归档文件的经典工具。它的名字，是 tape
archive的简称，揭示了它的根源，它是一款制作磁带备份的工具。而它仍然被用来完成传统任
务，它也同样适用于其它的存储设备。我们经常看到扩展名为.tar或者.tgz的文件，它们各自
236
表示“普通”的 tar包和被 gzip程序压缩过的 tar包。一个 tar包可以由一组独立的文件，一
个或者多个目录，或者两者混合体组成。命令语法如下：
tarmode[options]pathname...
这里的 mode是指以下操作模式（这里只展示了一部分，查看 tar的手册来得到完整列表）
之一：
模式说明
c为文件和／或目录列表创建归档文件。
x抽取归档文件。
r追加具体的路径到归档文件的末尾。
t列出归档文件的内容。
表 19-2: tar模式
tar命令使用了稍微有点奇怪的方式来表达它的选项，所以我们需要一些例子来展示它是怎
样工作的。首先，让我们重新创建之前我们用过的操练场:
[me@linuxbox~]$mkdir-pplayground/dir-{00{1..9},0{10..99},100}
[me@linuxbox~]$touchplayground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
下一步，让我们创建整个操练场的 tar包：
[me@linuxbox~]$tarcfplayground.tarplayground
这个命令创建了一个名为 playground.tar的 tar包，其包含整个 playground目录层次结
果。我们可以看到模式 c和选项 f，其被用来指定这个 tar包的名字，模式和选项可以写在一
起，而且不需要开头的短横线。注意，然而，必须首先指定模式，然后才是其它的选项。
要想列出归档文件的内容，我们可以这样做：
237
[me@linuxbox~]$tartfplayground.tar
为了得到更详细的列表信息，我们可以添加选项 v：
[me@linuxbox~]$tartvfplayground.tar
现在，抽取 tar包 playground到一个新位置。我们先创建一个名为 foo的新目录，更改目
录，然后抽取 tar包中的文件：
[me@linuxbox~]$mkdirfoo
[me@linuxbox~]$cdfoo
[me@linuxbox~]$tarxf../playground.tar
[me@linuxbox~]$ls
playground
如果我们检查/foo/playground目录中的内容，会看到这个归档文件已经被成功地安装了，
也即创建了一个精确的原始文件的副本。然而，这里有一个警告：除非你是超级用户，要不然
从归档文件中抽取的文件和目录的所有权由执行此复原操作的用户所拥有，而不属于原始所有
者。
tar命令另一个有趣的行为是它处理归档文件路径名的方式。默认情况下，路径名是相对的，
而不是绝对路径。当以相对路径创建归档文件的时候，tar命令会简单地删除路径名开头的斜
杠。为了说明问题，我们将会重新创建我们的归档文件，但是这次指定用绝对路径创建：
[me@linuxboxfoo]$cd
[me@linuxbox~]$tarcfplayground2.tar~/playground
记住，当按下回车键后，/playground会展开成 /home/me/playground，所以我们将会得
到一个绝对路径名。接下来，和之前一样我们会抽取归档文件，观察发生什么事情：
238
[me@linuxbox~]$cdfoo
[me@linuxboxfoo]$tarxf../playground2.tar
[me@linuxboxfoo]$ls
homeplayground
[me@linuxboxfoo]$lshome
me
[me@linuxboxfoo]$lshome/me
playground
这里我们看到当我们抽取第二个归档文件时，它重新创建了 home/me/playground目录，相
对于我们当前的工作目录，/foo，而不是相对于 root目录，作为带有绝对路径名的案例。这
看起来似乎是一种奇怪的工作方式，但事实上这种方式很有用，因为这样就允许我们抽取文件
到任意位置，而不是强制地把抽取的文件放置到原始目录下。加上 verbose（v）选项，重做这
个练习，将会展现更加详细的信息。
让我们考虑一个假设，tar命令的实际应用。假定我们想要复制家目录及其内容到另一个系
统中，并且有一个大容量的 USB硬盘，可以把它作为传输工具。在现代 Linux系统中，这个
硬盘会被“自动地”挂载到 /media目录下。我们也假定硬盘中有一个名为 BigDisk的逻辑卷。
为了制作 tar包，我们可以这样做：
[me@linuxbox~]$sudotarcf/media/BigDisk/home.tar/home
tar包制作完成之后，我们卸载硬盘，然后把它连接到第二个计算机上。再一次，此硬盘被
挂载到 /media/BigDisk目录下。为了抽取归档文件，我们这样做：
[me@linuxbox2~]$cd/
[me@linuxbox2/]$sudotarxf/media/BigDisk/home.tar
值得注意的一点是，因为归档文件中的所有路径名都是相对的，所以首先我们必须更改目录
到根目录下，这样抽取的文件路径就相对于根目录了。
当抽取一个归档文件时，有可能限制从归档文件中抽取什么内容。例如，如果我们想要抽取
单个文件，可以这样实现：
239
tarxfarchive.tarpathname
通过给命令添加末尾的路径名，tar命令就只会恢复指定的文件。可以指定多个路径名。注
意路径名必须是完全的，精准的相对路径名，就如存储在归档文件中的一样。当指定路径名的
时候，通常不支持通配符；然而，GNU版本的 tar命令（在 Linux发行版中最常出现）通过
--wildcards选项来支持通配符。这个例子使用了之前 playground.tar文件：
[me@linuxbox~]$cdfoo
[me@linuxboxfoo]$tarxf../playground2.tar--wildcards'home/me/playground/dir-\*/file-A'
这个命令将只会抽取匹配特定路径名的文件，路径名中包含了通配符 dir-*。
tar命令经常结合 find命令一起来制作归档文件。在这个例子里，我们将会使用 find命令
来产生一个文件集合，然后这些文件被包含到归档文件中。
[me@linuxbox~]$findplayground-name'file-A'-exectarrfplayground.tar'{}''+'
这里我们使用 find命令来匹配 playground目录中所有名为 file-A的文件，然后使用-exec
行为，来唤醒带有追加模式（r）的 tar命令，把匹配的文件添加到归档文件 playground.tar里
面。
使用 tar和 find命令，来创建逐渐增加的目录树或者整个系统的备份，是个不错的方法。
通过 find命令匹配新于某个时间戳的文件，我们就能够创建一个归档文件，其只包含新于上一
个 tar包的文件，假定这个时间戳文件恰好在每个归档文件创建之后被更新了。
tar命令也可以利用标准输出和输入。这里是一个完整的例子:
[me@linuxboxfoo]$cd
[me@linuxbox~]$findplayground-name'file-A'|tarcf---files-from=-
|gzip>playground.tgz
在这个例子里面，我们使用 find程序产生了一个匹配文件列表，然后把它们管道到 tar命令
中。如果指定了文件名“-”，则其被看作是标准输入或输出，正是所需（顺便说一下，使用“-”
240
来表示标准输入／输出的惯例，也被大量的其它程序使用）。这个 --file-from选项（也可以用
-T来指定）导致 tar命令从一个文件而不是命令行来读入它的路径名列表。最后，这个由 tar
命令产生的归档文件被管道到 gzip命令中，然后创建了压缩归档文件 playground.tgz。此.tgz
扩展名是命名由 gzip压缩的 tar文件的常规扩展名。有时候也会使用.tar.gz这个扩展名。
虽然我们使用 gzip程序来制作我们的压缩归档文件，但是现在的 GUN版本的 tar命令，
gzip和 bzip2压缩两者都直接支持，各自使用 z和 j选项。以我们之前的例子为基础，我们可
以这样简化它：
[me@linuxbox~]$findplayground-name'file-A'|tarczfplayground.tgz-T-
如果我们本要创建一个由 bzip2压缩的归档文件，我们可以这样做：
[me@linuxbox~]$findplayground-name'file-A'|tarcjfplayground.tbz-T-
通过简单地修改压缩选项，把 z改为 j（并且把输出文件的扩展名改为.tbz，来指示一个
bzip2压缩文件），就使 bzip2命令压缩生效了。另一个 tar命令与标准输入和输出的有趣使用，
涉及到在系统之间经过网络传输文件。假定我们有两台机器，每台都运行着类 Unix，且装备着
tar和 ssh工具的操作系统。在这种情景下，我们可以把一个目录从远端系统（名为 remote-sys）
传输到我们的本地系统中：
[me@linuxbox~]$mkdirremote-stuff
[me@linuxbox~]$cdremote-stuff
[me@linuxboxremote-stuff]$sshremote-sys'tarcf-Documents'|tarxf-
me@remote-sys’spassword:
[me@linuxboxremote-stuff]$ls
Documents
这里我们能够从远端系统 remote-sys中复制目录 Documents到本地系统名为 remote-stuff
目录中。我们怎样做的呢？首先，通过使用 ssh命令在远端系统中启动 tar程序。你可记得 ssh
允许我们在远程联网的计算机上执行程序，并且在本地系统中看到执行结果——远端系统中产
生的输出结果被发送到本地系统中查看。我们可以利用。在本地系统中，我们执行 tar命令，
241
19.2.2zip
这个 zip程序既是压缩工具，也是一个打包工具。这程序使用的文件格式，Windows用户比较
熟悉，因为它读取和写入.zip文件。然而，在 Linux中 gzip是主要的压缩程序，而 bzip2则位
居第二。
在 zip命令最基本的使用中，可以这样唤醒 zip命令：
zipoptionszipfilefile...
例如，制作一个 playground的 zip版本的文件包，这样做：
[me@linuxbox~]$zip-rplayground.zipplayground
除非我们包含-r选项，要不然只有 playground目录（没有任何它的内容）被存储。虽然会
自动添加.zip扩展名，但为了清晰起见，我们还是包含文件扩展名。
在创建 zip版本的文件包时，zip命令通常会显示一系列的信息：
adding:playground/dir-020/file-Z(stored0%)
adding:playground/dir-020/file-Y(stored0%)
adding:playground/dir-020/file-X(stored0%)
adding:playground/dir-087/(stored0%)
adding:playground/dir-087/file-S(stored0%)
这些信息显示了添加到文件包中每个文件的状态。zip命令会使用两种存储方法之一，来添
加文件到文件包中：要不它会“store”没有压缩的文件，正如这里所示，或者它会“deflate”文
件，执行压缩操作。在存储方法之后显示的数值表明了压缩量。因为我们的 playground目录
只是包含空文件，没有对它的内容执行压缩操作。
使用 unzip程序，来直接抽取一个 zip文件的内容。
[me@linuxbox~]$cdfoo
[me@linuxboxfoo]$unzip../playground.zip
242
对于 zip命令（与 tar命令相反）要注意一点，就是如果指定了一个已经存在的文件包，其
被更新而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。
可以列出文件或者有选择地从一个 zip文件包中抽取文件，只要给 unzip命令指定文件名：
[me@linuxbox~]$unzip-lplayground.zipplayground/dir-87/file-Z
Archive:../playground.zip
LengthDateTimeName
010-05-0809:25playground/dir-87/file-Z
01file
[me@linuxbox~]$cdfoo
[me@linuxboxfoo]$unzip./playground.zipplayground/dir-87/file-Z
Archive:../playground.zip
replaceplayground/dir-87/file-Z?[y]es,[n]o,[A]ll,[N]one,
[r]ename:y
extracting:playground/dir-87/file-Z
使用-l选项，导致 unzip命令只是列出文件包中的内容而没有抽取文件。如果没有指定文
件，unzip程序将会列出文件包中的所有文件。添加这个-v选项会增加列表的冗余信息。注意
当抽取的文件与已经存在的文件冲突时，会在替代此文件之前提醒用户。
像 tar命令一样，zip命令能够利用标准输入和输出，虽然它的实施不大有用。通过-@选
项，有可能把一系列的文件名管道到 zip命令。
[me@linuxboxfoo]$cd
[me@linuxbox~]$findplayground-name"file-A"|zip-@file-A.zip
这里我们使用 find命令产生一系列与“file-A”相匹配的文件列表，并且把此列表管道到
zip命令，然后创建包含所选文件的文件包 file-A.zip。
zip命令也支持把它的输出写入到标准输出，但是它的使用是有限的，因为很少的程序能利
用输出。不幸地是，这个 unzip程序，不接受标准输入。这就阻止了 zip和 unzip一块使用，
像 tar命令那样，来复制网络上的文件。
然而，zip命令可以接受标准输入，所以它可以被用来压缩其它程序的输出：
243
[me@linuxbox~]$ls-l/etc/|zipls-etc.zip-
adding:-(deflated80%)
在这个例子里，我们把 ls命令的输出管道到 zip命令。像 tar命令，zip命令把末尾的横杠
解释为“使用标准输入作为输入文件。”
这个 unzip程序允许它的输出发送到标准输出，当指定了-p选项之后：
[me@linuxbox~]$unzip-pls-etc.zip|less
我们讨论了一些 zip/unzip可以完成的基本操作。它们两个都有许多选项，其增加了命令的
灵活性，虽然一些选项只针对于特定的平台。zip和 unzip命令的说明手册都相当不错，并且
包含了有用的实例。然而，这些程序的主要用途是为了和 Windows系统交换文件，而不是在
Linux系统中执行压缩和打包操作，tar和 gzip程序在 Linux系统中更受欢迎。
19.3同步文件和目录
维护系统备份的常见策略是保持一个或多个目录与另一个本地系统（通常是某种可移动的存储
设备）或者远端系统中的目录（或多个目录）同步。我们可能，例如有一个正在开发的网站的
本地备份，需要时不时的与远端网络服务器中的文件备份保持同步。在类 Unix系统的世界里，
能完成此任务且备受人们喜爱的工具是 rsync。这个程序能同步本地与远端的目录，通过使用
rsync远端更新协议，此协议允许 rsync快速地检测两个目录的差异，执行最小量的复制来达
到目录间的同步。比起其它种类的复制程序，这就使 rsync命令非常快速和高效。
rsync被这样唤醒：
rsyncoptionssourcedestination
这里 source和 destination是下列选项之一：
•一个本地文件或目录
•一个远端文件或目录，以 [user@]host:path的形式存在
244
•一个远端 rsync服务器，由 rsync://[user@]host[:port]/path指定
注意 source和 destination两者之一必须是本地文件。rsync不支持远端到远端的复制
让我们试着对一些本地文件使用 rsync命令。首先，清空我们的 foo目录：
[me@linuxbox~]$rm-rffoo/*
下一步，我们将同步 playground目录和它在 foo目录中相对应的副本
[me@linuxbox~]$rsync-avplaygroundfoo
我们包括了-a选项（递归和保护文件属性）和-v选项（冗余输出），来在 foo目录中制作一
个 playground目录的镜像。当这个命令执行的时候，我们将会看到一系列的文件和目录被复
制。在最后，我们将看到一条像这样的总结信息：
sent135759bytesreceived57870bytes387258.00bytes/sec
totalsizeis3230speedupis0.02
说明复制的数量。如果我们再次运行这个命令，我们将会看到不同的结果：
[me@linuxbox~]$rsync-avplaygoundfoo
buildingfilelist...done
sent22635bytesreceived20bytes
totalsizeis3230speedupis0.14
45310.00bytes/sec
注意到没有文件列表。这是因为 rsync程序检测到在目录 /playground和 /foo/
playground之间不存在差异，因此它不需要复制任何数据。如果我们在 playground目录中修
改一个文件，然后再次运行 rsync命令：
245
[me@linuxbox~]$touchplayground/dir-099/file-Z
[me@linuxbox~]$rsync-avplaygroundfoo
buildingfilelist...done
playground/dir-099/file-Z
sent22685bytesreceived42bytes45454.00bytes/sec
totalsizeis3230speedupis0.14
我们看到 rsync命令检测到更改，并且只是复制了更新的文件。作为一个实际的例子，让我
们考虑一个假想的外部硬盘，之前我们在 tar命令中用到过的。如果我们再次把此硬盘连接到
我们的系统中，它被挂载到/media/BigDisk目录下，我们可以执行一个有用的系统备份了，首
先在外部硬盘上创建一个目录，名为/backup，然后使用 rsync程序从我们的系统中复制最重要
的数据到此外部硬盘上：
[me@linuxbox~]$mkdir/media/BigDisk/backup
[me@linuxbox~]$sudorsync-av--delete/etc/home/usr/local/media/BigDisk/backup
在这个例子里，我们把/etc，/home，和/usr/local目录从我们的系统中复制到假想的存储
设备中。我们包含了–delete这个选项，来删除可能在备份设备中已经存在但却不再存在于源设
备中的文件，（这与我们第一次创建备份无关，但是会在随后的复制操作中有用途）。挂载外部
驱动器，运行 rsync命令，不断重复这个过程，是一个不错的（虽然不理想）方式来保存少量
的系统备份文件。当然，别名会对这个操作更有帮助些。我们将会创建一个别名，并把它添加
到.bashrc文件中，来提供这个特性：
aliasbackup='sudorsync-av--delete/etc/home/usr/local/media/BigDisk/backup'
现在我们所做的事情就是连接外部驱动器，然后运行 backup命令来完成工作。
19.3.1在网络间使用rsync命令
rsync程序的真正好处之一，是它可以被用来在网络间复制文件。毕竟，rsync中的“r”象征着
“remote”。远程复制可以通过两种方法完成。第一个方法要求另一个系统已经安装了 rsync程
序，还安装了远程 shell程序，比如 ssh。比方说我们本地网络中的一个系统有大量可用的硬盘
246
空间，我们想要用远程系统来代替一个外部驱动器，来执行文件备份操作。假定远程系统中有
一个名为/backup的目录，其用来存放我们传送的文件，我们这样做：
[me@linuxbox~]$sudorsync-av--delete--rsh=ssh/etc/home/usr/localremote-sys:/backup
我们对命令做了两处修改，来方便网络间文件复制。首先，我们添加了--rsh=ssh选项，其
指示 rsync使用 ssh程序作为它的远程 shell。以这种方式，我们就能够使用一个 ssh加密通道，
把数据安全地传送到远程主机中。其次，通过在目标路径名前加上远端主机的名字（在这种情
况下，远端主机名为 remote-sys），来指定远端主机。
rsync可以被用来在网络间同步文件的第二种方式是通过使用 rsync服务器。rsync可以被
配置为一个守护进程，监听即将到来的同步请求。这样做经常是为了进行一个远程系统的镜像
操作。例如，Red Hat软件中心为它的 Fedora发行版，维护着一个巨大的正在开发中的软件
包的仓库。对于软件测试人员，在发行周期的测试阶段，定期镜像这些软件集合是非常有帮助
的。因为仓库中的这些文件会频繁地（通常每天不止一次）改动，定期同步本地镜像而不是大
量地拷贝软件仓库，这是更为明智的。这些软件库之一被维护在乔治亚理工大学；我们可以使
用本地 rsync程序和它们的 rsync服务器来镜像它。
[me@linuxbox~]$mkdirfedora-devel
[me@linuxbox~]$rsync-av-deletersync://rsync.gtlib.gatech.edu/fedora-linux-
core/development/i386/osfedora-devel
在这个例子里，我们使用了远端 rsync服务器的 URI，其由协议（rsync://），远端主机名
（rsync.gtlib.gatech.edu），和软件仓库的路径名组成。
19.4拓展阅读
•在这里讨论的所有命令的手册文档都相当清楚明白，并且包含了有用的例子。另外，GNU
版本的 tar命令有一个不错的在线文档。可以在下面链接处找到：
http://www.gnu.org/software/tar/manual/index.html
247
20|正则表达式
接下来的几章中，我们将会看一下一些用来操作文本的工具。正如我们所见到的，在类 Unix
的操作系统中，比如 Linux中，文本数据起着举足轻重的作用。但是在我们能完全理解这些工
具提供的所有功能之前，我们不得不先看看，经常与这些工具的高级使用相关联的一门技术
——正则表达式。
我们已经浏览了许多由命令行提供的功能和工具，我们遇到了一些真正神秘的 shell功能和
命令，比如 shell展开和引用、键盘快捷键和命令历史，更不用说 vi编辑器了。正则表达式延
续了这种“传统”，而且有可能（备受争议地）是这些‘神秘功能’中最神秘的那个。这并不
是说花费时间来学习它们是不值得的，而是恰恰相反。虽然它们的全部价值可能不能立即显现，
但是较强理解这些功能使我们能够表演令人惊奇的技艺。什么是正则表达式？
简而言之，正则表达式是一种符号表示法，被用来识别文本模式。在某种程度上，它们与匹
配文件和路径名的 shell通配符比较相似，但其规模更庞大。许多命令行工具和大多数的编程
语言都支持正则表达式，以此来帮助解决文本操作问题。然而，并不是所有的正则表达式都是
一样的，这就进一步混淆了事情；不同工具以及不同语言之间的正则表达式都略有差异。我们
将会限定 POSIX标准中描述的正则表达式（其包括了大多数的命令行工具），供我们讨论，与
许多编程语言（最著名的 Perl语言）相反，它们使用了更多和更丰富的符号集。
20.1grep
我们将使用的主要程序是我们的老朋友，grep程序，它会用到正则表达式。实际上，“grep”这
个名字来自于短语“global regular expression print”，所以我们能看出 grep程序和正则表达式
有关联。本质上，grep程序会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标
准输出。
到目前为止，我们已经使用 grep程序查找了固定的字符串，就像这样:
[me@linuxbox~]$ls/usr/bin|grepzip
248
这个命令会列出，位于目录 /usr/bin中，文件名中包含子字符串“zip”的所有文件。
grep程序以这样的方式来接受选项和参数：
grep[options]regex[file...]
这里的 regex是指一个正则表达式。
这是一个常用的 grep选项列表：
选项描述
-i忽略大小写。不会区分大小写字符。也可用--ignore-case来
指定。
-v不匹配。通常，grep程序会打印包含匹配项的文本行。这
个选项导致 grep程序只会打印不包含匹配项的文本行。也
可用--invert-match来指定。
-c打印匹配的数量（或者是不匹配的数目，若指定了-v选项），
而不是文本行本身。也可用--count选项来指定。
-l打印包含匹配项的文件名，而不是文本行本身，也可用--
files-with-matches选项来指定。
-L相似于-l选项，但是只是打印不包含匹配项的文件名。也可
用--files-without-match来指定。
-n在每个匹配行之前打印出其位于文件中的相应行号。也可
用--line-number选项来指定。
-h应用于多文件搜索，不输出文件名。也可用--no-filename选
项来指定。
表 20-1: grep选项
为了更好的探究 grep程序，让我们创建一些文本文件来搜寻：
[me@linuxbox~]$ls/bin>dirlist-bin.txt
[me@linuxbox~]$ls/usr/bin>dirlist-usr-bin.txt
[me@linuxbox~]$ls/sbin>dirlist-sbin.txt
[me@linuxbox~]$ls/usr/sbin>dirlist-usr-sbin.txt
[me@linuxbox~]$lsdirlist*.txt
249
dirlist-bin.txtdirlist-sbin.txtdirlist-usr-sbin.txt
dirlist-usr-bin.txt
我们能够对我们的文件列表执行简单的搜索，像这样：
[me@linuxbox~]$grepbzipdirlist*.txt
dirlist-bin.txt:bzip2
dirlist-bin.txt:bzip2recover
在这个例子里，grep程序在所有列出的文件中搜索字符串 bzip，然后找到两个匹配项，其
都在文件 dirlist-bin.txt中。如果我们只是对包含匹配项的文件列表，而不是对匹配项本身感兴
趣的话，我们可以指定-l选项：
[me@linuxbox~]$grep-lbzipdirlist*.txt
dirlist-bin.txt
相反地，如果我们只想查看不包含匹配项的文件列表，我们可以这样操作：
[me@linuxbox~]$grep-Lbzipdirlist*.txt
dirlist-sbin.txt
dirlist-usr-bin.txt
dirlist-usr-sbin.txt
20.2元字符和原义字符(MetacharactersAndLiterals)
它可能看起来不明显，但是我们的 grep程序一直使用了正则表达式，虽然是非常简单的例子。
这个正则表达式“bzip”意味着，匹配项所在行至少包含 4个字符，并且按照字符“b”、“z”、“i”
和“p”的顺序出现在匹配行的某处，字符之间没有其它的字符。字符串“bzip”中的所有字符
都是原义字符，因此它们匹配本身。除了原义字符之外，正则表达式也可能包含元字符，其被
用来指定更复杂的匹配项。正则表达式元字符由以下字符组成：
250
^$.[]{}-?*+()|\
其它所有字符都被认为是原义字符。在个别情况下，反斜杠会被用来创建元序列，元字符也
可以被转义为原义字符，而不是被解释为元字符。
注意：正如我们所见到的，当 shell执行展开的时候，许多正则表达式元字符，也是对 shell
有特殊含义的字符。当我们在命令行中传递包含元字符的正则表达式的时候，把元字符用引号
引起来至关重要，这样可以阻止 shell试图展开它们。
20.3任何字符
我们将要查看的第一个元字符是圆点字符，其被用来匹配任意字符。如果我们在正则表达式中
包含它，它将会匹配在此位置的任意一个字符。这里有个例子：
[me@linuxbox~]$grep-h'.zip'dirlist*.txt
bunzip2
bzip2
bzip2recover
gunzip
gzip
funzip
gpg-zip
preunzip
prezip
prezip-bin
unzip
unzipsfx
我们在文件中查找包含正则表达式“.zip”的文本行。对于搜索结果，有几点需要注意一下。
注意没有找到这个 zip程序。这是因为在我们的正则表达式中包含的圆点字符把所要求的匹配
项的长度增加到四个字符，并且因为字符串“zip”只包含三个字符，所以这个 zip程序不匹配。
251
另外，如果我们的文件列表中有一些文件的扩展名是.zip，则它们也会成为匹配项，因为文件扩
展名中的圆点符号也会被看作是“任意字符”。
20.4锚点
在正则表达式中，插入符号和美元符号被看作是锚点。这意味着正则表达式只有在文本行的开
头或末尾被找到时，才算发生一次匹配。
[me@linuxbox~]$grep-h'^zip'dirlist*.txt
zip
zipcloak
zipgrep
zipinfo
zipnote
zipsplit
[me@linuxbox~]$grep-h'zip$'dirlist*.txt
gunzip
gzip
funzip
gpg-zip
preunzip
prezip
unzip
zip
[me@linuxbox~]$grep-h'^zip$'dirlist*.txt
zip
这里我们分别在文件列表中搜索行首、行尾以及行首和行尾同时包含字符串“zip”（例如，
zip独占一行）的匹配行。注意正则表达式‘ˆ$’（行首和行尾之间没有字符）会匹配空行。
字谜助手
到目前为止，甚至凭借我们有限的正则表达式知识，我们已经能做些有意义的事
情了。
我妻子喜欢玩字谜游戏，有时候她会因为一个特殊的问题，而向我求助。类似这
样的问题，“一个有五个字母的单词，它的第三个字母是‘j’，最后一个字母是‘r’，
是哪个单词？”这类问题会让我动脑筋想想。
252
你知道你的 Linux系统中带有一本英文字典吗？千真万确。看一下 /usr/share/
dict目录，你就能找到一本，或几本。存储在此目录下的字典文件，其内容仅仅是
一个长长的单词列表，每行一个单词，按照字母顺序排列。在我的系统中，这个文
件仅包含 98,000个单词。为了找到可能的上述字谜的答案，我们可以这样做：
[me@linuxbox~]$grep-i'^..j.r$'/usr/share/dict/words
Major
major
使用这个正则表达式，我们能在我们的字典文件中查找到包含五个字母，且第三
个字母是“j”，最后一个字母是“r”的所有单词。
20.5中括号表达式和字符类
除了能够在正则表达式中的给定位置匹配任意字符之外，通过使用中括号表达式，我们也能够
从一个指定的字符集合中匹配单个字符。通过中括号表达式，我们能够指定一个待匹配字符集
合（包含在不加中括号的情况下会被解释为元字符的字符）。在这个例子里，使用了一个两个字
符的集合：
[me@linuxbox~]$grep-h'[bg]zip'dirlist*.txt
bzip2
bzip2recover
gzip
我们匹配包含字符串“bzip”或者“gzip”的任意行。
一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的
特殊含义。然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第
一个元字符是插入字符（ˆ），其被用来表示否定；第二个是连字符字符（-），其被用来表示一个
字符范围。
253
20.6否定
如果在中括号表示式中的第一个字符是一个插入字符（ˆ），则剩余的字符被看作是不会在给定
的字符位置出现的字符集合。通过修改之前的例子，我们试验一下：
[me@linuxbox~]$grep-h'[^bg]zip'dirlist*.txt
bunzip2
gunzip
funzip
gpg-zip
preunzip
prezip
prezip-bin
unzip
unzipsfx
通过激活否定操作，我们得到一个文件列表，它们的文件名都包含字符串“zip”，并且“zip”
的前一个字符是除了“b”和“g”之外的任意字符。注意文件 zip没有被发现。一个否定的字
符集仍然在给定位置要求一个字符，但是这个字符必须不是否定字符集的成员。
插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去
它的特殊含义，变成字符集中的一个普通字符。
20.7传统的字符区域
如果我们想要构建一个正则表达式，它可以在我们的列表中找到每个以大写字母开头的文件，
我们可以这样做：
[me@linuxbox~]$grep-h'^[ABCDEFGHIJKLMNOPQRSTUVWXZY]'dirlist*.txt
这只是一个在正则表达式中输入 26个大写字母的问题。但是输入所有字母非常令人烦恼，
所以有另外一种方式：
254
[me@linuxbox~]$grep-h'^[A-Z]'dirlist*.txt
MAKEDEV
ControlPanel
GET
HEAD
POST
X
X11
Xorg
MAKEFLOPPIES
NetworkManager
NetworkManagerDispatcher
通过使用一个三个符区域，我们能够缩写 26个字母。任意字符的区域都能按照这种方式表
达，包括多个区域，比如下面这个表达式就匹配了所有以字母和数字开头的文件名：
[me@linuxbox~]$grep-h'^[A-Za-z0-9]'dirlist*.txt
在字符区域中，我们看到这个连字符被特殊对待，所以我们怎样在一个正则表达式中包含一
个连字符呢？方法就是使连字符成为表达式中的第一个字符。考虑一下这两个例子：
[me@linuxbox~]$grep-h'[A-Z]'dirlist*.txt
这会匹配包含一个大写字母的文件名。然而：
[me@linuxbox~]$grep-h'[-AZ]'dirlist*.txt
上面的表达式会匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件
名。
20.8POSIX字符集
传统的字符区域是一个易于理解和有效的方法，用来处理快速指定字符集合的问题。不幸的是，
它们不总是工作。到目前为止，虽然我们在使用 grep程序的时候没有遇到任何问题，但是我们
255
可能在使用其它程序的时候会遭遇困难。
回到第 5章，我们看看通配符怎样被用来完成路径名展开操作。在那次讨论中，我们说过在
某种程度上，那个字符区域被使用的方式几乎与在正则表达式中的用法一样，但是有一个问题：
[me@linuxbox~]$ls/usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*
/usr/sbin/MAKEFLOPPIES
/usr/sbin/NetworkManagerDispatcher
/usr/sbin/NetworkManager
（依赖于不同的 Linux发行版，我们将得到不同的文件列表，有可能是一个空列表。这个例
子来自于 Ubuntu）这个命令产生了期望的结果——只有以大写字母开头的文件名，但是：
[me@linuxbox~]$ls/usr/sbin/[A-Z]*
/usr/sbin/biosdecode
/usr/sbin/chat
/usr/sbin/chgpasswd
/usr/sbin/chpasswd
/usr/sbin/chroot
/usr/sbin/cleanup-info
/usr/sbin/complain
/usr/sbin/console-kit-daemon
通过这个命令我们得到完全不同的结果（只列出了部分结果）。原因说来话长，简单来说就
是：
追溯到 Unix刚刚开发的时候，它只知道 ASCII字符，并且 Unix特性也如实反映了这一事
实。在 ASCII中，前 32个字符（数字 0－ 31）都是控制码（如 tabs、backspaces和回车）。
随后的 32个字符（32－ 63）包含可打印的字符，包括大多数的标点符号和数字 0到 9。再随
后的 32个字符（64－ 95）包含大写字符和一些更多的标点符号。最后的 31个字符（96－
127）包含小写字母和更多的标点符号。基于这种安排方式，使用 ASCII的系统的排序规则像
下面这样：
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
256
这个不同于正常的字典顺序，其像这样：
aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
随着 Unix系统的知名度在美国之外的国家传播开来，就需要支持不在 U.S.英语范围内的
字符。于是就扩展了这个 ASCII字符表，使用了整个 8位，添加了字符（数字 128－ 255），这
样就容纳了更多的语言。
为了支持这种功能，posix标准引入了 “locale”概念，它能针对不同地区选择合适的字符
集。：
[me@linuxbox~]$echo$LANG
en_US.UTF-8
通过这个设置，POSIX相容的应用程序将会使用字典排列顺序而不是 ASCII顺序。这就解
释了上述命令的行为。当 [A-Z]字符区域按照字典顺序解释的时候，包含除了小写字母“a”之
外的所有字母，因此得到这样的结果。
为了部分地解决这个问题，POSIX标准包含了大量的字符集，其提供了有用的字符区域。
如下表中所示：
字符集说明
[:alnum:]字母数字字符。在 ASCII中，等价于：[A-Za-z0-9]
[:word:]与 [:alnum:]相同,但增加了下划线字符。
[:alpha:]字母字符。在 ASCII中，等价于：[A-Za-z]
[:blank:]包含空格和 tab字符。
[:cntrl:] ASCII的控制码。包含了 0到 31，和 127的 ASCII字符。
[:digit:]数字 0到 9
[:graph:]可视字符。在 ASCII中，它包含 33到 126的字符。
[:lower:]小写字母。
[:punct:]标点符号字符。在 ASCII中，等价于：[-!”#$
%&’()*+,./:;<=>?@[\\\]_‘|˜]
[:print:]可打印的字符。在 [:graph:]中的所有字符，再加上空格字
符。
257
[:space:]空白字符，包括空格、tab、回车、换行、vertical tab和
form feed.在 ASCII中，等价于：[ \t\r\n\v\f]
[:upper:]大写字母。
[:xdigit:]用来表示十六进制数字的字符。在 ASCII中，等价于：
[0-9A-Fa-f]
表 20-2: POSIX字符集
甚至通过字符集，仍然没有便捷的方法来表达部分区域，比如 [A-M]。
通过使用字符集，我们重做上述的例题，看到一个改进的结果：
[me@linuxbox~]$ls/usr/sbin/[[:upper:]]*
/usr/sbin/MAKEFLOPPIES
/usr/sbin/NetworkManagerDispatcher
/usr/sbin/NetworkManager
记住，然而，这不是一个正则表达式的例子，而是 shell正在执行路径名展开操作。我们在
这里展示这个例子，是因为 POSIX规范的字符集适用于二者。
恢复到传统的排列顺序
通过改变环境变量 LANG的值，你可以选择让你的系统使用传统的（ASCII）排
列规则。如上所示，这个 LANG变量包含了语种和字符集。这个值最初由你安装
Linux系统时所选择的安装语言决定。
使用 locale命令，来查看 locale的设置。
258
[me@linuxbox~]$locale
LANG=en_US.UTF-8
LC_CTYPE="en_US.UTF-8"
LC_NUMERIC="en_US.UTF-8"
LC_TIME="en_US.UTF-8"
LC_COLLATE="en_US.UTF-8"
LC_MONETARY="en_US.UTF-8"
LC_MESSAGES="en_US.UTF-8"
LC_PAPER="en_US.UTF-8"
LC_NAME="en_US.UTF-8"
LC_ADDRESS="en_US.UTF-8"
LC_TELEPHONE="en_US.UTF-8"
LC_MEASUREMENT="en_US.UTF-8"
LC_IDENTIFICATION="en_US.UTF-8"
LC_ALL=
把这个 LANG变量设置为 POSIX，来更改 locale，使其使用传统的 Unix行为。
[me@linuxbox]$exportLANG=POSIX
注意这个改动使系统为它的字符集使用 U.S.英语（更准确地说，ASCII），所以
要确认一下这是否是你真正想要的效果。通过把这条语句添加到你的.bashrc文件
中，你可以使这个更改永久有效。
exportLANG=POSIX
259
20.9POSIX基本正则表达式与POSIX扩展正则表达式
就在我们认为这已经非常令人困惑了，我们却发现 POSIX把正则表达式的实现分成了两类：
基本正则表达式（BRE）和扩展的正则表达式（ERE）。既服从 POSIX规范又实现了 BRE的
任意应用程序，都支持我们目前研究的所有正则表达式特性。我们的 grep程序就是其中一个。
BRE和 ERE之间有什么区别呢？这是关于元字符的问题。BRE可以辨别以下元字符：
^$.[]*
其它的所有字符被认为是文本字符。ERE添加了以下元字符（以及与其相关的功能）:
(){}?+|
然而（这也是有趣的地方），在 BRE中，字符“(”，“)”，“{”，和“}”用反斜杠转义后，
被看作是元字符,相反在 ERE中，在任意元字符之前加上反斜杠会导致其被看作是一个文本字
符。在随后的讨论中将会涵盖很多奇异的特性。
因为我们将要讨论的下一个特性是 ERE的一部分，我们将要使用一个不同的 grep程序。
照惯例，一直由 egrep程序来执行这项操作，但是 GNU版本的 grep程序在使用了-E选项之
后也支持扩展的正则表达式。
在 20世纪 80年代，Unix成为一款非常流行的商业操作系统，但是到了 1988
年，Unix世界一片混乱。许多计算机制造商从 Unix的创建者 AT&T那里得到了
许可的 Unix源码，并且供应各种版本的操作系统。然而，在他们努力创造产品差
异化的同时，每个制造商都增加了专用的更改和扩展。这就开始限制了软件的兼容
性。
专有软件供应商一如既往，每个供应商都试图玩嬴游戏“锁定”他们的客户。这
个 Unix历史上的黑暗时代，就是今天众所周知的“the Balkanization”。
然后进入 IEEE（电气与电子工程师协会）时代。在上世纪 80年代中叶，IEEE
开始制定一套标准，其将会定义 Unix系统（以及类 Unix的系统）如何执行。这些
标准，正式成为 IEEE 1003，定义了应用程序编程接口（APIs），shell和一些实用
程序，其将会在标准的类 Unix操作系统中找到。“POSIX”这个名字，象征着可移
260
植的操作系统接口（为了时髦一点，添加了末尾的“X”），是由 Richard Stallman
建议的（是的，的确是 Richard Stallman），后来被 IEEE采纳。
20.10交替
我们将要讨论的扩展表达式的第一个特性叫做 alternation（交替），其是一款允许从一系列表达
式之间选择匹配项的实用程序。就像中括号表达式允许从一系列指定的字符之间匹配单个字符
那样，alternation允许从一系列字符串或者是其它的正则表达式中选择匹配项。为了说明问题，
我们将会结合 echo程序来使用 grep命令。首先，让我们试一个普通的字符串匹配：
[me@linuxbox~]$echo"AAA"|grepAAA
AAA
[me@linuxbox~]$echo"BBB"|grepAAA
[me@linuxbox~]$
一个相当直截了当的例子，我们把 echo的输出管道给 grep，然后看到输出结果。当出现一
个匹配项时，我们看到它会打印出来；当没有匹配项时，我们看到没有输出结果。
现在我们将添加 alternation，以竖杠线元字符为标记：
[me@linuxbox~]$echo"AAA"|grep-E'AAA|BBB'
AAA
[me@linuxbox~]$echo"BBB"|grep-E'AAA|BBB'
BBB
[me@linuxbox~]$echo"CCC"|grep-E'AAA|BBB'
[me@linuxbox~]$
这里我们看到正则表达式’AAA|BBB’，这意味着“匹配字符串 AAA或者是字符串 BBB”。
注意因为这是一个扩展的特性，我们给 grep命令（虽然我们能以 egrep程序来代替）添加了-E
选项，并且我们把这个正则表达式用单引号引起来，为的是阻止 shell把竖杠线元字符解释为
一个 pipe操作符。Alternation并不局限于两种选择：
261
[me@linuxbox~]$echo"AAA"|grep-E'AAA|BBB|CCC'
AAA
为了把 alternation和其它正则表达式元素结合起来，我们可以使用 ()来分离 alternation。
[me@linuxbox~]$grep-Eh'^(bz|gz|zip)'dirlist*.txt
这个表达式将会在我们的列表中匹配以“bz”，或“gz”，或“zip”开头的文件名。如果我们
删除了圆括号，这个表达式的意思：
[me@linuxbox~]$grep-Eh'^bz|gz|zip'dirlist*.txt
会变成匹配任意以“bz”开头，或包含“gz”，或包含“zip”的文件名。
20.11限定符
扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。
20.11.1?-匹配零个或一个元素
这个限定符意味着，实际上，“使前面的元素可有可无。”比方说我们想要查看一个电话号码的
真实性，如果它匹配下面两种格式的任意一种，我们就认为这个电话号码是真实的：
(nnn)nnn-nnnn
nnnnnn-nnnn
这里的“n”是一个数字。我们可以构建一个像这样的正则表达式：
^\(?[0-9][0-9][0-9]\)?[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$
262
在这个表达式中，我们在圆括号之后加上一个问号，来表示它们将被匹配零次或一次。再一
次，因为通常圆括号都是元字符（在 ERE中），所以我们在圆括号之前加上了反斜杠，使它们
成为文本字符。
让我们试一下：
[me@linuxbox~]$echo"(555)123-4567"|grep-E'^\(?[0-9][0-9][0-9]\)?[0-9][0-9][0-9]-[0-9]
[0-9][0-9][0-9]$'
(555)123-4567
[me@linuxbox~]$echo"555123-4567"|grep-E'^\(?[0-9][0-9][0-9]\)?[0-9][0-9][0-9]-[0-9]
[0-9][0-9][0-9]$'
555123-4567
[me@linuxbox~]$echo"AAA123-4567"|grep-E'^\(?[0-9][0-9][0-9]\)?[0-9][0-9][0-9]-[0-9]
[0-9][0-9][0-9]$'
[me@linuxbox~]$
这里我们看到这个表达式匹配这个电话号码的两种形式，但是不匹配包含非数字字符的号
码。
20.12*-匹配零个或多个元素
像?元字符一样，这个 *被用来表示一个可选的字符；然而，又与?不同，匹配的字符可以出
现任意多次，不仅是一次。比方说我们想要知道是否一个字符串是一句话；也就是说，字符串
开始于一个大写字母，然后包含任意多个大写和小写的字母和空格，最后以句号收尾。为了匹
配这个（非常粗略的）语句的定义，我们能够使用一个像这样的正则表达式：
[[:upper:]][[:upper:][:lower:]]*.
这个表达式由三个元素组成：一个包含 [:upper:]字符集的中括号表达式，一个包含 [:upper:]
和 [:lower:]两个字符集以及一个空格的中括号表达式，和一个被反斜杠字符转义过的圆点。第
二个元素末尾带有一个 *元字符，所以在开头的大写字母之后，可能会跟随着任意数目的大写
和小写字母和空格，并且匹配：
263
[me@linuxbox~]$echo"Thisworks."|grep-E'[[:upper:]][[:upper:][:lower:]]*\.'
Thisworks.
[me@linuxbox~]$echo"ThisWorks."|grep-E'[[:upper:]][[:upper:][:lower:]]*\.'
ThisWorks.
[me@linuxbox~]$echo"thisdoesnot"|grep-E'[[:upper:]][[:upper:][:lower:]]*\.'
[me@linuxbox~]$
这个表达式匹配前两个测试语句，但不匹配第三个，因为第三个句子缺少开头的大写字母和
末尾的句号。
20.12.1+-匹配一个或多个元素
+元字符的作用与 *非常相似，除了它要求前面的元素至少出现一次匹配。这个正则表达式只
匹配那些由一个或多个字母字符组构成的文本行，字母字符之间由单个空格分开：
^([[:alpha:]]+?)+$
[me@linuxbox~]$echo"Thisthat"|grep-E'^([[:alpha:]]+?)+$'
Thisthat
[me@linuxbox~]$echo"abc"|grep-E'^([[:alpha:]]+?)+$'
abc
[me@linuxbox~]$echo"ab9"|grep-E'^([[:alpha:]]+?)+$'
[me@linuxbox~]$echo"abcd"|grep-E'^([[:alpha:]]+?)+$'
[me@linuxbox~]$
我们看到这个正则表达式不匹配“a b 9”这一行，因为它包含了一个非字母的字符；它也不
匹配“abc d”，因为在字符“c”和“d”之间不止一个空格。
20.12.2{}-匹配特定个数的元素
{和 }元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：
限定符意思
n匹配前面的元素，如果它确切地出现了 n次。
n,m匹配前面的元素，如果它至少出现了 n次，但是不多于 m
次。
n,匹配前面的元素，如果它出现了 n次或多于 n次。
264
,m匹配前面的元素，如果它出现的次数不多于 m次。
表 20-3:指定匹配的数目
回到之前处理电话号码的例子，我们能够使用这种指定重复次数的方法来简化我们最初的
正则表达式：
^\(?[0-9][0-9][0-9]\)?[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$
简化为：
^\(?[0-9]{3}\)?[0-9]{3}-[0-9]{4}$
让我们试一下：
[me@linuxbox~]$echo"(555)123-4567"|grep-E'^\(?[0-9]{3}\)?[0-9]{3}-[0-9]{4}$'
(555)123-4567
[me@linuxbox~]$echo"555123-4567"|grep-E'^\(?[0-9]{3}\)?[0-9]{3}-[0-9]{4}$'
555123-4567
[me@linuxbox~]$echo"5555123-4567"|grep-E'^\(?[0-9]{3}\)?[0-9]{3}-[0-9]{4}$'
[me@linuxbox~]$
我们可以看到，我们修订的表达式能成功地验证带有和不带有圆括号的数字，而拒绝那些格
式不正确的数字。
20.13让正则表达式工作起来
让我们看看一些我们已经知道的命令，然后看一下它们怎样使用正则表达式。
20.13.1通过grep命令来验证一个电话簿
在我们先前的例子中，我们查看过单个电话号码，并且检查了它们的格式。一个更现实的情形
是检查一个数字列表，所以我们先创建一个列表。我们将念一个神奇的咒语到命令行中。它会
265
很神奇，因为我们还没有涵盖所涉及的大部分命令，但是不要担心。我们将在后面的章节里面
讨论那些命令。这就是那个咒语：
[me@linuxbox~]$foriin{1..10};doecho"(${RANDOM:0:3})${RANDOM:0:3}-${RANDOM:
0:4}">>phonelist.txt;done
这个命令会创建一个包含 10个电话号码的名为 phonelist.txt的文件。每次重复这个命令的
时候，另外 10个号码会被添加到这个列表中。我们也能够更改命令开头附近的数值 10，来生
成或多或少的电话号码。如果我们查看这个文件的内容，然而我们会发现一个问题：
[me@linuxbox~]$catphonelist.txt
(232)298-2265
(624)381-1078
(540)126-1980
(874)163-2885
(286)254-2860
(292)108-518
(129)44-1379
(458)273-1642
(686)299-8268
(198)307-2440
一些号码是残缺不全的，这正是我们想要的，因为我们将使用 grep命令来验证电话号码的
正确性。
一个有用的验证方法是扫描这个文件，查找无效的号码，并把搜索结果显示到屏幕上：
[me@linuxbox~]$grep-Ev'^\([0-9]{3}\)[0-9]{3}-[0-9]{4}$'phonelist.txt
(292)108-518
(129)44-1379
[me@linuxbox~]$
这里我们使用-v选项来产生相反的匹配，因此我们将只输出不匹配指定表达式的文本行。
这个表达式自身的两端都包含定位点（锚）元字符，是为了确保这个号码的两端没有多余的字
符。这个表达式也要求圆括号出现在一个有效的号码中，不同于我们先前电话号码的实例。
266
20.13.2用find查找丑陋的文件名
这个 find命令支持一个基于正则表达式的测试。当在使用正则表达式方面比较 find和 grep命
令的时候，还有一个重要问题要牢记在心。当某一行包含的字符串匹配上了一个表达式的时候，
grep命令会打印出这一行，然而 find命令要求路径名精确地匹配这个正则表达式。在下面的
例子里面，我们将使用带有一个正则表达式的 find命令，来查找每个路径名，其包含的任意字
符都不是以下字符集中的一员。
[-\_./0-9a-zA-Z]
这样一种扫描会发现包含空格和其它潜在不规范字符的路径名：
[me@linuxbox~]$find.-regex'.*[^-\_./0-9a-zA-Z].*'
由于要精确地匹配整个路径名，所以我们在表达式的两端使用了.*，来匹配零个或多个字
符。在表达式中间，我们使用了否定的中括号表达式，其包含了我们一系列可接受的路径名字
符。
20.13.3用locate查找文件
这个 locate程序支持基本的（--regexp选项）和扩展的（--regex选项）正则表达式。通过 locate
命令，我们能够执行许多与先前操作 dirlist文件时相同的操作：
[me@linuxbox~]$locate--regex'bin/(bz|gz|zip)'
/bin/bzcat
/bin/bzcmp
/bin/bzdiff
/bin/bzegrep
/bin/bzexe
/bin/bzfgrep
/bin/bzgrep
/bin/bzip2
/bin/bzip2recover
/bin/bzless
267
/bin/bzmore
/bin/gzexe
/bin/gzip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
通过使用 alternation，我们搜索包含 bin/bz，bin/gz，或/bin/zip字符串的路径名。
20.13.4在less和vim中查找文本
less和 vim两者享有相同的文本查找方法。按下/按键，然后输入正则表达式，来执行搜索任
务。如果我们使用 less程序来浏览我们的 phonelist.txt文件：
[me@linuxbox~]$lessphonelist.txt
然后查找我们有效的表达式：
(232)298-2265
(624)381-1078
(540)126-1980
(874)163-2885
(286)254-2860
(292)108-518
(129)44-1379
(458)273-1642
(686)299-8268
(198)307-2440
~
/^\([0-9]{3}\)[0-9]{3}-[0-9]{4}$
less将会高亮匹配到的字符串，这样就很容易看到无效的电话号码：
268
(232)298-2265
(624)381-1078
(540)126-1980
(874)163-2885
(286)254-2860
(292)108-518
(129)44-1379
(458)273-1642
(686)299-8268
(198)307-2440
~
(END)
另一方面，vim支持基本的正则表达式，所以我们用于搜索的表达式看起来像这样：
/([0-9]\{3\})[0-9]\{3\}-[0-9]\{4\}
我们看到表达式几乎一样；然而，在扩展表达式中，许多被认为是元字符的字符在基本的表
达式中被看作是文本字符。只有用反斜杠把它们转义之后，它们才被看作是元字符。
依赖于系统中 vim的特殊配置，匹配项将会被高亮。如若不是，试试这个命令模式：
:hlsearch
来激活搜索高亮功能。
注意：依赖于你的发行版，vim有可能支持或不支持文本搜索高亮功能。尤其是 Ubuntu自
带了一款非常简化的 vim版本。在这样的系统中，你可能要使用你的软件包管理器来安装一个
功能更完备的 vim版本。
269
20.14总结归纳
在这章中，我们已经看到几个使用正则表达式例子。如果我们使用正则表达式来搜索那些使用
正则表达式的应用程序，我们可以找到更多的使用实例。通过查找手册页，我们就能找到：
[me@linuxbox~]$cd/usr/share/man/man1
[me@linuxboxman1]$zgrep-El'regex|regularexpression'*.gz
这个 zgrep程序是 grep的前端，允许 grep来读取压缩文件。在我们的例子中，我们在手册
文件所在的目录中，搜索压缩文件中的内容。这个命令的结果是一个包含字符串“regex”或者
“regular expression”的文件列表。正如我们所看到的，正则表达式会出现在大量程序中。
基本正则表达式中有一个特性，我们没有涵盖。叫做反引用，这个特性在下一章中会被讨论
到。
20.15拓展阅读
有许多在线学习正则表达式的资源，包括各种各样的教材和速记表。
另外，关于下面的背景话题，Wikipedia有不错的文章。
• POSIX: http://en.wikipedia.org/wiki/Posix
• ASCII: http://en.wikipedia.org/wiki/Ascii
270
21|文本处理
所有类 Unix的操作系统都严重依赖于几种数据存储类型的文本文件。所以，有许多用于处理
文本的工具就说的通了。在这一章中，我们将看一些被用来“切割”文本的程序。在下一章中，
我们将查看更多的文本处理程序，但主要集中于文本格式化输出程序和其它一些人们需要的工
具。
这一章会重新拜访一些老朋友，并且会给我们介绍一些新朋友：
• cat–连接文件并且打印到标准输出
• sort–给文本行排序
• uniq–报告或者省略重复行
• cut–从每行中删除文本区域
• paste–合并文件文本行
• join–基于某个共享字段来联合两个文件的文本行
• comm–逐行比较两个有序的文件
• diff–逐行比较文件
• patch–给原始文件打补丁
• tr–翻译或删除字符
• sed–用于筛选和转换文本的流编辑器
• aspell–交互式拼写检查器
271
21.1文本应用程序
到目前为止，我们已经知道了一对文本编辑器（nano和 vim），看过一堆配置文件，并且目睹
了许多命令的输出都是文本格式。但是文本还被用来做什么？它可以做很多事情。
21.1.1文档
许多人使用纯文本格式来编写文档。虽然很容易看到一个小的文本文件对于保存简单的笔记会
很有帮助，但是也有可能用文本格式来编写大的文档。一个流行的方法是先用文本格式来编写
一个大的文档，然后使用一种标记语言来描述已完成文档的格式。许多科学论文就是用这种方
法编写的，因为基于 Unix的文本处理系统位于支持技术学科作家所需要的高级排版布局的一
流系统之列。
21.1.2网页
世界上最流行的电子文档类型可能就是网页了。网页是文本文档，它们使用 HTML（超文本标
记语言）或者是 XML（可扩展的标记语言）作为标记语言来描述文档的可视格式。
21.1.3电子邮件
从本质上来说，email是一个基于文本的媒介。为了传输，甚至非文本的附件也被转换成文本
表示形式。我们能看到这些，通过下载一个 email信息，然后用 less来浏览它。我们将会看到
这条信息开始于一个标题，其描述了信息的来源以及在传输过程中它接受到的处理，然后是信
息的正文内容。
21.1.4打印输出
在类 Unix的系统中，输出会以纯文本格式发送到打印机，或者如果页面包含图形，其会被转
换成一种文本格式的页面描述语言，以 PostScript著称，然后再被发送给一款能产生图形点阵
的程序，最后被打印出来。
21.1.5程序源码
在类 Unix系统中会发现许多命令行程序被用来支持系统管理和软件开发，并且文本处理程序
也不例外。许多文本处理程序被设计用来解决软件开发问题。文本处理对于软件开发者而言至
关重要是因为所有的软件都起始于文本格式。源代码，程序员实际编写的一部分程序，总是文
本格式。
272
21.2回顾一些老朋友
回到第 7章（重定向），我们已经知道一些命令除了接受命令行参数之外，还能够接受标准输
入。那时候我们只是简单地介绍了它们，但是现在我们将仔细地看一下它们是怎样被用来执行
文本处理的。
21.2.1cat
这个 cat程序具有许多有趣的选项。其中许多选项用来帮助更好的可视化文本内容。一个例子
是-A选项，其用来在文本中显示非打印字符。有些时候我们想知道是否控制字符嵌入到了我们
的可见文本中。最常用的控制字符是 tab字符（而不是空格）和回车字符，在 MS-DOS风格
的文本文件中回车符经常作为结束符出现。另一种常见情况是文件中包含末尾带有空格的文本
行。
让我们创建一个测试文件，用 cat程序作为一个简单的文字处理器。为此，我们将键入 cat
命令（随后指定了用于重定向输出的文件），然后输入我们的文本，最后按下 Enter键来结束
这一行，然后按下组合键 Ctrl-d，来指示 cat程序，我们已经到达文件末尾了。在这个例子中，
我们文本行的开头和末尾分别键入了一个 tab字符以及一些空格。
[me@linuxbox~]$cat>foo.txt
Thequickbrownfoxjumpedoverthelazydog.
[me@linuxbox~]$
下一步，我们将使用带有-A选项的 cat命令来显示这个文本：
[me@linuxbox~]$cat-Afoo.txt
^IThequickbrownfoxjumpedoverthelazydog.$
[me@linuxbox~]$
在输出结果中我们看到，这个 tab字符在我们的文本中由 ˆI字符来表示。这是一种常见的
表示方法，意思是“Control-I”，结果证明，它和 tab字符是一样的。我们也看到一个 $字符出
现在文本行真正的结尾处，表明我们的文本包含末尾的空格。
273
MS-DOS文本 Vs. Unix文本
可能你想用 cat程序在文本中查看非打印字符的一个原因是发现隐藏的回车符。
那么隐藏的回车符来自于哪里呢？它们来自于 DOS和 Windows！Unix和 DOS在
文本文件中定义每行结束的方式不相同。Unix通过一个换行符（ASCII 10）来结束
一行，然而 MS-DOS和它的衍生品使用回车（ASCII 13）和换行字符序列来终止每
个文本行。
有几种方法能够把文件从 DOS格式转变为 Unix格式。在许多 Linux系统中，
有两个程序叫做 dos2unix和 unix2dos，它们能在两种格式之间转变文本文件。然
而，如果你的系统中没有安装 dos2unix程序，也不要担心。文件从 DOS格式转变
为 Unix格式的过程非常简单；它只简单地涉及到删除违规的回车符。通过随后本
章中讨论的一些程序，这个工作很容易完成。
cat程序也包含用来修改文本的选项。最著名的两个选项是-n，其给文本行添加行号和-s，
禁止输出多个空白行。我们这样来说明：
[me@linuxbox~]$cat>foo.txt
Thequickbrownfox
jumpedoverthelazydog.
[me@linuxbox~]$cat-nsfoo.txt
1Thequickbrownfox
2
3jumpedoverthelazydog.
[me@linuxbox~]$
在这个例子里，我们创建了一个测试文件 foo.txt的新版本，其包含两行文本，由两个空白
行分开。经由带有-ns选项的 cat程序处理之后，多余的空白行被删除，并且对保留的文本行进
行编号。然而这并不是多个进程在操作这个文本，只有一个进程。
21.2.2sort
这个 sort程序对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序结
果发送到标准输出。使用与 cat命令相同的技巧，我们能够演示如何用 sort程序来处理标准输
入：
274
[me@linuxbox~]$sort>foo.txt
c
b
a
[me@linuxbox~]$catfoo.txt
a
b
c
输入命令之后，我们键入字母“c”，“b”，和“a”，然后再按下 Ctrl-d组合键来表示文件的
结尾。随后我们查看生成的文件，看到文本行有序地显示。
因为 sort程序能接受命令行中的多个文件作为参数，所以有可能把多个文件合并成一个有
序的文件。例如，如果我们有三个文本文件，想要把它们合并为一个有序的文件，我们可以这
样做：
sortfile1.txtfile2.txtfile3.txt>final_sorted_list.txt
sort程序有几个有趣的选项。这里只是一部分列表：
选项长选项描述
-b --ignore-leading-blanks默认情况下，对整行进行排序，从每行的第一个
字符开始。这个选项导致 sort程序忽略每行开
头的空格，从第一个非空白字符开始排序。
-f --ignore-case让排序不区分大小写。
-n --numeric-sort基于字符串的数值来排序。使用此选项允许根
据数字值执行排序，而不是字母值。
-r --reverse按相反顺序排序。结果按照降序排列，而不是
升序。
-k --key=field1[,field2]对从 field1到 field2之间的字符排序，而不是整
个文本行。看下面的讨论。
-m --merge把每个参数看作是一个预先排好序的文件。把
多个文件合并成一个排好序的文件，而没有执
行额外的排序。
275
-o --output=file把排好序的输出结果发送到文件，而不是标准
输出。
-t --field-separator=char定义域分隔字符。默认情况下，域由空格或制
表符分隔。
表 21-1:常见的 sort程序选项
虽然以上大多数选项的含义是不言自喻的，但是有些也不是。首先，让我们看一下 -n选项，
被用做数值排序。通过这个选项，有可能基于数值进行排序。我们通过对 du命令的输出结果
排序来说明这个选项，du命令可以确定最大的磁盘空间用户。通常，这个 du命令列出的输出
结果按照路径名来排序：
[me@linuxbox~]$du-s/usr/share/*|head
252/usr/share/aclocal
96/usr/share/acpi-support
8/usr/share/adduser
196/usr/share/alacarte
344/usr/share/alsa
8/usr/share/alsa-base
12488/usr/share/anthy
8/usr/share/apmd
21440/usr/share/app-install
48/usr/share/application-registry
在这个例子里面，我们把结果管道到 head命令，把输出结果限制为前 10行。我们能够产
生一个按数值排序的列表，来显示 10个最大的空间消费者：
[me@linuxbox~]$du-s/usr/share/*|sort-nr|head
509940/usr/share/locale-langpack
242660/usr/share/doc
197560/usr/share/fonts
179144/usr/share/gnome
146764/usr/share/myspell
144304/usr/share/gimp
135880/usr/share/dict
276
76508/usr/share/icons
68072/usr/share/apps
62844/usr/share/foomatic
通过使用此 -nr选项，我们产生了一个反向的数值排序，最大数值排列在第一位。这种排序
起作用是因为数值出现在每行的开头。但是如果我们想要基于文件行中的某个数值排序，又会
怎样呢？例如，命令 ls -l的输出结果：
[me@linuxbox~]$ls-l/usr/bin|head
total152948
-rwxr-xr-x1rootroot348242008-04-0402:42[
-rwxr-xr-x1rootroot1015562007-11-2706:08a2p
...
此刻，忽略 ls程序能按照文件大小对输出结果进行排序，我们也能够使用 sort程序来完成
此任务：
[me@linuxbox~]$ls-l/usr/bin|sort-nr-k5|head
-rwxr-xr-x1rootroot82342162008-04-0717:42inkscape
-rwxr-xr-x1rootroot82226922008-04-0717:42inkview
...
sort程序的许多用法都涉及到处理表格数据，例如上面 ls命令的输出结果。如果我们把数
据库这个术语应用到上面的表格中，我们会说每行是一条记录，并且每条记录由多个字段组成，
例如文件属性，链接数，文件名，文件大小等等。sort程序能够处理独立的字段。在数据库术
语中，我们能够指定一个或者多个关键字段，来作为排序的关键值。在上面的例子中，我们指
定 n和 r选项来执行相反的数值排序，并且指定 -k 5，让 sort程序使用第五字段作为排序的关
键值。
这个 k选项非常有趣，而且还有很多特点，但是首先我们需要讲讲 sort程序怎样来定义字
段。让我们考虑一个非常简单的文本文件，只有一行包含作者名字的文本。
WilliamShotts
277
默认情况下，sort程序把此行看作有两个字段。第一个字段包含字符：
和第二个字段包含字符：
意味着空白字符（空格和制表符）被当作是字段间的界定符，当执行排序时，界定符会被包
含在字段当中。再看一下 ls命令的输出，我们看到每行包含八个字段，并且第五个字段是文件
大小：
-rwxr-xr-x1rootroot82342162008-04-0717:42inkscape
让我们考虑用下面的文件，其包含从 2006年到 2008年三款流行的 Linux发行版的发行历
史，来做一系列实验。文件中的每一行都有三个字段：发行版的名称，版本号，和 MM/DD/
YYYY格式的发行日期：
SUSE10.212/07/2006
Fedora1011/25/2008
SUSE11.0406/19/2008
Ubuntu8.0404/24/2008
Fedora811/08/2007
SUSE10.310/04/2007
...
使用一个文本编辑器（可能是 vim），我们将输入这些数据，并把产生的文件命名为
distros.txt。
下一步，我们将试着对这个文件进行排序，并观察输出结果：
[me@linuxbox~]$sortdistros.txt
Fedora1011/25/2008
Fedora503/20/2006
Fedora610/24/2006
Fedora705/31/2007
Fedora811/08/2007
...
恩，大部分正确。问题出现在 Fedora的版本号上。因为在字符集中“1”出现在“5”之前，
版本号“10”在最顶端，然而版本号“9”却掉到底端。
278
为了解决这个问题，我们必须依赖多个键值来排序。我们想要对第一个字段执行字母排序，
然后对第三个字段执行数值排序。sort程序允许多个 -k选项的实例，所以可以指定多个排序
关键值。事实上，一个关键值可能包括一个字段区域。如果没有指定区域（如同之前的例子），
sort程序会使用一个键值，其始于指定的字段，一直扩展到行尾。下面是多键值排序的语法：
[me@linuxbox~]$sort--key=1,1--key=2ndistros.txt
Fedora503/20/2006
Fedora610/24/2006
Fedora705/31/2007
...
虽然为了清晰，我们使用了选项的长格式，但是 -k 1,1 -k 2n格式是等价的。在第一个 key
选项的实例中，我们指定了一个字段区域。因为我们只想对第一个字段排序，我们指定了 1,1，
意味着“始于并且结束于第一个字段。”在第二个实例中，我们指定了 2n，意味着第二个字段
是排序的键值，并且按照数值排序。一个选项字母可能被包含在一个键值说明符的末尾，其用
来指定排序的种类。这些选项字母和 sort程序的全局选项一样：b（忽略开头的空格），n（数
值排序），r（逆向排序），等等。
我们列表中第三个字段包含的日期格式不利于排序。在计算机中，日期通常设置为
YYYY-MM-DD格式，这样使按时间顺序排序变得容易，但是我们的日期为美国格式 MM/
DD/YYYY。那么我们怎样能按照时间顺序来排列这个列表呢？
幸运地是，sort程序提供了一种方式。这个 key选项允许在字段中指定偏移量，所以我们
能在字段中定义键值。
[me@linuxbox~]$sort-k3.7nbr-k3.1nbr-k3.4nbrdistros.txt
Fedora1011/25/2008
Ubuntu8.1010/30/2008
SUSE11.006/19/2008
...
通过指定 -k 3.7，我们指示 sort程序使用一个排序键值，其始于第三个字段中的第七个字
符，对应于年的开头。同样地，我们指定 -k 3.1和 -k 3.4来分离日期中的月和日。我们也添加
了 n和 r选项来实现一个逆向的数值排序。这个 b选项用来删除日期字段中开头的空格（行与
行之间的空格数迥异，因此会影响 sort程序的输出结果）。
一些文件不会使用 tabs和空格做为字段界定符；例如，这个 /etc/passwd文件：
279
[me@linuxbox~]$head/etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
这个文件的字段之间通过冒号分隔开，所以我们怎样使用一个 key字段来排序这个文件？
sort程序提供了一个 -t选项来定义分隔符。按照第七个字段（帐户的默认 shell）来排序此
passwd文件，我们可以这样做：
[me@linuxbox~]$sort-t':'-k7/etc/passwd|head
me:x:1001:1001:Myself,,,:/home/me:/bin/bash
root:x:0:0:root:/root:/bin/bash
dhcp:x:101:102::/nonexistent:/bin/false
gdm:x:106:114:GnomeDisplayManager:/var/lib/gdm:/bin/false
hplip:x:104:7:HPLIPsystemuser,,,:/var/run/hplip:/bin/false
klog:x:103:104::/home/klog:/bin/false
messagebus:x:108:119::/var/run/dbus:/bin/false
polkituser:x:110:122:PolicyKit,,,:/var/run/PolicyKit:/bin/false
pulse:x:107:116:PulseAudiodaemon,,,:/var/run/pulse:/bin/false
通过指定冒号字符做为字段分隔符，我们能按照第七个字段来排序。
21.2.3uniq
与 sort程序相比，这个 uniq程序是个轻量级程序。uniq执行一个看似琐碎的行为。当给定一
个排好序的文件（包括标准输出），uniq会删除任意重复行，并且把结果发送到标准输出。它
常常和 sort程序一块使用，来清理重复的输出。
280
uniq程序是一个传统的 Unix工具，经常与 sort程序一块使用，但是这个 GNU版本的 sort
程序支持一个 -u选项，其可以从排好序的输出结果中删除重复行。
让我们创建一个文本文件，来实验一下：
[me@linuxbox~]$cat>foo.txt
a
b
c
a
b
c
记住输入 Ctrl-d来终止标准输入。现在，如果我们对文本文件执行 uniq命令：
[me@linuxbox~]$uniqfoo.txt
a
b
c
a
b
c
输出结果与原始文件没有差异；重复行没有被删除。实际上，uniq程序能完成任务，其输
入必须是排好序的数据，
[me@linuxbox~]$sortfoo.txt|uniq
a
b
c
这是因为 uniq只会删除相邻的重复行。uniq程序有几个选项。这里是一些常用选项：
281
选项说明
-c输出所有的重复行，并且每行开头显示重复的次数。
-d只输出重复行，而不是特有的文本行。
-f n忽略每行开头的 n个字段，字段之间由空格分隔，正如 sort
程序中的空格分隔符；然而，不同于 sort程序，uniq没有
选项来设置备用的字段分隔符。
-i在比较文本行的时候忽略大小写。
-s n跳过（忽略）每行开头的 n个字符。
-u只输出独有的文本行。这是默认的。
表 21-2:常用的 uniq选项
这里我们看到 uniq被用来报告文本文件中重复行的次数，使用这个-c选项：
[me@linuxbox~]$sortfoo.txt|uniq-c
2a
2b
2c
21.3切片和切块
下面我们将要讨论的三个程序用来从文件中获得文本列，并且以有用的方式重组它们。
21.3.1cut
这个 cut程序被用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数
或者标准输入。
从文本行中指定要抽取的文本有些麻烦，使用以下选项：
选项说明
-c char_list从文本行中抽取由 char_list定义的文本。这个列表可能由
一个或多个逗号分隔开的数值区间组成。
282
-f field_list从文本行中抽取一个或多个由 field_list定义的字段。这个
列表可能包括一个或多个字段，或由逗号分隔开的字段区
间。
-d delim_char当指定-f选项之后，使用 delim_char做为字段分隔符。默
认情况下，字段之间必须由单个 tab字符分隔开。
--complement抽取整个文本行，除了那些由-c和／或-f选项指定的文本。
表 21-3: cut程序选择项
正如我们所看到的，cut程序抽取文本的方式相当不灵活。cut命令最好用来从其它程
序产生的文件中抽取文本，而不是从人们直接输入的文本中抽取。我们将会看一下我们的
distros.txt文件，看看是否它足够“整齐”成为 cut实例的一个好样本。如果我们使用带有 -A
选项的 cat命令，我们能查看是否这个文件符号由 tab字符分离字段的要求。
[me@linuxbox~]$cat-Adistros.txt
SUSE^I10.2^I12/07/2006$
Fedora^I10^I11/25/2008$
SUSE^I11.0^I06/19/2008$
Ubuntu^I8.04^I04/24/2008$
Fedora^I8^I11/08/2007$
SUSE^I10.3^I10/04/2007$
Ubuntu^I6.10^I10/26/2006$
Fedora^I7^I05/31/2007$
Ubuntu^I7.10^I10/18/2007$
Ubuntu^I7.04^I04/19/2007$
SUSE^I10.1^I05/11/2006$
Fedora^I6^I10/24/2006$
Fedora^I9^I05/13/2008$
Ubuntu^I6.06^I06/01/2006$
Ubuntu^I8.10^I10/30/2008$
Fedora^I5^I03/20/2006$
看起来不错。字段之间仅仅是单个 tab字符，没有嵌入空格。因为这个文件使用了 tab而
不是空格，我们将使用 -f选项来抽取一个字段：
283
[me@linuxbox~]$cut-f3distros.txt
12/07/2006
11/25/2008
06/19/2008
04/24/2008
11/08/2007
10/04/2007
10/26/2006
05/31/2007
10/18/2007
04/19/2007
05/11/2006
10/24/2006
05/13/2008
06/01/2006
10/30/2008
03/20/2006
因为我们的 distros文件是由 tab分隔开的，最好用 cut来抽取字段而不是字符。这是因为
一个由 tab分离的文件，每行不太可能包含相同的字符数，这就使计算每行中字符的位置变得
困难或者是不可能。在以上事例中，然而，我们已经抽取了一个字段，幸运地是其包含地日期
长度相同，所以通过从每行中抽取年份，我们能展示怎样来抽取字符：
[me@linuxbox~]$cut-f3distros.txt|cut-c7-10
2006
2008
2007
2006
2007
2006
2008
2006
2008
2006
通过对我们的列表再次运行 cut命令，我们能够抽取从位置 7到 10的字符，其对应于日期
284
字段的年份。这个 7-10表示法是一个区间的例子。cut命令手册包含了一个如何指定区间的完
整描述。
展开 Tabs
distros.txt的文件格式很适合使用 cut程序来抽取字段。但是如果我们想要 cut
程序按照字符，而不是字段来操作一个文件，那又怎样呢？这要求我们用相应数目
的空格来代替 tab字符。幸运地是，GNU的 Coreutils软件包有一个工具来解决这
个问题。这个程序名为 expand，它既可以接受一个或多个文件参数，也可以接受标
准输入，并且把修改过的文本送到标准输出。
如果我们通过 expand来处理 distros.txt文件，我们能够使用 cut -c命令来从文
件中抽取任意区间内的字符。例如，我们能够使用以下命令来从列表中抽取发行年
份，通过展开此文件，再使用 cut命令，来抽取从位置 23开始到行尾的每一个字符：
[me@linuxbox]$expanddistros.txt|cut-c23-
Coreutils软件包也提供了 unexpand程序，用 tab来代替空格。
当操作字段的时候，有可能指定不同的字段分隔符，而不是 tab字符。这里我们将会从/
etc/passwd文件中抽取第一个字段：
[me@linuxbox~]$cut-d':'-f1/etc/passwd|head
root
daemon
bin
sys
sync
games
man
lp
mail
news
使用-d选项，我们能够指定冒号做为字段分隔符。
285
21.3.2paste
这个 paste命令的功能正好与 cut相反。它会添加一个或多个文本列到文件中，而不是从文件
中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标
准输出。类似于 cut命令，paste接受多个文件参数和／或标准输入。为了说明 paste是怎样
工作的，我们将会对 distros.txt文件动手术，来产生发行版的年代表。
从我们之前使用 sort的工作中，首先我们将产生一个按照日期排序的发行版列表，并把结
果存储在一个叫做 distros-by-date.txt的文件中：
[me@linuxbox~]$sort-k3.7nbr-k3.1nbr-k3.4nbrdistros.txt>distros-by-date.txt
下一步，我们将会使用 cut命令从文件中抽取前两个字段（发行版名字和版本号），并把结
果存储到一个名为 distro-versions.txt的文件中：
[me@linuxbox~]$cut-f1,2distros-by-date.txt>distros-versions.txt
[me@linuxbox~]$headdistros-versions.txt
Fedora10
Ubuntu8.10
SUSE11.0
Fedora9
Ubuntu8.04
Fedora8
Ubuntu7.10
SUSE10.3
Fedora7
Ubuntu7.04
最后的准备步骤是抽取发行日期，并把它们存储到一个名为 distro-dates.txt文件中：
[me@linuxbox~]$cut-f3distros-by-date.txt>distros-dates.txt
[me@linuxbox~]$headdistros-dates.txt
11/25/2008
10/30/2008
06/19/2008
05/13/2008
286
04/24/2008
11/08/2007
10/18/2007
10/04/2007
05/31/2007
04/19/2007
现在我们拥有了我们所需要的文本了。为了完成这个过程，使用 paste命令来把日期列放到
发行版名字和版本号的前面，这样就创建了一个年代列表。通过使用 paste命令，然后按照期
望的顺序来安排它的参数，就能很容易完成这个任务。
[me@linuxbox~]$pastedistros-dates.txtdistros-versions.txt
11/25/2008Fedora10
10/30/2008Ubuntu8.10
06/19/2008SUSE11.0
05/13/2008Fedora9
04/24/2008Ubuntu8.04
11/08/2007Fedora8
10/18/2007Ubuntu7.10
10/04/2007SUSE10.3
05/31/2007Fedora7
04/19/2007Ubuntu7.04
21.3.3join
在某些方面，join命令类似于 paste，它会往文件中添加列，但是它使用了独特的方法来完成。
一个 join操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格
的数据结合起来，得到一个期望的结果。这个 join程序执行相同的操作。它把来自于多个基于
共享关键域的文件的数据结合起来。
为了知道在关系数据库中是怎样使用 join操作的，让我们想象一个很小的数据库，这个数
据库由两个表格组成，每个表格包含一条记录。第一个表格，叫做 CUSTOMERS，有三个数
据域：一个客户号（CUSTNUM），客户的名字（FNAME）和客户的姓（LNAME）：
CUSTNUMFNAMEME
287
===================
4681934JohnSmith
第二个表格叫做ORDERS，其包含四个数据域：订单号（ORDERNUM），客户号（CUSTNUM），
数量（QUAN），和订购的货品（ITEM）。
ORDERNUMCUSTNUMQUANITEM
=======================
301495330546819341BlueWidget
注意两个表格共享数据域 CUSTNUM。这很重要，因为它使表格之间建立了联系。
执行一个 join操作将允许我们把两个表格中的数据域结合起来，得到一个有用的结果，例
如准备一张发货单。通过使用两个表格 CUSTNUM数字域中匹配的数值，一个 join操作会产
生以下结果：
FNAMELNAMEQUANITEM
==================
JohnSmith1BlueWidget
为了说明 join程序，我们需要创建一对包含共享键值的文件。为此，我们将使用我们的
distros.txt文件。从这个文件中，我们将构建额外两个文件，一个包含发行日期（其会成为共
享键值）和发行版名称：
[me@linuxbox~]$cut-f1,1distros-by-date.txt>distros-names.txt
[me@linuxbox~]$pastedistros-dates.txtdistros-names.txt>distros-key-names.txt
[me@linuxbox~]$headdistros-key-names.txt
11/25/2008Fedora
10/30/2008Ubuntu
06/19/2008SUSE
05/13/2008Fedora
04/24/2008Ubuntu
11/08/2007Fedora
10/18/2007Ubuntu
288
10/04/2007SUSE
05/31/2007Fedora
04/19/2007Ubuntu
第二个文件包含发行日期和版本号：
[me@linuxbox~]$cut-f2,2distros-by-date.txt>distros-vernums.txt
[me@linuxbox~]$pastedistros-dates.txtdistros-vernums.txt>distros-key-vernums.txt
[me@linuxbox~]$headdistros-key-vernums.txt
11/25/200810
10/30/20088.10
06/19/200811.0
05/13/20089
04/24/20088.04
11/08/20078
10/18/20077.10
10/04/200710.3
05/31/20077
04/19/20077.04
现在我们有两个具有共享键值（“发行日期”数据域）的文件。有必要指出，为了使 join命
令能正常工作，所有文件必须按照关键数据域排序。
[me@linuxbox~]$joindistros-key-names.txtdistros-key-vernums.txt|head
11/25/2008Fedora10
10/30/2008Ubuntu8.10
06/19/2008SUSE11.0
05/13/2008Fedora9
04/24/2008Ubuntu8.04
11/08/2007Fedora8
10/18/2007Ubuntu7.10
10/04/2007SUSE10.3
05/31/2007Fedora7
04/19/2007Ubuntu7.04
289
也要注意，默认情况下，join命令使用空白字符做为输入字段的界定符，一个空格作为输出
字段的界定符。这种行为可以通过指定的选项来修改。详细信息，参考 join命令手册。
21.4比较文本
通常比较文本文件的版本很有帮助。对于系统管理员和软件开发者来说，这个尤为重要。一名
系统管理员可能，例如，需要拿现有的配置文件与先前的版本做比较，来诊断一个系统错误。
同样的，一名程序员经常需要查看程序的修改。
21.4.1comm
这个 comm程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文把行。为
了说明问题，通过使用 cat命令，我们将会创建两个内容几乎相同的文本文件：
[me@linuxbox~]$cat>file1.txt
a
b
c
d
[me@linuxbox~]$cat>file2.txt
b
c
d
e
下一步，我们将使用 comm命令来比较这两个文件：
[me@linuxbox~]$commfile1.txtfile2.txt
a
b
c
d
e
正如我们所见到的，comm命令产生了三列输出。第一列包含第一个文件独有的文本行；第
二列，文本行是第二列独有的；第三列包含两个文件共有的文本行。comm支持 -n形式的选
290
项，这里 n代表 1，2或 3。这些选项使用的时候，指定了要隐藏的列。例如，如果我们只想输
出两个文件共享的文本行，我们将隐藏第一列和第二列的输出结果：
[me@linuxbox~]$comm-12file1.txtfile2.txt
b
c
d
21.4.2diff
类似于 comm程序，diff程序被用来监测文件之间的差异。然而，diff是一款更加复杂的工具，
它支持许多输出格式，并且一次能处理许多文本文件。软件开发员经常使用 diff程序来检查不
同程序源码版本之间的更改，diff能够递归地检查源码目录，经常称之为源码树。diff程序的一
个常见用例是创建 diff文件或者补丁，它会被其它程序使用，例如 patch程序（我们一会儿讨
论），来把文件从一个版本转换为另一个版本。
如果我们使用 diff程序，来查看我们之前的文件实例：
[me@linuxbox~]$difffile1.txtfile2.txt
1d0
<a
4a4
>e
我们看到 diff程序的默认输出风格：对两个文件之间差异的简短描述。在默认格式中，每
组的更改之前都是一个更改命令，其形式为rangeoperationrange，用来描述要求更改的位置
和类型，从而把第一个文件转变为第二个文件：
改变说明
r1ar2把第二个文件中位置 r2处的文件行添加到第一个文件中的
r1处。
r1cr2用第二个文件中位置 r2处的文本行更改（替代）位置 r1处
的文本行。
r1dr2删除第一个文件中位置 r1处的文本行，这些文本行将会出
现在第二个文件中位置 r2处。
291
表 21-4: diff更改命令
在这种格式中，一个范围就是由逗号分隔开的开头行和结束行的列表。虽然这种格式是默
认情况（主要是为了服从 POSIX标准且向后与传统的 Unix diff命令兼容），但是它并不像其
它可选格式一样被广泛地使用。最流行的两种格式是上下文模式和统一模式。
当使用上下文模式（带上 -c选项），我们将看到这些：
[me@linuxbox~]$diff-cfile1.txtfile2.txt
***file1.txt2008-12-2306:40:13.000000000-0500
---file2.txt2008-12-2306:40:34.000000000-0500
***************
***1,4****
-a
b
c
d
---1,4----
b
c
d
+e
这个输出结果以两个文件名和它们的时间戳开头。第一个文件用星号做标记，第二个文件
用短横线做标记。纵观列表的其它部分，这些标记将象征它们各自代表的文件。下一步，我们
看到几组修改，包括默认的周围上下文行数。在第一组中，我们看到：
***1,4***
其表示第一个文件中从第一行到第四行的文本行。随后我们看到：
---1,4---
292
这表示第二个文件中从第一行到第四行的文本行。在更改组内，文本行以四个指示符之一
开头：
293
指示符意思
blank上下文显示行。它并不表示两个文件之间的差异。
-删除行。这一行将会出现在第一个文件中，而不是第二个文
件内。
+添加行。这一行将会出现在第二个文件内，而不是第一个文
件中。
!更改行。将会显示某个文本行的两个版本，每个版本会出现
在更改组的各自部分。
表 21-5: diff上下文模式更改指示符
这个统一模式相似于上下文模式，但是更加简洁。通过 -u选项来指定它：
[me@linuxbox~]$diff-ufile1.txtfile2.txt
---file1.txt2008-12-2306:40:13.000000000-0500
+++file2.txt2008-12-2306:40:34.000000000-0500
@@-1,4+1,4@@
-a
b
c
d
+e
上下文模式和统一模式之间最显著的差异就是重复上下文的消除，这就使得统一模式的输
出结果要比上下文模式的输出结果简短。在我们上述实例中，我们看到类似于上下文模式中的
文件时间戳，其紧紧跟随字符串 @@ -1,4 +1,4 @@。这行字符串表示了在更改组中描述的第一
个文件中的文本行和第二个文件中的文本行。这行字符串之后就是文本行本身，与三行默认的
上下文。每行以可能的三个字符中的一个开头：
字符意思
空格两个文件都包含这一行。
-在第一个文件中删除这一行。
+添加这一行到第一个文件中。
表 21-6: diff统一模式更改指示符
294
21.4.3patch
这个 patch程序被用来把更改应用到文本文件中。它接受从 diff程序的输出，并且通常被用来
把较老的文件版本转变为较新的文件版本。让我们考虑一个著名的例子。Linux内核是由一个
大型的，组织松散的贡献者团队开发而成，这些贡献者会提交固定的少量更改到源码包中。这
个 Linux内核由几百万行代码组成，虽然每个贡献者每次所做的修改相当少。对于一个贡献者
来说，每做一个修改就给每个开发者发送整个的内核源码树，这是没有任何意义的。相反，提
交一个 diff文件。一个 diff文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。
然后一个接受者使用 patch程序，把这些更改应用到他自己的源码树中。使用 diff/patch组合
提供了两个重大优点：
1.一个 diff文件非常小，与整个源码树的大小相比较而言。
2.一个 diff文件简洁地显示了所做的修改，从而允许程序补丁的审阅者能快速地评估它。
当然，diff/patch能工作于任何文本文件，不仅仅是源码文件。它同样适用于配置文件或任
意其它文本。
准备一个 diff文件供 patch程序使用，GNU文档（查看下面的拓展阅读部分）建议这样使
用 diff命令：
diff-Naurold_filenew_file>diff_file
old_file和 new_file部分不是单个文件就是包含文件的目录。这个 r选项支持递归目录树。
一旦创建了 diff文件，我们就能应用它，把旧文件修补成新文件。
patch<diff_file
我们将使用测试文件来说明：
[me@linuxbox~]$diff-Naurfile1.txtfile2.txt>patchfile.txt
[me@linuxbox~]$patch<patchfile.txt
patchingfilefile1.txt
[me@linuxbox~]$catfile1.txt
b
295
c
d
e
在这个例子中，我们创建了一个名为 patchfile.txt的 diff文件，然后使用 patch程序，来
应用这个补丁。注意我们没有必要指定一个要修补的目标文件，因为 diff文件（在统一模式中）
已经在标题行中包含了文件名。一旦应用了补丁，我们能看到，现在 file1.txt与 file2.txt文件
相匹配了。
patch程序有大量的选项，而且还有额外的实用程序可以被用来分析和编辑补丁。
21.5运行时编辑
我们对于文本编辑器的经验是它们主要是交互式的，意思是我们手动移动光标，然后输入我们
的修改。然而，也有非交互式的方法来编辑文本。有可能，例如，通过单个命令把一系列修改
应用到多个文件中。
21.5.1tr
这个 tr程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。换字是
一种把字符从一个字母转换为另一个字母的过程。例如，把小写字母转换成大写字母就是换
字。我们可以通过 tr命令来执行这样的转换，如下所示：
[me@linuxbox~]$echo"lowercaseletters"|tra-zA-Z
LOWERCASELETTERS
正如我们所见，tr命令操作标准输入，并把结果输出到标准输出。tr命令接受两个参数：要
被转换的字符集以及相对应的转换后的字符集。字符集可以用三种方式来表示：
1.一个枚举列表。例如，ABCDEFGHIJKLMNOPQRSTUVWXYZ
2.一个字符域。例如，A-Z。注意这种方法有时候面临与其它命令相同的问题，归因于语系
的排序规则，因此应该谨慎使用。
3. POSIX字符类。例如，[:upper:]
296
大多数情况下，两个字符集应该长度相同；然而，有可能第一个集合大于第二个，尤其如果
我们想要把多个字符转换为单个字符：
[me@linuxbox~]$echo"lowercaseletters"|tr[:lower:]A
AAAAAAAAAAAAAAAA
除了换字之外，tr命令能允许字符从输入流中简单地被删除。在之前的章节中，我们讨论
了转换 MS-DOS文本文件为 Unix风格文本的问题。为了执行这个转换，每行末尾的回车符需
要被删除。这个可以通过 tr命令来执行，如下所示：
tr-d'\r'<dos_file>unix_file
这里的 dos_file是需要被转换的文件，unix_file是转换后的结果。这种形式的命令使用转
义序列 \r来代表回车符。查看 tr命令所支持地完整的转义序列和字符类别列表，试试下面的
命令：
[me@linuxbox~]$tr--help
ROT13:不那么秘密的编码环
tr命令的一个有趣的用法是执行 ROT13文本编码。ROT13是一款微不足道的
基于一种简易的替换暗码的加密类型。把 ROT13称为“加密”是过誉了；称其为
“文本模糊处理”则更准确些。有时候它被用来隐藏文本中潜在的攻击内容。这个方
法就是简单地把每个字符在字母表中向前移动 13位。因为移动的位数是可能的 26
个字符的一半，所以对文本再次执行这个算法，就恢复到了它最初的形式。通过 tr
命令来执行这种编码：
echo “secret text” tr a-zA-Z n-za-mN-ZA-M
297
frperg grkg
再次执行相同的过程，得到翻译结果：
echo “frperg grkg” tr a-zA-Z n-za-mN-ZA-M
secret text
大量的 email程序和 USENET新闻读者都支持 ROT13编码。Wikipedia上面
有一篇关于这个主题的好文章：
http://en.wikipedia.org/wiki/ROT13
tr也可以完成另一个技巧。使用-s选项，tr命令能“挤压”（删除）重复的字符实例：
[me@linuxbox~]$echo"aaabbbccc"|tr-sab
abccc
这里我们有一个包含重复字符的字符串。通过给 tr命令指定字符集“ab”，我们能够消除字
符集中字母的重复实例，然而会留下不属于字符集的字符（“c”）无更改。注意重复的字符必须
是相邻的。如果它们不相邻：
[me@linuxbox~]$echo"abcabcabc"|tr-sab
abcabcabc
那么挤压会没有效果。
21.5.2sed
名字 sed是 stream editor（流编辑器）的简称。它对文本流，即一系列指定的文件或标准输入
进行编辑。sed是一款强大的，并且有些复杂的程序（有整本内容都是关于 sed程序的书籍），
所以在这里我们不会详尽的讨论它。
总之，sed的工作方式是要不给出单个编辑命令（在命令行中）要不就是包含多个命令的脚
本文件名，然后它就按行来执行这些命令。这里有一个非常简单的 sed实例：
298
[me@linuxbox~]$echo"front"|sed's/front/back/'
back
在这个例子中，我们使用 echo命令产生了一个单词的文本流，然后把它管道给 sed命令。
sed，依次，对流文本执行指令 s/front/back/，随后输出“back”。我们也能够把这个命令认为
是相似于 vi中的“替换”（查找和替代）命令。
sed中的命令开始于单个字符。在上面的例子中，这个替换命令由字母 s来代表，其后跟着
查找和替代字符串，斜杠字符做为分隔符。分隔符的选择是随意的。按照惯例，经常使用斜杠
字符，但是 sed将会接受紧随命令之后的任意字符做为分隔符。我们可以按照这种方式来执行
相同的命令：
[me@linuxbox~]$echo"front"|sed's_front_back_'
back
通过紧跟命令之后使用下划线字符，则它变成界定符。sed可以设置界定符的能力，使命令
的可读性更强，正如我们将看到的.
sed中的大多数命令之前都会带有一个地址，其指定了输入流中要被编辑的文本行。如果省
略了地址，然后会对输入流的每一行执行编辑命令。最简单的地址形式是一个行号。我们能够
添加一个地址到我们例子中：
[me@linuxbox~]$echo"front"|sed'1s/front/back/'
back
给我们的命令添加地址 1，就导致只对仅有一行文本的输入流的第一行执行替换操作。如果
我们指定另一个数字：
[me@linuxbox~]$echo"front"|sed'2s/front/back/'
front
我们看到没有执行这个编辑命令，因为我们的输入流没有第二行。地址可以用许多方式来
表达。这里是最常用的：
299
地址说明
n行号，n是一个正整数。
$最后一行。
/regexp/所有匹配一个 POSIX基本正则表达式的文本行。注意正则
表达式通过斜杠字符界定。选择性地，这个正则表达式可能
由一个备用字符界定，通过\cregexpc来指定表达式，这里
c就是一个备用的字符。
addr1,addr2从 addr1到 addr2范围内的文本行，包含地址 addr2在内。
地址可能是上述任意单独的地址形式。
first˜step匹配由数字 first代表的文本行，然后随后的每个在 step间
隔处的文本行。例如 1˜2是指每个位于奇数行号的文本行，
5˜5则指第五行和之后每五行位置的文本行。
addr1,+n匹配地址 addr1和随后的 n个文本行。
addr!匹配所有的文本行，除了 addr之外，addr可能是上述任意
的地址形式。
表 21-7: sed地址表示法
通过使用这一章中早前的 distros.txt文件，我们将演示不同种类的地址表示法。首先，一
系列行号：
[me@linuxbox~]$sed-n'1,5p'distros.txt
SUSE10.212/07/2006
Fedora1011/25/2008
SUSE11.006/19/2008
Ubuntu8.0404/24/2008
Fedora811/08/2007
在这个例子中，我们打印出一系列的文本行，开始于第一行，直到第五行。为此，我们使用
p命令，其就是简单地把匹配的文本行打印出来。然而为了高效，我们必须包含选项 -n（不自
动打印选项），让 sed不要默认地打印每一行。
下一步，我们将试用一下正则表达式：
300
[me@linuxbox~]$sed-n'/SUSE/p'distros.txt
SUSE10.212/07/2006
SUSE11.006/19/2008
SUSE10.310/04/2007
SUSE10.105/11/2006
通过包含由斜杠界定的正则表达式 \/SUSE\/，我们能够孤立出包含它的文本行，和 grep
程序的功能是相同的。
最后，我们将试着否定上面的操作，通过给这个地址添加一个感叹号：
[me@linuxbox~]$sed-n'/SUSE/!p'distros.txt
Fedora1011/25/2008
Ubuntu8.0404/24/2008
Fedora811/08/2007
Ubuntu6.1010/26/2006
Fedora705/31/2007
Ubuntu7.1010/18/2007
Ubuntu7.0404/19/2007
Fedora610/24/2006
Fedora905/13/2008
Ubuntu6.0606/01/2006
Ubuntu8.1010/30/2008
Fedora503/20/2006
这里我们看到期望的结果：输出了文件中所有的文本行，除了那些匹配这个正则表达式的文
本行。
目前为止，我们已经知道了两个 sed的编辑命令，s和 p。这里是一个更加全面的基本编辑
命令列表：
命令说明
=输出当前的行号。
a在当前行之后追加文本。
d删除当前行。
i在当前行之前插入文本。
301
p打印当前行。默认情况下，sed程序打印每一行，并且只是
编辑文件中匹配指定地址的文本行。通过指定-n选项，这
个默认的行为能够被忽略。
q退出 sed，不再处理更多的文本行。如果不指定-n选项，输
出当前行。
Q退出 sed，不再处理更多的文本行。
s/regexp/replace-只要找到一个 regexp匹配项，就替换为 replacement的内
ment/容。replacement可能包括特殊字符 &，其等价于由 regexp
匹配的文本。另外，replacement可能包含序列 \1到 \9，其
是 regexp中相对应的子表达式的内容。更多信息，查看下
面 back references部分的讨论。在 replacement末尾的斜杠
之后，可以指定一个可选的标志，来修改 s命令的行为。
y/set1/set2执行字符转写操作，通过把 set1中的字符转变为相对应的
set2中的字符。注意不同于 tr程序，sed要求两个字符集合
具有相同的长度。
表 21-8: sed基本编辑命令
到目前为止，这个 s命令是最常使用的编辑命令。我们将仅仅演示一些它的功能，通过编辑
我们的 distros.txt文件。我们以前讨论过 distros.txt文件中的日期字段不是“友好地计算机”
模式。文件中的日期格式是 MM/DD/YYYY，但如果格式是 YYYY-MM-DD会更好一些（利
于排序）。手动修改日期格式不仅浪费时间而且易出错，但是有了 sed，只需一步就能完成修改：
[me@linuxbox~]$sed's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/'distros.txt
SUSE10.22006-12-07
Fedora102008-11-25
SUSE11.02008-06-19
Ubuntu8.042008-04-24
Fedora82007-11-08
SUSE10.32007-10-04
Ubuntu6.102006-10-26
Fedora72007-05-31
Ubuntu7.102007-10-18
Ubuntu7.042007-04-19
SUSE10.12006-05-11
302
Fedora62006-10-24
Fedora92008-05-13
Ubuntu6.062006-06-01
Ubuntu8.102008-10-30
Fedora52006-03-20
哇！这个命令看起来很丑陋。但是它起作用了。仅用一步，我们就更改了文件中的日期格
式。它也是一个关于为什么有时候会开玩笑地把正则表达式称为是“只写”媒介的完美的例
子。我们能写正则表达式，但是有时候我们不能读它们。在我们恐惧地忍不住要逃离此命令之
前，让我们看一下怎样来构建它。首先，我们知道此命令有这样一个基本的结构：
sed's/regexp/replacement/'distros.txt
我们下一步是要弄明白一个正则表达式将要孤立出日期。因为日期是 MM/DD/YYYY格
式，并且出现在文本行的末尾，我们可以使用这样的表达式：
[0-9]{2}/[0-9]{2}/[0-9]{4}$
此表达式匹配两位数字，一个斜杠，两位数字，一个斜杠，四位数字，以及行尾。如此关心
regexp，那么replacement又怎样呢？为了解决此问题，我们必须介绍一个正则表达式的新
功能，它出现在一些使用 BRE的应用程序中。这个功能叫做逆参照，像这样工作：如果序列
\n出现在replacement中，这里 n是指从 1到 9的数字，则这个序列指的是在前面正则表达
式中相对应的子表达式。为了创建这个子表达式，我们简单地把它们用圆括号括起来，像这样：
([0-9]{2})/([0-9]{2})/([0-9]{4})$
现在我们有了三个子表达式。第一个表达式包含月份，第二个包含某月中的某天，以及第三
个包含年份。现在我们就可以构建replacement，如下所示：
\3-\1-\2
303
此表达式给出了年份，一个短划线，月份，一个短划线，和某天。
现在我们的命令看起来像下面这样：
sed's/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/'distros.txt
我们还有两个问题。第一个是当 sed试图解释这个 s命令的时候在我们表达式中额外的斜
杠将会使 sed迷惑。第二个是由于 sed默认情况下只接受基本的正则表达式，在表达式中的几
个字符会被当作文字字面值，而不是元字符。我们能够通过反斜杠的自由应用来转义令人不快
的字符解决这两个问题，：
sed's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/'distros.txt
你掌握了吧!
s命令的另一个功能是使用可选标志，其跟随替代字符串。一个最重要的可选标志是 g标
志，其指示 sed对某个文本行全范围地执行查找和替代操作，不仅仅是对第一个实例，这是默
认行为。这里有个例子：
[me@linuxbox~]$echo"aaabbbccc"|sed's/b/B/'
aaaBbbccc
我们看到虽然执行了替换操作，但是只针对第一个字母“b”实例，然而剩余的实例没有更
改。通过添加 g标志，我们能够更改所有的实例：
[me@linuxbox~]$echo"aaabbbccc"|sed's/b/B/g'
aaaBBBccc
目前为止，通过命令行我们只让 sed执行单个命令。使用-f选项，也有可能在一个脚本文件
中构建更加复杂的命令。为了演示，我们将使用 sed和 distros.txt文件来生成一个报告。我们
的报告以开头标题，修改过的日期，以及大写的发行版名称为特征。为此，我们需要编写一个
脚本，所以我们将打开文本编辑器，然后输入以下文字：
304
#sedscripttoproduceLinuxdistributionsreport
1i\
\
LinuxDistributionsReport\
s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
我们将把 sed脚本保存为 distros.sed文件，然后像这样运行它：
[me@linuxbox~]$sed-fdistros.seddistros.txt
LinuxDistributionsReport
SUSE10.22006-12-07
FEDORA102008-11-25
SUSE11.02008-06-19
UBUNTU8.042008-04-24
FEDORA82007-11-08
SUSE10.32007-10-04
UBUNTU6.102006-10-26
FEDORA72007-05-31
UBUNTU7.102007-10-18
UBUNTU7.042007-04-19
SUSE10.12006-05-11
FEDORA62006-10-24
FEDORA92008-05-13
正如我们所见，我们的脚本文件产生了期望的结果，但是它是如何做到的呢？让我们再看一
下我们的脚本文件。我们将使用 cat来给每行文本编号：
[me@linuxbox~]$cat-ndistros.sed
1#sedscripttoproduceLinuxdistributionsreport
2
31i\
4\
305
5LinuxDistributionsReport\
6
7s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
8y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
我们脚本文件的第一行是一条注释。如同 Linux系统中的许多配置文件和编程语言一样，
注释以 #字符开始，然后是人类可读的文本。注释可以被放到脚本中的任意地方（虽然不在命
令本身之中），且对任何可能需要理解和／或维护脚本的人们都很有帮助。
第二行是一个空行。正如注释一样，添加空白行是为了提高程序的可读性。
许多 sed命令支持行地址。这些行地址被用来指定对输入文本的哪一行执行操作。行地址
可能被表示为单独的行号，行号范围，以及特殊的行号“$”，它表示输入文本的最后一行。
从第三行到第六行所包含地文本要被插入到地址 1处，也就是输入文本的第一行中。这个
i命令之后是反斜杠回车符，来产生一个转义的回车符，或者就是所谓的连行符。这个序列能
够被用在许多环境下，包括 shell脚本，从而允许把回车符嵌入到文本流中，而没有通知解释
器（在这是指 sed解释器）已经到达了文本行的末尾。这个 i命令，同样地，命令 a（追加文
本，而不是插入文本）和 c（取代文本）命令都允许多个文本行，只要每个文本行，除了最后一
行，以一个连行符结束。实际上，脚本的第六行是插入文本的末尾，它以一个普通的回车符结
尾，而不是一个连行符，通知解释器 i命令结束了。
注意：一个连行符由一个反斜杠字符其后紧跟一个回车符组成。它们之间不允许有空白字
符。
第七行是我们的查找和替代命令。因为命令之前没有添加地址，所以输入流中的每一行文
本都得服从它的操作。
第八行执行小写字母到大写字母的字符替换操作。注意不同于 tr命令，这个 sed中的 y命
令不支持字符区域（例如，[a-z]），也不支持 POSIX字符集。再说一次，因为 y命令之前不带
地址，所以它会操作输入流的每一行。
喜欢 sed的人们也会喜欢。。。
306
sed是一款非常强大的程序，它能够针对文本流完成相当复杂的编辑任务。它最
常用于简单的行任务，而不是长长的脚本。许多用户喜欢使用其它工具，来执行较
大的工作。在这些工具中最著名的是 awk和 perl。它们不仅仅是工具，像这里介绍
的程序，且延伸到完整的编程语言领域。特别是 perl，经常被用来代替 shell脚本，
来完成许多系统管理任务，同时它也是一款非常流行网络开发语言。awk更专用一
些。其具体优点是其操作表格数据的能力。awk程序通常逐行处理文本文件，这点
类似于 sed，awk使用了一种方案，其与 sed中地址之后跟随编辑命令的概念相似。
虽然关于 awk和 perl的内容都超出了本书所讨论的范围，但是对于 Linux命令行
用户来说，它们都是非常好的技能。
21.5.3aspell
我们要查看的最后一个工具是 aspell，一款交互式的拼写检查器。这个 aspell程序是早先 ispell
程序的继承者，大多数情况下，它可以被用做一个替代品。虽然 aspell程序大多被其它需要拼
写检查能力的程序使用，但它也可以作为一个独立的命令行工具使用。它能够智能地检查各种
类型的文本文件，包括 HTML文件，C/C++程序，电子邮件和其它种类的专业文本。
拼写检查一个包含简单的文本文件，可以这样使用 aspell:
aspellchecktextfile
这里的 textfile是要检查的文件名。作为一个实际例子，让我们创建一个简单的文本文件，
叫做 foo.txt，包含一些故意的拼写错误：
[me@linuxbox~]$cat>foo.txt
Thequickbrownfoxjimpedoverthelaxydog.
下一步我们将使用 aspell来检查文件：
[me@linuxbox~]$aspellcheckfoo.txt
因为 aspell在检查模式下是交互的，我们将看到像这样的一个屏幕：
307
Thequickbrownfoxjimpedoverthelaxydog.
1)jumped6)wimped
2)gimped7)camped
3)comped8)humped
4)limped9)impede
5)pimped0)umped
i)IgnoreI)Ignoreall
r)ReplaceR)Replaceall
a)Addl)AddLower
b)Abortx)Exit
?
在显示屏的顶部，我们看到我们的文本中有一个拼写可疑且高亮显示的单词。在中间部分，
我们看到十个拼写建议，序号从 0到 9，然后是一系列其它可能的操作。最后，在最底部，我
们看到一个提示符，准备接受我们的选择。
如果我们按下 1按键，aspell会用单词“jumped”代替错误单词，然后移动到下一个拼写
错的单词，就是“laxy”。如果我们选择替代物“lazy”，aspell会替换“laxy”并且终止。一旦
aspell结束操作，我们可以检查我们的文件，会看到拼写错误的单词已经更正了。
[me@linuxbox~]$catfoo.txt
Thequickbrownfoxjumpedoverthelazydog.
除非由命令行选项 --dont-backup告诉 aspell，否则通过追加扩展名.bak到文件名中, aspell
会创建一个包含原始文本的备份文件。
为了炫耀 sed的编辑本领，我们将还原拼写错误，从而能够重用我们的文件：
[me@linuxbox~]$sed-i's/lazy/laxy/;s/jumped/jimped/'foo.txt
这个 sed选项-i，告诉 sed在适当位置编辑文件，意思是不要把编辑结果发送到标准输出
中。sed会把更改应用到文件中，以此重新编写文件。我们也看到可以把多个 sed编辑命令放
在同一行，编辑命令之间由分号分隔开来。
下一步，我们将看一下 aspell怎样来解决不同种类的文本文件。使用一个文本编辑器，例
如 vim（胆大的人可能想用 sed），我们将添加一些 HTML标志到文件中：
308
<html>
<head>
<title>MispelledHTMLfile</title>
</head>
<body>
<p>Thequickbrownfoxjimpedoverthelaxydog.</p>
</body>
</html>
现在，如果我们试图拼写检查我们修改的文件，我们会遇到一个问题。如果我们这样做：
[me@linuxbox~]$aspellcheckfoo.txt
我们会得到这些：
<html>
<head>
<title>MispelledHTMLfile</title>
</head>
<body>
<p>Thequickbrownfoxjimpedoverthelaxydog.</p>
</body>
</html>
1)HTML4)Hamel
2)html5)Hamil
3)ht-ml6)hotel
i)IgnoreI)Ignoreall
r)ReplaceR)Replaceall
a)Addl)AddLower
b)Abortx)Exit
?
aspell会认为 HTML标志的内容是拼写错误。通过包含-H（HTML）检查模式选项，这个
问题能够解决，像这样：
309
[me@linuxbox~]$aspell-Hcheckfoo.txt
这会导致这样的结果：
<html>
<head>
<title><b>Mispelled</b>HTMLfile</title>
</head>
<body>
<p>Thequickbrownfoxjimpedoverthelaxydog.</p>
</body>
</html>
1)Mispelled6)Misapplied
2)Mi-spelled7)Miscalled
3)Misspelled8)Respelled
4)Dispelled9)Misspell
5)Spelled0)Misled
i)IgnoreI)Ignoreall
r)ReplaceR)Replaceall
a)Addl)AddLower
b)Abortx)Exit
?
这个 HTML标志被忽略了，并且只会检查文件中非标志部分的内容。在这种模式下，
HTML标志的内容被忽略了，不会进行拼写检查。然而，ALT标志的内容，会被检查。
注意：默认情况下，aspell会忽略文本中的 URL和电子邮件地址。通过命令行选项，可以
重写此行为。也有可能指定哪些标志进行检查及跳过。详细内容查看 aspell命令手册。
21.6总结归纳
在这一章中，我们已经查看了一些操作文本的命令行工具。在下一章中，我们会再看几个命令
行工具。诚然，看起来不能立即显现出怎样或为什么你可能使用这些工具为日常的基本工具，
310
虽然我们已经展示了一些半实际的命令用法的例子。我们将在随后的章节中发现这些工具组成
了解决实际问题的基本工具箱。这将是确定无疑的，当我们学习 shell脚本的时候，到时候这
些工具将真正体现出它们的价值。
21.7拓展阅读
GNU项目网站包含了本章中所讨论工具的许多在线指南。
•来自 Coreutils软件包：
http://www.gnu.org/software/coreutils/manual/coreutils.html#Output-of-entire-files
http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-sorted-files
http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-fields-within-
a-line
http://www.gnu.org/software/coreutils/manual/coreutils.html#Operating-on-characters
•来自 Diffutils软件包：
http://www.gnu.org/software/diffutils/manual/html_mono/diff.html
• sed工具
http://www.gnu.org/software/sed/manual/sed.html
• aspell工具
http://aspell.net/man-html/index.html
•尤其对于 sed工具，还有很多其它的在线资源：
http://www.grymoire.com/Unix/Sed.html
http://sed.sourceforge.net/sed1line.txt
•试试用 google搜索“sed one liners”,“sed cheat sheets”关键字
21.8友情提示
有一些更有趣的文本操作命令值得。在它们之间有：split（把文件分割成碎片），csplit（基于上
下文把文件分割成碎片），和 sdiff（并排合并文件差异）。
311
22|格式化输出
在这章中，我们继续着手于文本相关的工具，关注那些用来格式化输出的程序，而不是改变文
本自身。这些工具通常让文本准备就绪打印，这是我们在下一章会提到的。我们在这章中会提
到的工具有以下这些：
• nl–添加行号
• fold–限制文件列宽
• fmt–一个简单的文本格式转换器
• pr–让文本为打印做好准备
• printf–格式化数据并打印出来
• groff–一个文件格式化系统
22.1简单的格式化工具
我们将先着眼于一些简单的格式工具。他们都是功能单一的程序，并且做法有一点单纯，但是
他们能被用于小任务并且作为脚本和管道的一部分。
22.1.1nl-添加行号
nl程序是一个相当神秘的工具，用作一个简单的任务。它添加文件的行数。在它最简单的用途
中，它相当于 cat -n:
[me@linuxbox~]$nldistros.txt|head
像 cat，nl既能接受多个文件作为命令行参数，也能接受标准输入。然而，nl有一个相当数
量的选项并支持一个简单的标记方式去允许更多复杂的方式的计算。
312
nl在计算文件行数的时候支持一个叫“逻辑页面”的概念。这允许 nl在计算的时候去重设
（再一次开始）可数的序列。用到那些选项的时候，可以设置一个特殊的开始值，并且在某个可
限定的程度上还能设置它的格式。一个逻辑页面被进一步分为 header,body和 footer这样的元
素。在每一个部分中，数行数可以被重设，并且/或被设置成另外一个格式。如果 nl同时处理
多个文件，它会把他们当成一个单一的文本流。文本流中的部分被一些相当古怪的标记的存在
加进了文本：
标记含义
\:\:\:逻辑页页眉开始处
\:\:逻辑页主体开始处
\:逻辑页页脚开始处
Table 22-1: nl标记
每一个上述的标记元素肯定在自己的行中独自出现。在处理完一个标记元素之后，nl把它
从文本流中删除。
这里有一些常用的 nl选项：
选项含义
-b style把 body按被要求方式数行，可以是以下方式：a =数所有
行
t =数非空行。这是默认设置。
n =无
pregexp =只数那些匹配了正则表达式的行
-f style将 footer按被要求设置数。默认是无
-h style将 header按被要求设置数。默认是
-i number将页面增加量设置为数字。默认是一。
-n format设置数数的格式，格式可以是：ln =左偏，没有前导零。
rn =右偏，没有前导零。
rz =右偏，有前导零。
-p不要在没一个逻辑页面的开始重设页面数。
-s string在没一个行的末尾加字符作分割符号。默认是单个的 tab。
-v number将每一个逻辑页面的第一行设置成数字。默认是一。
313
-w width将行数的宽度设置，默认是六。
表格 22-2:常用 nl选项
坦诚的说，我们大概不会那么频繁地去数行数，但是我们能用 nl去查看我们怎么将多个
工具结合在一个去完成更复杂的任务。我们将在之前章节的基础上做一个 Linux发行版的报
告。因为我们将使用 nl，包含它的 header/body/footer标记将会十分有用。我们将把它加到
上一章的 sed脚本来做这个。使用我们的文本编辑器，我们将脚本改成一下并且把它保存成
distros-nl.sed:
#sedscripttoproduceLinuxdistributionsreport
1i\
\\:\\:\\:\
\
LinuxDistributionsReport\
\
Name
Ver.Released\
----
------------\
\\:\\:
s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
$i\
\\:\
\
EndOfReport
这个脚本现在加入了 nl的逻辑页面标记并且在报告的最后加了一个 footer。记得我们在我
们的标记中必须两次使用反斜杠，因为他们通常被 sed解释成一个转义字符。
下一步，我们将结合 sort, sed, nl来生成我们改进的报告：
[me@linuxbox~]$sort-k1,1-k2ndistros.txt|sed-fdistros-nl.sed|nl
LinuxDistributionsReport
NameVer.Released
----------------
314
1Fedora52006-03-20
2Fedora62006-10-24
3Fedora72007-05-31
4Fedora82007-11-08
5Fedora92008-05-13
6Fedora102008-11-25
7SUSE10.12006-05-11
8SUSE10.22006-12-07
9SUSE10.32007-10-04
10SUSE11.02008-06-19
11Ubuntu6.062006-06-01
12Ubuntu6.102006-10-26
13Ubuntu7.042007-04-19
14Ubuntu7.102007-10-18
15Ubuntu8.042008-04-24
EndOfReport
我们的报告是一串命令的结果，首先，我们给名单按发行版本和版本号（表格 1和 2处）
进行排序，然后我们用 sed生产结果，增加了 header（包括了为 nl增加的逻辑页面标记）和
footer。最后，我们按默认用 nl生成了结果，只数了属于逻辑页面的 body部分的文本流的行
数。
我们能够重复命令并且实验不同的 nl选项。一些有趣的方式：
nl-nrz
和
nl-w3-s''
22.1.2fold-限制文件行宽
折叠是将文本的行限制到特定的宽的过程。像我们的其他命令，fold接受一个或多个文件及标
准输入。如果我们将一个简单的文本流 fold，我们可以看到它工作的方式：
315
[me@linuxbox~]$echo"Thequickbrownfoxjumpedoverthelazydog."|fold-w12
Thequickbr
ownfoxjump
edoverthe
lazydog.
这里我们看到了 fold的行为。这个用 echo命令发送的文本用 -w选项分解成块。在这个例
子中，我们设定了行宽为 12个字符。如果没有字符设置，默认是 80。注意到文本行不会因为
单词边界而不会被分解。增加的 -s选项将让 fold分解到最后可用的空白字符，即会考虑单词
边界。
[me@linuxbox~]$echo"Thequickbrownfoxjumpedoverthelazydog."
|fold-w12-s
Thequick
brownfox
jumpedover
thelazy
dog.
22.1.3fmt-一个简单的文本格式器
fmt程序同样折叠文本，外加很多功能。它接受文本或标准输入并且在文本流上格式化段落。
它主要是填充和连接文本行，同时保留空白符和缩进。
为了解释，我们将需要一些文本。让我们抄一些 fmt主页上的东西吧：
‘fmt’readsfromthespecifiedFILEarguments(orstandardinputif
nonearegiven),andwritestostandardoutput.
Bydefault,blanklines,spacesbetweenwords,andindentationare
preservedintheoutput;successiveinputlineswithdifferent
indentationarenotjoined;tabsareexpandedoninputandintroducedon
output.
‘fmt’prefersbreakinglinesattheendofasentence,andtriesto
316
avoidlinebreaksafterthefirstwordofasentenceorbeforethelast
wordofasentence.A"sentencebreak"isdefinedaseithertheendof
aparagraphorawordendinginanyof‘.?!’,followedbytwospacesor
endofline,ignoringanyinterveningparenthesesorquotes.LikeTeX,
‘fmt’readsentire“paragraphs”beforechoosinglinebreaks;the
algorithmisavariantofthatgivenbyDonaldE.KnuthandMichaelF.
Plassin“BreakingParagraphsIntoLines”,‘Software—Practice&
Experience’11,11(November1981),1119–1184.
我们将把这段文本复制进我们的文本编辑器并且保存文件名为 fmt-info.txt。现在，让我们
重新格式这个文本并且让它成为一个 50个字符宽的项目。我们能用 -w选项对文件进行处理：
[me@linuxbox~]$fmt-w50fmt-info.txt|head
'fmt'readsfromthespecifiedFILEarguments
(orstandardinputif
nonearegiven),andwritestostandardoutput.
Bydefault,blanklines,spacesbetweenwords,
andindentationare
preservedintheoutput;successiveinputlines
withdifferentindentationarenotjoined;tabs
areexpandedoninputandintroducedonoutput.
好，这真是一个奇怪的结果。大概我们应该认真的阅读这段文本，因为它恰好解释了发生了
什么：
默认情况下，输出会保留空行，单词之间的空格，和缩进；持续输入的具有不同缩进的文本
行不会连接在一起；tab字符在输入时会展开，输出时复原。
所以，fmt会保留第一行的缩进。幸运的是，fmt提供了一个选项来更正这种行为：
好多了。通过添加 -c选项，现在我们得到了所期望的结果。
fmt有一些有意思的选项：
这个 -p选项尤为有趣。通过它，我们可以格式文件选中的部分，通过在开头使用一样的符
号。很多编程语言使用锚标记（#）去提醒注释的开始，而且它可以通过这个选项来被格式。
让我们创建一个有用到注释的程序。
317
[me@linuxbox~]$cat>fmt-code.txt
#Thisfilecontainscodewithcomments.
#Thislineisacomment.
#Followedbyanothercommentline.
#Andanother.
This,ontheotherhand,isalineofcode.
Andanotherlineofcode.
Andanother.
我们的示例文件包含了用“#”开始的注释（一个 #后跟着一个空白符）和代码。现在，使
用 fmt，我们能格式注释并且不让代码被触及。
[me@linuxbox~]$fmt-w50-p'#'fmt-code.txt
#Thisfilecontainscodewithcomments.
#Thislineisacomment.Followedbyanother
#commentline.Andanother.
This,ontheotherhand,isalineofcode.
Andanotherlineofcode.
Andanother.
注意相邻的注释行被合并了，空行和非注释行被保留了。
22.1.4pr–格式化打印文本
pr程序用来把文本分页。当打印文本的时候，经常希望用几个空行在输出的页面的顶部或底部
添加空白。此外，这些空行能够用来插入到每个页面的页眉或页脚。
下面我们将演示 pr的用法。我们准备将 distros.txt这个文件分成若干张很短的页面（仅展
示前两张页面）：
[me@linuxbox~]$pr-l15-w65distros.txt
2008-12-1118:27distros.txtPage1
318
SUSE10.212/07/2006
Fedora1011/25/2008
SUSE11.006/19/2008
Ubuntu8.0404/24/2008
Fedora811/08/2007
2008-12-1118:27distros.txtPage2
SUSE10.310/04/2007
Ubuntu6.1010/26/2006
Fedora705/31/2007
Ubuntu7.1010/18/2007
Ubuntu7.0404/19/2007
在上面的例子中，我们用 -l选项（页长）和 -w选项（页宽）定义了宽 65列，长 15行的一
个“页面”。pr为 distros.txt中的内容编订页码，用空行分开各页面，生成了包含文件修改时
间、文件名、页码的默认页眉。pr指令拥有很多调整页面布局的选项，我们将在下一章中进一
步探讨。
22.1.5printf–FormatAndPrintData
与本章中的其他指令不同，printf并不用于流水线执行（不接受标准输入）。在命令行中，它也
鲜有运用（它通常被用于自动执行指令中）。所以为什么它如此重要？因为它被广泛使用。
printf (来自短语“格式化打印”“print formatted”)最初为 C语言设计，后来在包括 shell
的多种语言中运用。事实上，在 bash中, printf是内置的。printf这样工作:
printf“format”arguments
首先，发送包含有格式化描述的字符串的指令，接着，这些描述被应用于参数列表上。格式
化的结果在标准输出中显示。下面是一个小例子：
[me@linuxbox~]$printf"Iformattedthestring:%s\n"foo
Iformattedthestring:foo
319
格式字符串可能包含文字文本（如“我格式化了这个字符串：”“I formatted the string:”），
转义序列（例如\n，换行符）和以％字符开头的序列，这被称为转换规范。在上面的例子中，转
换规范％s用于格式化字符串“foo”并将其输出在命令行中。我们再来看一遍：
[me@linuxbox~]$printf"Iformatted'%s'asastring.\n"foo
Iformatted'foo'asastring.
我们可以看到，在命令行输出中，转换规范％s被字符串“foo”所替代。s转换用于格式化
字符串数据。还有其他转换符用于其他类型的数据。此表列出了常用的数据类型：
组件描述
d将数字格式化为带符号的十进制整数
f格式化并输出浮点数
o将整数格式化为八进制数
s将字符串格式化
x将整数格式化为十六进制数，必要时使用小写 a-f
X与 x相同，但变为大写
%打印%符号 (比如，指定“%%”)
表 22-5: printf转换规范组件
下面我们以字符串 “380”为例，展示每种转换符的效果。
[me@linuxbox~]$printf"%d,%f,%o,%s,%x,%X\n"380380380380380380
380,380.000000,574,380,17c,17C
由于我们指定了六个转换符，我们还必须为 printf提供六个参数进行处理。下面六个结果
展示了每个转换符的效果。可将可选组件添加到转换符以调整输出。完整的转换规范包含以下
内容：
%[flags][width][.precision]conversion_specification
320
使用多个可选组件时，必须按照上面指定的顺序，以便准确编译。以下是每个可选组件的描
述：
组件描述
flags有 5种不同的标志: #–使用“备用格式”输出。这取决于
数据类型。对于 o（八进制数）转换，输出以 0为前缀.对于
x和 X（十六进制数）转换，输出分别以 0x或 0X为前缀。
0–(零)用零填充输出。这意味着该字段将填充前导零，比
如“000380”。
-–(破折号)左对齐输出。默认情况下，printf右对齐输出。
‘’–(空格)在正数前空一格。
+–(加号)在正数前添加加号。默认情况下，printf只在负
数前添加符号。
width指定最小字段宽度的数。
.precision对于浮点数，指定小数点后的精度位数。对于字符串转换，
指定要输出的字符数。
表 22-5: printf转换规范组件
以下是不同格式的一些示例：
自变量格式结果备注
380 ”%d” 380简单格式化
整数。
380 ”%#x” 0x17c使用“替代
格式”标志
将整数格式
化为十六进
制数。
321
380 ”%05d” 00380用前导零
（padding）格
式化整数，
且最小字段
宽度为五个
字符。
380 ”%05.5f” 380.00000使用前导零
和五位小数
位精度格式
化数字为浮
点数。由于
指定的最小
字段宽度（5）
小于格式化
后数字的实
际宽度，因
此前导零这
一命令实际
上没有起到
作用。
380 ”%010.5f” 0380.00000将最小字段
宽度增加到
10，前导零
现在变得可
见。
380 ”%+d” +380使用 +标
志标记正
数。
380 ”%-d” 380使用-标志
左对齐
322
abcdefghijk ”%5s” abcedfghijk用最小字段
宽度格式化
字符串。
abcdefghijk ”%d” abcde对字符串应
用精度，它
被从中截
断。
表 22-6: print转换规范示例
再次强调，printf主要用在脚本中，用于格式化表格数据，而不是直接用于命令行。但是我
们仍然可以展示如何使用它来解决各种格式化问题。首先，我们输出一些由制表符分隔的字段：
[me@linuxbox~]$printf"%s\t%s\t%s\n"str1str2str3
str1str2str3
通过插入\t（tab的转义序列），我们实现了所需的效果。接下来，我们让一些数字的格式变
得整齐：
[me@linuxbox~]$printf"Line:%05d%15.3fResult:%+15d\n"1071
3.1415629532589
Line:010713.142Result:+32589
这显示了最小字符宽度对字符间距的影响。或者，让我们看看如何格式化一个小网页：
[me@linuxbox~]$printf"<html>\n\t<head>\n\t\t<title>%s</title>\n
\t</head>\n\t<body>\n\t\t<p>%s</p>\n\t</body>\n</html>\n""PageTit
le""PageContent"
<html>
<head>
<title>PageTitle</title>
</head>
<body>
323
<p>PageContent</p>
</body>
</html>
22.2DocumentFormattingSystems
22.3文件格式化系统
到目前为止，我们已经查看了简单的文本格式化工具。这些对于小而简单的任务是有好处的，
但更大的工作呢？Unix在技术和科学用户中流行的原因之一（除了为各种软件开发提供强大的
多任务多用户环境之外），是它提供了可用于生成许多类型文档的工具，特别是科学和学术出版
物。事实上，正如 GNU文档所描述的那样，文档准备对于 Unix的开发起到了促进作用：
UNIX的第一个版本是在位于贝尔实验室的 PDP-7上开发的。在 1971年，开发人员想要
获得 PDP-11进一步开发操作系统。为了证明这个系统的成本是合理的，他们建议为 AT＆
T专利部门创建文件格式化系统。第一个格式化程序是由 J. F. Ossanna撰写的，重新实现了
McIllroy的“roff”的。
两个文件格式化程序的主要家族占据了该领域：继承自原始 roff程序的，包括 nroff和 troff；
以及基于 Donald Knuth的 TEX（发音“tek”）排版系统。是的，中间那个掉下来的“E”是其
名称的一部分。
名称“roff”源于术语“run off”，如“I’ll run off a copy for you.”（“我将为您运行副本”）。
nroff程序用于格式化文档以输出到使用等宽字体的设备，如字符终端和打字机式打印机。在它
刚面世时，这几乎包括了所有连接在计算机上的打印设备。稍后的 troff程序格式化用于排版
机输出的文档，也就是“camera-ready”（可供拍摄成印刷版的）类型的用于商业打印的设备。
今天的大多数电脑打印机都能够模拟排版机的输出。roff家族还包括一些用于准备文档部分的
程序。这些包括 eqn（用于数学方程）和 tbl（用于表）。
TEX系统（稳定形式）首先在 1989年出现，并在某种程度上取代了 troff作为排版机输出
的首选工具。由于其复杂性（整本书都讲不完）以及在大多数现代 Linux系统上默认情况下不
安装的事实，我们不会在此讨论 TEX。
提示：对于有兴趣安装 TEX的用户，请查看大多数分发版本中可以找到的 texlive软件包，
以及 LyX图形内容编辑器。
324
22.3.1groff
groff是一套用 GNU实现 troff的程序。它还包括一个脚本，用来模仿 nroff和其他 roff家族。
roff及其后继制作格式化文档的方式对现代用户来说是相当陌生的。今天的大部分文件都是
由能够一次性完成排字和布局的文字处理器生成的。在图形文字处理器出现之前，需要两步来
生成文档。首先用文本编辑器排字，接着用诸如 troff之类的处理器来格式化。格式化程序的
说明通过标记语言的形式插入到已排好字的文本当中。类似这种过程的现代例子是网页。它首
先由某种文本编辑器排好字，然后由使用 HTML作为标记语言的 Web浏览器渲染出最终的页
面布局。
我们不会讲解 groff的全部内容，因为它的标记语言被用来处理少有人懂的排字细节。我们
将专注于其中的一个仍然广泛使用的宏包。这些宏包将低级命令转换少量高级命令，从而简化
groff的使用。
现在，我们来看一下这个简单的手册页。它位于/usr/share/man目录，是一个 gzip压缩文
本文件。解压后，我们将看到以下内容（显示了 ls手册的第 1节）：
[me@linuxbox~]$zcat/usr/share/man/man1/ls.1.gz|head
.\"DONOTMODIFYTHISFILE!Itwasgeneratedbyhelp2man1.35.
.THLS"1""April2008""GNUcoreutils6.10""UserCommands"
.SHNAME
ls\-listdirectorycontents
.SHSYNOPSIS
.Bls
[\fIOPTION\fR]...[\fIFILE\fR]...
.SHDESCRIPTION
.\"Addanyadditionaldescriptionhere
.PP
与默认手册页进行比较，我们可以开始看到标记语言与其结果之间的相关性：
[me@linuxbox~]$manls|head
LS(1)UserCommandsLS(1)
NAME
ls-listdirectorycontents
325
SYNOPSIS
ls[OPTION]...[FILE]...
令人感兴趣的原因是手册页由 groff渲染，使用 mandoc宏包。事实上，我们可以用以下流
水线来模拟 man命令：
[me@linuxbox~]$zcat/usr/share/man/man1/ls.1.gz|groff-mandoc-T
ascii|head
LS(1)UserCommandsLS(1)
NAME
ls-listdirectorycontents
SYNOPSIS
ls[OPTION]...[FILE]...
在这里，我们使用 groff程序和选项集来指定 mandoc宏程序包和 ASCII的输出驱动程序。
groff可以产生多种格式的输出。如果没有指定格式，默认情况下会输出 PostScript格式：
[me@linuxbox~]$zcat/usr/share/man/man1/ls.1.gz|groff-mandoc|
head
%!PS-Adobe-3.0
%%Creator:groffversion1.18.1
%%CreationDate:ThuFeb513:44:372009
%%DocumentNeededResources:fontTimes-Roman
%%+fontTimes-Bold
%%+fontTimes-Italic
%%DocumentSuppliedResources:procsetgrops1.181
%%Pages:4
%%PageOrder:Ascend
%%Orientation:Portrait
我们在前一章中简要介绍了 PostScript，并将在下一章中再次介绍。PostScript是一种页面
描述语言，用于将打印页面的内容描述给类似排字机的设备。如果我们输出命令并将其存储到
一个文件中（假设我们正在使用带有 Desktop目录的图形桌面）：
326
[me@linuxbox~]$zcat/usr/share/man/man1/ls.1.gz|groff-mandoc>
~/Desktop/foo.ps
输出文件的图标应该出现在桌面上。双击图标，页面查看器将启动，并显示渲染后的文件：
图 4：在 GNOME中使用页面查看器查看 PostScript输出
我们看到的是一个排版很好的 ls手册页面！事实上，可以使用以下命令将 PostScript输出
的文件转换为 PDF（便携式文档格式）文件：
[me@linuxbox~]$ps2pdf~/Desktop/foo.ps~/Desktop/ls.pdf
ps2pdf程序是 ghostscript包的一部分，它安装在大多数支持打印的 Linux系统上。
提示： Linux系统通常包含许多用于文件格式转换的命令行程序。它们通常以format2format
命名。尝试使用该命令
ls/usr/bin/*[[:alpha:]]2[[:alpha:]]*
去识别它们。同样也可以尝试搜索 formattoformat程序。
groff的最后一个练习，将再次访问我们的老朋友 distros.txt。这一次，我们将使用能够将
表格格式化的 tbl程序，来输出 Linux发行版本列表。为此，我们将使用早期的 sed脚本添加
一个文本流的标记，提供给 groff。
首先，我们需要修改我们的 sed脚本来添加 tbl所需的请求。使用文本编辑器，我们将将
distros.sed更改为以下内容：
#sedscripttoproduceLinuxdistributionsreport
1i\
.TS\
327
centerbox;\
cbss\
cbcbcb\
lnc.\
LinuxDistributionsReport\
=\
NameVersionReleased\
_
s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
$a\
.TE
请注意，为使脚本正常工作，必须注意单词“Name Version Released”由 tab分隔，而不
是空格。我们将生成的文件保存为 distros-tbl.sed. tbl使用.TS和.TE请求来启动和结束表格。
.TS请求后面的行定义了表格的全局属性，就我们的示例而言，它在页面上水平居中并含外边
框。定义的其余行描述每行的布局。现在，如果我们再次使用新的 sed脚本运行我们新的报告
生成流水线，我们将得到以下内容：
[me@linuxbox~]$sort-k1,1-k2ndistros.txt|sed-fdistros-tbl
.sed|groff-t-Tascii2>/dev/null
+------------------------------+
|LinuxDistributionsReport|
+------------------------------+
|NameVersionReleased|
+------------------------------+
|Fedora52006-03-20|
|Fedora62006-10-24|
|Fedora72007-05-31|
|Fedora82007-11-08|
|Fedora92008-05-13|
|Fedora102008-11-25|
|SUSE10.12006-05-11|
|SUSE10.22006-12-07|
|SUSE10.32007-10-04|
|SUSE11.02008-06-19|
|Ubuntu6.062006-06-01|
|Ubuntu6.102006-10-26|
328
|Ubuntu7.042007-04-19|
|Ubuntu7.102007-10-18|
|Ubuntu8.042008-04-24|
|Ubuntu8.102008-10-30|
+------------------------------+
将 -t选项添加到 groff指示它用 tbl预处理文本流。同样地，-T选项用于输出到 ASCII，
而不是默认的输出介质 PostScript。
如果仅限于终端屏幕或打字机式打印机，这样的输出格式是我们能期望的最好的。如果我
们指定 PostScript输出并以图形方式查看生成的输出，我们将得到一个更加满意的结果：
[me@linuxbox~]$sort-k1,1-k2ndistros.txt|sed-fdistros-tbl
.sed|groff-t>~/Desktop/foo.ps
图 5：查看生成的表格
22.4SummingUp
22.5小节
文本是类 Unix系统的核心特性，一定会有许多修改和格式化文本的工具。正如我们所看到的
那样，的确很多！像 fmt和 pr这种比较简单的格式化工具会在生成比较短的文件时发挥很多
用途，而 groff和其他工具则会在写书的时候用上。我们也许永远不会用命令行工具来写一篇
技术文章（尽管有很多人在这么做！），但是知道我们可以这么做也是极好的。
22.6FurtherReading
http://www.gnu.org/software/groff/manual/
http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf
http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf
http://plan9.bell-labs.com/10thEdMan/tbl.pdf
http://en.wikipedia.org/wiki/TeX
http://en.wikipedia.org/wiki/Donald_Knuth
http://en.wikipedia.org/wiki/Typesetting
329
22.7阅读更多
• groff用户指南
http://www.gnu.org/software/groff/manual/
•运用 nroff指令中的 -me选项写论文:
http://docs.freebsd.org/44doc/usd/19.memacros/paper.pdf
• -me参考手册:
http://docs.freebsd.org/44doc/usd/20.meref/paper.pdf
• Tbl–一个格式化表格的指令:
http://plan9.bell-labs.com/10thEdMan/tbl.pdf
•当然，你也可以试试下面列出的维基百科中的内容:
http://en.wikipedia.org/wiki/TeX
http://en.wikipedia.org/wiki/Donald_Knuth
http://en.wikipedia.org/wiki/Typesetting
330
23|打印
前几章我们学习了如何操控文本，下面要做的是将文本呈于纸上。在这章中，我们将会着手用
于打印文件和控制打印选项的命令行工具。通常不同发行版的打印配置各有不同且都会在其安
装时自动完成，因此这里我们不讨论打印的配置过程。本章的练习需要一台正确配置的打印机
来完成。
我们将讨论一下命令：
• pr——转换需要打印的文本文件
• lpr——打印文件
• lp——打印文件（System V）
• a2ps——为 PostScript打印机格式化文件
• lpstat——显示打印机状态信息
• lpq——显示打印机队列状态
• lprm——取消打印任务
• cancel——取消打印任务（System V）
23.1打印简史
为了较好的理解类 Unix操作系统中的打印功能，我们必须先了解一些历史。类 Unix系统中
的打印可追溯到操作系统本身的起源，那时候打印机和它的用法与今天截然不同。
23.1.1早期的打印
和计算机一样，前 PC时代的打印机都很大、很贵，并且很集中。1980年的计算机用户都是在
离电脑很远的地方用一个连接电脑的终端来工作的，而打印机就放在电脑旁并受到计算机管理
员的全方位监视。
331
由于当时打印机既昂贵又集中，而且都工作在早期的 Unix环境下，人们从实际考虑通常都
会多人共享一台打印机。为了区别不同用户的打印任务，每个打印任务的开头都会打印一张写
着用户名字的标题页，然后计算机工作人员会用推车装好当天的打印任务并分发给每个用户。
23.1.2基于字符的打印机
80年代的打印机技术有两方面的不同。首先，那时的打印机基本上都是打击式打印机。打击式
打印机使用撞针打击色带的机械结构在纸上形成字符。这种流行的技术造就了当时的菊轮式打
印和点阵式打印。
其次，更重要的是，早期打印机的特点是它使用设备内部固定的一组字符集。比如，一台
菊轮式打印机只能打印固定在其菊花轮花瓣上的字符，就这点而言打印机更像是高速打字机。
大部分打字机都使用等宽字体，意思是说每个字符的宽度相等，页面上只有固定的区域可供
打印，而这些区域只能容纳固定的字符数。大部分打印机采用横向 10字符每英寸（CPI）和
纵向 6行每英寸（LPI）的规格打印，这样一张美式信片纸就有横向 85字符宽纵向 66行高，
加上两侧的页边距，一行的最大宽度可达 80字符。据此，使用等宽字体就能提供所见即所得
（WYSIWYG，What You See Is What You Get）的打印预览。
接着，一台类打字机的打印机会收到以简单字节流的形式传送来的数据，其中就包含要打印
的字符。例如要打印一个字母 a，计算机就会发送 ASCII码 97，如果要移动打印机的滑动架和
纸张，就需要使用回车、换行、换页等的小编号 ASCII控制码。使用控制码，还能实现一些之
前受限制的字体效果，比如粗体，就是让打印机先打印一个字符，然后退格再打印一遍来得到
颜色较深的效果的。用 nroff来产生一个手册页然后用 cat -A检查输出，我们就能亲眼看看这
种效果了：
[me@linuxbox~]$zcat/usr/share/man/man1/ls.1.gz|nroff-man|cat-A|head
LS(1)UserCommandsLS(1)
$
N^HNA^HAM^HME^HE$
ls-listdirectorycontents$
$
S^HSY^HYN^HNO^HOP^HPS^HSI^HIS^HS$
l^Hls^Hs[_^HO_^HP_^HT_^HI_^HO_^HN]...[_^HF_^HI_^HL_^HE]...$
ˆH（ctrl-H）字符是用于打印粗体效果的退格符。同样，我们还可以看到用于打印下划线效
果的 [退格/下划线]序列。
332
23.1.3图形化打印机
图形用户界面（GUI）的发展催生了打印机技术中主要的变革。随着计算机的展现步入更多以
图形为基础的方式，打印技术也从基于字符走向图形化技术，这一切都是源于激光打印机的到
来，它不仅廉价，还可以在打印区域的任意位置打印微小的墨点，而不是使用固定的字符集。
这让打印机能够打印成比例的字体（像用排字机那样），甚至是图片和高质量图表。
然而，从基于字符的方式到转移到图形化的方式提出了一个严峻的技术挑战。原因如下：使
用基于字符的打印机时，填满一张纸所用的字节数可以这样计算出来（假设一张纸有 60行，每
行 80个字符)：60 × 80 = 4800字节。
相比之下，用一台 300点每英寸（DPI）分辨率的激光打印机（假设一张纸有 8乘 10英寸
的打印区域）打印则需要 (8 × 300) × (10 × 300) / 8 = 900,000字节。
当时许多慢速的个人电脑网络无法接受激光打印机打印一页需要传输将近 1兆的数据这一
点，因此，很有必要发明一种更聪明的方法。
这种发明便是页面描述语言（PDL）。PDL是一种描述页面内容的编程语言。简单的说就
是，“到这个地方，印一个 10点大小的黑体字符 a，到这个地方。。。”这样直到页面上的所有
内容都描述完了。第一种主要的 PDL是 Adobe系统开发的 PostScript，直到今天，这种语言
仍被广泛使用。PostScript是专为印刷各类图形和图像设计的完整的编程语言，它内建支持 35
种标准的高质量字体，在工作时还能够接受其他的字体定义。最早，对 PostScript的支持是打
印机本身内建的。这样传输数据的问题就解决了。相比基于字符打印机的简单字节流，典型的
PostScript程序更为详细，而且比表示整个页面的字节数要小很多。
一台 PostScript打印机接受 PostScript程序作为输入。打印机有自己的处理器和内存（通
常这让打印机比连接它的计算机更为强大），能执行一种叫做 PostScript解析器的特殊程序用
于读取输入的 PostScript程序并生成结果导入打印机的内存，这样就形成了要转移到纸上的位
（点）图。这种将页面渲染成大型位图（bitmap）的过程有个通用名称作光栅图像处理器（raster
image processor），又叫 RIP。
多年之后，电脑和网络都变得更快了。这使得 RIP技术从打印机转移到了主机上，还让高
品质打印机变得更便宜了。
现在的许多打印机仍能接受基于字符的字节流，但很多廉价的打印机却不支持，因为它们依
赖于主机的 RIP提供的比特流来作为点阵打印。当然也有不少仍旧是 PostScript打印机。
23.2在Linux下打印
当前 Linux系统采用两套软件配合显示和管理打印。第一，CUPS（Common Unix Printing
System，一般 Unix打印系统），用于提供打印驱动和打印任务管理；第二，Ghostscript，一种
333
PostScript解析器，作为 RIP使用。
CUPS通过创建并维护打印队列来管理打印机。如前所述，Unix下的打印原本是设计成多
用户共享中央打印机的管理模式的。由于打印机本身比连接到它的电脑要慢，打印系统就需要
对打印任务进行调度使其保持顺序。CUPS还能识别出不同类型的数据（在合理范围内）并转
换文件为可打印的格式。
23.3为打印准备文件
作为命令行用户，尽管打印各种格式的文本都能实现，不过打印最多的，还是文本。
23.3.1pr-转换需要打印的文本文件
前面的章节我们也有提到过 pr命令，现在我们来探讨一下这条命令结合打印使用的一些选项。
我们知道，在打印的历史上，基于字符的打印机曾经用过等宽字体，致使每页只能打印固定的
行数和字符数，而 pr命令则能够根据不同的页眉和页边距排列文本使其适应指定的纸张。表
23-1总结了最常用的选项。
选项描述
+first[:last]输出从 first到 last（默认为最后）范围内的页面。
-columns根据 columns指定的列数排版页面内容。
-a默认多列输出为垂直，用 -a (across)可使其水平输出。
-d双空格输出。
-D format用 format指定的格式修改页眉中显示的日期，日期命令中
format字符串的描述详见参考手册。
-f改用换页替换默认的回车来分割页面。
-h header在页眉中部用 header参数替换打印文件的名字。
-l length设置页长为 length，默认为 66行（每英寸 6行的美国信
纸）。
-n输出行号。
-o offset创建一个宽 offset字符的左页边。
-w width设置页宽为 width，默认为 72字符。
表 23-1:常用 pr选项
我们通常用管道配合 pr命令来做筛选。下面的例子中我们会列出目录 /usr/bin并用 pr将
334
其格式化为 3列输出的标题页：
[me@linuxbox~]$ls/usr/bin|pr-3-w65|head
2012-02-1814:00Page1
[apturlbsd-write
411toppmarbsh
a2parecordbtcflash
a2psarecordmidibug-buddy
a2ps-lpr-wrapperarkbuildhash
23.4将打印任务送至打印机
CUPS打印体系支持两种曾用于类 Unix系统的打印方式。一种，叫 Berkeley或 LPD（用于
Unix的 Berkeley软件发行版），使用 lpr程序；另一种，叫 SysV（源自 System V版本的 Unix），
使用 lp程序。这两个程序的功能大致相同。具体使用哪个完全根据个人喜好。
23.4.1lpr-打印文件（Berkeley风格）
lpr程序可以用来把文件传送给打印机。由于它能接收标准输入，所以能用管道来协同工作。
例如，要打印刚才多列目录列表的结果，我们只需这样：
[me@linuxbox~]$ls/usr/bin|pr-3|lpr
报告会送到系统默认的打印机，如果要送到别的打印机，可以使用 -P参数：
lpr-Pprinter_name
printer_name表示这台打印机的名称。若要查看系统已知的打印机列表：
[me@linuxbox~]$lpstat-a
335
注意：许多 Linux发行版允许你定义一个输出 PDF文件但不执行实体打印的“打印机”，
这可以用来很方便的检验你的打印命令。看看你的打印机配置程序是否支持这项配置。在某些
发行版中，你可能要自己安装额外的软件包（如 cups-pdf）来使用这项功能。
表 23-2显示了 lpr的一些常用选项
选项描述
-# number设定打印份数为 number。
-p使每页页眉标题中带有日期、时间、工作名称和页码。这
种所谓的“美化打印”选项可用于打印文本文件。
-P printer指定输出打印机的名称。未指定则使用系统默认打印机。
-r打印后删除文件。对程序产生的临时打印文件较为有用。
表 23-2:常用 lpr选项
23.4.2lp-打印文件（SystemV风格）
和 lpr一样，lp可以接收文件或标准输入为打印内容。与 lpr不同的是 lp支持不同的选项（略
为复杂），表 23-3列出了其常用选项。
选项描述
-d printer设定目标（打印机）为 printer。若 d选项未指
定，则使用系统默认打印机。
-n number设定的打印份数为 number。
-o landscape设置输出为横向。
-o fitplot缩放文件以适应页面。打印图像时较为有用，如
JPEG文件。
-o scaling=number缩放文件至 number。100表示填满页面，小于
100表示缩小，大于 100则会打印在多页上。
-o cpi=number设定输出为 number字符每英寸。默认为 10。
-o lpi=number设定输出为 number行每英寸，默认为 6。
-o page-bottom=points设置页边距，单位为点，一种印刷上的单位。一
-o page-left=points英寸 =72点。
-o page-right=points
-o page-top=points
336
-P pages指定打印的页面。pages可以是逗号分隔的列表
或范围——例如 1,3,5,7-10。
表 23-3:常用 lp选项
再次打印我们的目录列表，这次我们设置 12 CPI、8 LPI和一个半英寸的左边距。注意这
里我必须调整 pr选项来适应新的页面大小：
[me@linuxbox~]$ls/usr/bin|pr-4-w90-l88|lp-opage-left=36-ocpi=12-olpi=8
这条命令用小于默认的格式产生了一个四列的列表。增加 CPI可以让我们在页面上打印更
多列。
23.4.3另一种选择：a2ps
a2ps程序很有趣。单从名字上看，这是个格式转换程序，但它的功能不止于此。程序名字的本
意为 ASCII to PostScript，它是用来为 PostScript打印机准备要打印的文本文件的。多年后，
程序的功能得到了提升，名字的含义也变成了 Anything to PostScript。尽管名为格式转换程
序，但它实际的功能却是打印。它的默认输出不是标准输出，而是系统的默认打印机。程序的
默认行为被称为“漂亮的打印机”，这意味着它可以改善输出的外观。我们能用程序在桌面上创
建一个 PostScript文件：
[me@linuxbox~]$ls/usr/bin|pr-3-t|a2ps-o~/Desktop/ls.ps-L66
[stdin(plain):11pageson6sheets]
[Total:11pageson6sheets]savedintothefile`/home/me/Desktop/ls.ps'
这里我们用带 -t参数（忽略页眉和页脚）的 pr命令过滤数据流，然后用 a2ps指定一个输
出文件（-o参数），并设定每页 66行（-L参数）来匹配 pr的输出分页。用合适的文件查看器
查看我们的输出文件，我们就会看到图 23-1中显示的结果。
337
图 23-1:浏览 a2ps的输出结果
可以看到，默认的输出布局是一面两页的，这将导致两页的内容被打印到一张纸上。a2ps
还能利用页眉和页脚。
a2ps有很多选项，总结在表 23-4中。
选项描述
--center-title text设置中心页标题为 text。
--columns number将所有页面排列成 number列。默认为 2。
--footer text设置页脚为 text。
--guess报告参数中文件的类型。由于 a2ps会转换并格
式化所有类型的数据，所以当给定文件类型后，
这个选项可以很好的用来判断 a2ps应该做什
么。
--left-footer text设置左页脚为 text。
--left-title text设置页面左标题为 text。
--line-numbers=interval每隔 interval行输出行号。
--list=defauls显示默认设置。
--list=topic显示 topic设置，topic表示下列之一：代理程
序（用来转换数据的外部程序），编码，特征，变
量，媒介（页面大小等），ppd（PostScript打印
机描述信息），打印机，起始程序（为常规输出
添加前缀的代码部分），样式表，或用户选项。
338
--pages range打印 range范围内的页面。
--right-footer text设置右页脚为 text。
--right-title text设置页面右标题为 text。
--rows number将所有页面排列成 number排。默认为 1。
-B没有页眉。
-b text设置页眉为 text。
-f size使用字体大小为 size号。
-l number设置每行字符数为 number。此项和 -L选项（见
下方）可以给文件用其他程序来更准确的分页，
如 pr。
-L number设置每页行数为 number。
-M name使用打印媒介的名称——例如，A4。
-n number每页输出 number份。
-o file输出到文件 file。如果指定为 -，则输出到标准
输出。
-P printer使用打印机 printer。如果未指定，则使用系统
默认打印机。
-R纵向打印。
-r横向打印。
-T number设置制表位为每 number字符。
-u text用 text作为页面底图（水印）。
表 23-4: a2ps选项
以上只是对 a2ps的总结，更多的选项尚未列出。
注意：a2ps目前仍在不断的开发中。就我的测试而言，不同版本之间都多少有所变化。
CentOS 4中输出总是默认为标准输出。在 CentOS 4和 Fedora 10中，尽管程序配置信纸为默
认媒介，输出还是默认为 A4纸。我可以明确的指定需要的选项来解决这些问题。Ubuntu 8.04
中，a2ps表现的正如参考文档中所述。另外，我们也要注意到另一个转换文本为 PostScript的
输出格式化工具，名叫 enscript。它具有许多相同的格式化和打印功能，但和 a2ps唯一的不同
在于，它只能处理纯文本的输入。
339
23.5监视和控制打印任务
由于 Unix打印系统的设计是能够处理多用户的多重打印任务，CUPS也是如此设计的。每台
打印机都有一个打印队列，其中的任务直到传送到打印机才停下并进行打印。CUPS支持一
些命令行程序来管理打印机状态和打印队列。想 lpr和 lp这样的管理程序都是以 Berkeley和
System V打印系统的相应程序为依据进行排列的。
23.5.1lpstat-显示打印系统状态
lpstat程序可用于确定系统中打印机的名字和有效性。例如，我们系统中有一台实体打印机
（名叫 printer）和一台 PDF虚拟打印机（名叫 PDF），我们可以像这样查看打印机状态：
[me@linuxbox~]$lpstat-a
PDFacceptingrequestssinceMon05Dec201103:05:59PMEST
printeracceptingrequestssinceTue21Feb201208:43:22AMEST
接着，我们可以查看打印系统更具体的配置信息：
[me@linuxbox~]$lpstat-s
systemdefaultdestination:printer
deviceforPDF:cups-pdf:/
deviceforprinter:ipp://print-server:631/printers/printer
上例中，我们看到 printer是系统默认的打印机，其本身是一台网络打印机，使用网络打印
协议（ipp://）通过网络连接到名为 print-server的系统。
lpstat的常用选项列于表 23-5。
选项描述
-a [printer...]显示 printer打印机的队列。这里显示的状态是打印机队列
承受任务的能力，而不是实体打印机的状态。若未指定打印
机，则显示所有打印队列。
-d显示系统默认打印机的名称。
-p [printer...]显示 printer指定的打印机的状态。若未指定打印机，则显
示所有打印机状态。
340
-r显示打印系统的状态。
-s显示汇总状态。
-t显示完整状态报告。
表 23-5:常用 lpstat选项
23.5.2lpq-显示打印机队列状态
使用 lpq程序可以查看打印机队列的状态，从中我们可以看到队列的状态和所包含的打印任
务。下面的例子显示了一台名叫 printer的系统默认打印机包含一个空队列的情况：
[me@linuxbox~]$lpq
printerisready
noentries
如果我们不指定打印机（用 -P参数），就会显示系统默认打印机。如果给打印机添加一项
任务再查看队列，我们就会看到下列结果：
[me@linuxbox~]$ls*.txt|pr-3|lp
requestidisprinter-603(1file(s))
[me@linuxbox~]$lpq
printerisreadyandprinting
RankOwnerJobFile(s)TotalSize
activeme603(stdin)1024bytes
23.5.3lprm和cancel-取消打印任务
CUPS提供两个程序来从打印队列中终止并移除打印任务。一个是 Berkeley风格的（lprm），
另一个是 System V的（cancel）。在支持的选项上两者有较小的区别但是功能却几乎相同。以
上面的打印任务为例，我们可以像这样终止并移除任务：
[me@linuxbox~]$cancel603
[me@linuxbox~]$lpq
341
printerisready
noentries
每个命令都有选项可用于移除某用户、某打印机或多个任务号的所有任务，相应的参考手
册中都有详细的介绍。
342
24|编译程序
在这一章中，我们将看一下如何通过编译源代码来创建程序。源代码的可用性是至关重要的自
由，从而使得 Linux成为可能。整个 Linux开发生态圈就是依赖于开发者之间的自由交流。对
于许多桌面用户来说，编译是一种失传的艺术。以前很常见，但现在，由系统发行版提供商维
护巨大的预编译的二进制仓库，准备供用户下载和使用。在写这篇文章的时候，Debian仓库
（最大的发行版之一）包含了几乎 23,000个预编译的包。
那么为什么要编译软件呢？有两个原因：
1.可用性。尽管系统发行版仓库中已经包含了大量的预编译程序，但是一些发行版本不可
能包含所有期望的应用。在这种情况下，得到所期望程序的唯一方式是编译程序源码。
2.及时性。虽然一些系统发行版专门打包前沿版本的应用程序，但是很多不是。这意味着，
为了拥有一个最新版本的程序，编译是必需的。
从源码编译软件可以变得非常复杂且具有技术性；许多用户难以企及。然而，许多编译任务
是相当简单的，只涉及到几个步骤。这都取决于程序包。我们将看一个非常简单的案例，为的
是给大家提供一个对编译过程的整体认识，并为那些愿意进一步学习的人们构筑一个起点。
我们将介绍一个新命令：
• make -维护程序的工具
24.1什么是编译？
简而言之，编译就是把源码（一个由程序员编写的人类可读的程序的说明）翻译成计算机处理
器的语言的过程。
计算机处理器（或 CPU）工作在一个非常基本的水平，执行用机器语言编写的程序。这是
一种数值编码，描述非常小的操作，比如“加这个字节”、“指向内存中的这个位置”或者“复
制这个字节”。
343
这些指令中的每一条都是用二进制表示的（1和 0）。最早的计算机程序就是用这种数值编
码写成的，这可能就解释了为什么编写它们的程序员据说吸很多烟，喝大量咖啡，并带着厚厚
的眼镜。随着汇编语言的出现，这个问题得到克服。汇编语言使用诸如 CPY（复制）和 MOV
（移动）之类（略微）易用的字符助记符代替了数值编码。用汇编语言编写的程序通过汇编器处
理为机器语言。今天为了完成某些特定的程序任务，汇编语言仍在被使用，例如设备驱动和嵌
入式系统。
下一步我们谈论一下什么是所谓的高级编程语言。之所以这样称呼它们，是因为它们可以
让程序员少操心处理器的一举一动，而更多关心如何解决手头的问题。早期的高级语言（二十
世纪 50年代期间研发的）包括 FORTRAN（为科学和技术任务而设计）和 COBOL（为商业
应用而设计）。今天这两种语言仍在有限的使用。
虽然有许多流行的编程语言，两个占主导地位。大多数为现代系统编写的程序，要么用 C
编写，要么是用 C++编写。在随后的例子中，我们将编写一个 C程序。
用高级语言编写的程序，经过另一个称为编译器的程序的处理，会转换成机器语言。一些编
译器把高级指令翻译成汇编语言，然后使用一个汇编器完成翻译成机器语言的最后阶段。
一个称为链接的过程经常与编译结合在一起。有许多常见的由程序执行的任务。以打开文
件为例。许多程序执行这个任务，但是让每个程序实现它自己的打开文件功能，是很浪费资源
的。更有意义的是，拥有单独的一段知道如何打开文件的程序，并允许所有需要它的程序共享
它。对常见任务提供支持由所谓的库完成。这些库包含多个程序，每个程序执行一些可以由多
个程序共享的常见任务。如果我们看一下 /lib和 /usr/lib目录，我们可以看到许多库定居在那
里。一个叫做链接器的程序用来在编译器的输出结果和要编译的程序所需的库之间建立连接。
这个过程的最终结果是一个可执行程序文件，准备使用。
24.1.1所有的程序都是可编译的吗？
不是。正如我们所看到的，有些程序比如 shell脚本就不需要编译。它们直接执行。这些程序是
用所谓的脚本或解释型语言编写的。近年来，这些语言变得越来越流行，包括 Perl、Python、
PHP、Ruby和许多其它语言。
脚本语言由一个叫做解释器的特殊程序执行。一个解释器输入程序文件，读取并执行程序
中包含的每一条指令。通常来说，解释型程序执行起来要比编译程序慢很多。这是因为每次解
释型程序执行时，程序中每一条源码指令都需要翻译，而一个已经编译好的程序，一条源码指
令只翻译了一次，翻译后的指令会永久地记录到最终的执行文件中。
那么为什么解释型程序这样流行呢？对于许多编程任务来说，原因是“足够快”，但是真正
的优势是一般来说开发解释型程序要比编译程序快速且容易。通常程序开发需要经历一个不断
重复的写码、编译和测试周期。随着程序变得越来越大，编译阶段会变得相当耗时。解释型语
344
言删除了编译步骤，这样就加快了程序开发。
24.2编译一个C语言
让我们编译一些东西。在我们编译之前，然而我们需要一些工具，像编译器、链接器以及
make。在 Linux环境中，普遍使用的 C编译器叫做 gcc（GNU C编译器），最初由 Richard
Stallman写出来的。大多数 Linux系统发行版默认不安装 gcc。我们可以这样查看该编译器是
否存在：
[me@linuxbox~]$whichgcc
/usr/bin/gcc
在这个例子中的输出结果表明安装了 gcc编译器。
小提示：你的系统发行版可能有一个用于软件开发的 meta-package（软件包的集合）。如
果是这样的话，若你打算在你的系统中编译程序就考虑安装它。若你的系统没有提供一个
meta-package，试着安装 gcc和 make工具包。在许多发行版中，这就足够完成下面的练习了。
—
24.2.1得到源码
为了我们的编译练习，我们将编译一个叫做 diction的程序，来自 GNU项目。这是一个小巧方
便的程序，检查文本文件的书写质量和样式。就程序而言，它相当小，且容易创建。
遵照惯例，首先我们要创建一个名为 src的目录来存放我们的源码，然后使用 ftp协议把源
码下载下来。
[me@linuxbox~]$mkdirsrc
[me@linuxbox~]$cdsrc
[me@linuxboxsrc]$ftpftp.gnu.org
Connectedtoftp.gnu.org.
220GNUFTPserverready.
Name(ftp.gnu.org:me):anonymous
230Loginsuccessful.
345
RemotesystemtypeisUNIX.
Usingbinarymodetotransferfiles.
ftp>cdgnu/diction
250Directorysuccessfullychanged.
ftp>ls
200PORTcommandsuccessful.ConsiderusingPASV.
150Herecomesthedirectorylisting.
-rw-r--r--110036553468940Aug281998diction-0.7.tar.gz
-rw-r--r--110036553490957Mar042002diction-1.02.tar.gz
-rw-r--r--1100365534141062Sep172007diction-1.11.tar.gz
226DirectorysendOK.
ftp>getdiction-1.11.tar.gz
local:diction-1.11.tar.gzremote:diction-1.11.tar.gz
200PORTcommandsuccessful.ConsiderusingPASV.
150OpeningBINARYmodedataconnectionfordiction-1.11.tar.gz
(141062bytes).
226FilesendOK.
141062bytesreceivedin0.16secs(847.4kB/s)
ftp>bye
221Goodbye.
[me@linuxboxsrc]$ls
diction-1.11.tar.gz
注意：因为我们是这个源码的“维护者”，当我们编译它的时候，我们把它保存在/src目
录下。由你的系统发行版源码会把源码安装在 /usr/src目录下，而供多个用户使用的源码，通
常安装在 /usr/local/src目录下。
正如我们所看到的，通常提供的源码形式是一个压缩的 tar文件。有时候称为 tarball，这
个文件包含源码树，或者是组成源码的目录和文件的层次结构。当到达 ftp站点之后，我们检
查可用的 tar文件列表，然后选择最新版本，下载。使用 ftp中的 get命令，我们把文件从 ftp
服务器复制到本地机器。
一旦 tar文件下载下来之后，必须解包。通过 tar程序可以完成：
346
[me@linuxboxsrc]$tarxzfdiction-1.11.tar.gz
[me@linuxboxsrc]$ls
diction-1.11
diction-1.11.tar.gz
小提示：该 diction程序，像所有的 GNU项目软件，遵循着一定的源码打包标准。其它大
多数在 Linux生态系统中可用的源码也遵循这个标准。该标准的一个条目是，当源码 tar文件
打开的时候，会创建一个目录，该目录包含了源码树，并且这个目录将会命名为 project-x.xx，
其包含了项目名称和它的版本号两项内容。这种方案能在系统中方便安装同一程序的多个版
本。然而，通常在打开 tarball之前检验源码树的布局是个不错的主意。一些项目不会创建该
目录，反而，会把文件直接传递给当前目录。这会把你的（除非组织良好的）src目录弄得一片
狼藉。为了避免这个，使用下面的命令，检查 tar文件的内容：
tartzvftarfile|head---
24.3检查源码树
打开该 tar文件，会创建一个新的目录，名为 diction-1.11。这个目录包含了源码树。让我们看
一下里面的内容：
[me@linuxboxsrc]$cddiction-1.11
[me@linuxboxdiction-1.11]$ls
config.guessdiction.cgetopt.cnl
config.h.indiction.potgetopt.hnl.po
config.subdiction.specgetopt_int.hREADME
configurediction.spec.inINSTALLsentence.c
configure.indiction.texi.ininstall-shsentence.h
COPYINGenMakefile.instyle.1.in
deen_GBmisc.cstyle.c
de.poen_GB.pomisc.htest
diction.1.ingetopt1.cNEWS
347
在源码树中，我们看到大量的文件。属于 GNU项目的程序，还有其它许多程序都会，提供
文档文件 README，INSTALL，NEWS，和 COPYING。
这些文件包含了程序描述，如何建立和安装它的信息，还有其它许可条款。在试图建立程序
之前，仔细阅读 README和 INSTALL文件，总是一个不错的主意。
在这个目录中，其它有趣的文件是那些以.c和.h为后缀的文件：
[me@linuxboxdiction-1.11]$ls*.c
diction.cgetopt1.cgetopt.cmisc.csentence.cstyle.c
[me@linuxboxdiction-1.11]$ls*.h
getopt.hgetopt_int.hmisc.hsentence.h
这些.c文件包含了由该软件包提供的两个 C程序（style和 diction），被分割成模块。这是
一种常见做法，把大型程序分解成更小，更容易管理的代码块。源码文件都是普通文本，可以
用 less命令查看：
[me@linuxboxdiction-1.11]$lessdiction.c
这些.h文件被称为头文件。它们也是普通文件。头文件包含了程序的描述，这些程序被包
括在源码文件或库中。为了让编译器链接到模块，编译器必须接受所需的所有模块的描述，来
完成整个程序。在 diction.c文件的开头附近，我们看到这行代码：
#include"getopt.h"
当它读取 diction.c中的源码的时候，这行代码指示编译器去读取文件 getopt.h，为的是“知
道”getopt.c中的内容。getopt.c文件提供由 style和 diction两个程序共享的例行程序。
在 getopt.h的 include语句上面，我们看到一些其它的 include语句，比如这些：
#include<regex.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
348
这些文件也是头文件，但是这些头文件在当前源码树的外面。它们由操作系统供给，来支持
每个程序的编译。如果我们看一下 /usr/include目录，能看到它们：
[me@linuxboxdiction-1.11]$ls/usr/include
当我们安装编译器的时候，这个目录中的头文件会被安装。
24.3.1构建程序
大多数程序通过一个简单的，两个命令的序列构建：
./configure
make
这个 configure程序是一个 shell脚本，由源码树提供。它的工作是分析程序构建环境。大
多数源码会设计为可移植的。也就是说，它被设计成能够在不止一种类 Unix系统中进行构建。
但是为了做到这一点，在建立程序期间，为了适应系统之间的差异，源码可能需要经过轻微的
调整。configure也会检查是否安装了必要的外部工具和组件。让我们运行 configure命令。因
为 configure命令所在的位置不是位于 shell通常期望程序所呆的地方，我们必须明确地告诉
shell它的位置，通过在命令之前加上./字符，来表明程序位于当前工作目录：
[me@linuxboxdiction-1.11]$./configure
configure将会输出许多信息，随着它测试和配置整个构建过程。当结束后，输出结果看起
来像这样：
checkinglibintl.hpresence...yes
checkingforlibintl.h...yes
checkingforlibrarycontaininggettext...nonerequired
configure:creating./config.status
config.status:creatingMakefile
config.status:creatingdiction.1
349
config.status:creatingdiction.texi
config.status:creatingdiction.spec
config.status:creatingstyle.1
config.status:creatingtest/rundiction
config.status:creatingconfig.h
[me@linuxboxdiction-1.11]$
这里最重要的事情是没有错误信息。如果有错误信息，整个配置过程失败，然后程序不能构
建直到修正了错误。
我们看到在我们的源码目录中 configure命令创建了几个新文件。最重要一个是 Makefile。
Makefile是一个配置文件，指示 make程序究竟如何构建程序。没有它，make程序就不能运
行。Makefile是一个普通文本文件，所以我们能查看它：
[me@linuxboxdiction-1.11]$lessMakefile
这个 make程序把一个 makefile文件作为输入（通常命名为 Makefile），makefile文件描述
了包括最终完成的程序的各组件之间的关系和依赖性。
makefile文件的第一部分定义了变量，这些变量在该 makefile后续章节中会被替换掉。例
如我们看看这一行代码：
CC=gcc
其定义了所用的 C编译器是 gcc。文件后面部分，我们看到一个使用该变量的实例：
diction:diction.osentence.omisc.ogetopt.ogetopt1.o
$(CC)-o$@$(LDFLAGS)diction.osentence.omisc.o\
getopt.ogetopt1.o$(LIBS)
这里完成了一个替换操作，在程序运行时，$(CC)的值会被替换成 gcc。大多数 makefile文
件由行组成，每行定义一个目标文件，在这种情况下，目标文件是指可执行文件 diction，还有目
标文件所依赖的文件。剩下的行描述了从目标文件的依赖组件中创建目标文件所需的命令。在
350
这个例子中，我们看到可执行文件 diction（最终的成品之一）依赖于文件 diction.o，sentence.o，
misc.o，getopt.o，和 getopt1.o都存在。在 makefile文件后面部分，我们看到 diction文件所
依赖的每一个文件做为目标文件的定义：
diction.o:diction.cconfig.hgetopt.hmisc.hsentence.h
getopt.o:getopt.cgetopt.hgetopt_int.h
getopt1.o:getopt1.cgetopt.hgetopt_int.h
misc.o:misc.cconfig.hmisc.h
sentence.o:sentence.cconfig.hmisc.hsentence.h
style.o:style.cconfig.hgetopt.hmisc.hsentence.h
然而，我们不会看到针对它们的任何命令。这个由一个通用目标解决，在文件的前面，描述
了这个命令，用来把任意的.c文件编译成.o文件：
.c.o:
$(CC)-c$(CPPFLAGS)$(CFLAGS)$<
这些看起来非常复杂。为什么不简单地列出编译每个部分的步骤，那样不就行了？一会儿
就知道答案了。同时，让我们运行 make命令并构建我们的程序：
[me@linuxboxdiction-1.11]$make
这个 make程序将会运行，使用 Makefile文件的内容来指导它的行为。它会产生很多信息。
当 make程序运行结束后，现在我们将看到所有的目标文件出现在我们的目录中。
[me@linuxboxdiction-1.11]$ls
config.guessde.poenen_GBsentence.c
config.hdictionen_GB.moen_GB.posentence.h
config.h.indiction.1getopt1.cgetopt1.osentence.o
config.logdiction.1.ingetopt.cgetopt.hstyle
config.statusdiction.cgetopt_int.hgetopt.ostyle.1
config.subdiction.oINSTALLinstall-shstyle.1.in
configurediction.potMakefileMakefile.instyle.c
351
configure.indiction.specmisc.cmisc.hstyle.o
COPYINGdiction.spec.inmisc.oNEWStest
dediction.texinlnl.mo
de.modiction.texi.inl.poREADME
在这些文件之中，我们看到 diction和 style，我们开始要构建的程序。恭喜一切正常！我们
刚才源码编译了我们的第一个程序。但是出于好奇，让我们再运行一次 make程序：
[me@linuxboxdiction-1.11]$make
make:Nothingtobedonefor`all'.
它只是产生这样一条奇怪的信息。怎么了？为什么它没有重新构建程序呢？啊，这就是
make奇妙之处了。make只是构建需要构建的部分，而不是简单地重新构建所有的内容。由于
所有的目标文件都存在，make确定没有任何事情需要做。我们可以证明这一点，通过删除一
个目标文件，然后再次运行 make程序，看看它做些什么。让我们去掉一个中间目标文件：
[me@linuxboxdiction-1.11]$rmgetopt.o
[me@linuxboxdiction-1.11]$make
我们看到 make重新构建了 getopt.o文件，并重新链接了 diction和 style程序，因为它们
依赖于丢失的模块。这种行为也指出了 make程序的另一个重要特征：它保持目标文件是最新
的。make坚持目标文件要新于它们的依赖文件。这个非常有意义，做为一名程序员，经常会
更新一点儿源码，然后使用 make来构建一个新版本的成品。make确保基于更新的代码构建
了需要构建的内容。如果我们使用 touch程序，来“更新”其中一个源码文件，我们看到发生
了这样的事情：
[me@linuxboxdiction-1.11]$ls-ldictiongetopt.c
-rwxr-xr-x1meme371642009-03-0506:14diction
-rw-r--r--1meme331252007-03-3017:45getopt.c
[me@linuxboxdiction-1.11]$touchgetopt.c
[me@linuxboxdiction-1.11]$ls-ldictiongetopt.c
-rwxr-xr-x1meme371642009-03-0506:14diction
352
-rw-r--r--1meme331252009-03-0506:23getopt.c
[me@linuxboxdiction-1.11]$make
运行 make之后，我们看到目标文件已经更新于它的依赖文件：
[me@linuxboxdiction-1.11]$ls-ldictiongetopt.c
-rwxr-xr-x1meme371642009-03-0506:24diction
-rw-r--r--1meme331252009-03-0506:23getopt.c
make程序这种智能地只构建所需要构建的内容的特性，对程序来说，是巨大的福利。虽然
在我们的小项目中，节省的时间可能不是非常明显，在庞大的工程中，它具有非常重大的意义。
记住，Linux内核（一个经历着不断修改和改进的程序）包含了几百万行代码。
24.3.2安装程序
打包良好的源码经常包括一个特别的 make目标文件，叫做 install。这个目标文件将在系统目
录中安装最终的产品，以供使用。通常，这个目录是 /usr/local/bin，为在本地所构建软件的传
统安装位置。然而，通常普通用户不能写入该目录，所以我们必须变成超级用户，来执行安装
操作：
[me@linuxboxdiction-1.11]$sudomakeinstall
执行了安装后，我们可以检查下程序是否已经可用：
[me@linuxboxdiction-1.11]$whichdiction
/usr/local/bin/diction
[me@linuxboxdiction-1.11]$mandiction
完美！
24.4总结
在这一章中，我们已经知道了三个简单命令：
353
./configure
make
makeinstall
可以用来构建许多源码包。我们也知道了在程序维护过程中，make程序起到了举足轻重
的作用。make程序可以用到任何需要维护一个目标/依赖关系的任务中，不仅仅为了编译源代
码。
24.5拓展阅读
• Wikipedia上面有关于编译器和 make程序的好文章：
http://en.wikipedia.org/wiki/Compiler
http://en.wikipedia.org/wiki/Make_(software)
• GNU Make手册
http://www.gnu.org/software/make/manual/html_node/index.html
354
25|编写第一个Shell脚本
在前面的章节中，我们已经装备了一个命令行工具的武器库。虽然这些工具能够解决许多种计
算问题，但是我们仍然局限于在命令行中手动地一个一个使用它们。如果我们能够让 shell来
完成更多的工作,岂不是更好？我们可以的。通过把我们的工具一起放置到我们自己设计的程
序中, shell就会自己来执行这些复杂的任务序列。通过编写 shell脚本，我们可以让 shell来做
这些事情。
25.1什么是Shell脚本？
最简单的解释，一个 shell脚本就是一个包含一系列命令的文件。shell读取这个文件，然后执
行文件中的所有命令，就好像这些命令已经直接被输入到了命令行中一样。
Shell有些独特，因为它不仅是一个功能强大的命令行接口,也是一个脚本语言解释器。我
们将会看到，大多数能够在命令行中完成的任务也能够用脚本来实现，同样地，大多数能用脚
本实现的操作也能够在命令行中完成。
虽然我们已经介绍了许多 shell功能，但只是集中于那些经常直接在命令行中使用的功能。
Shell也提供了一些通常（但不总是）在编写程序时才使用的功能。
25.2怎样编写一个Shell脚本
为了成功地创建和运行一个 shell脚本，我们需要做三件事情：
1.编写一个脚本。 Shell脚本就是普通的文本文件。所以我们需要一个文本编辑器来书写它
们。最好的文本编辑器都会支持语法高亮，这样我们就能够看到一个脚本关键字的彩色编
码视图。语法高亮会帮助我们查看某种常见错误。为了编写脚本文件，vim，gedit，kate，
和许多其它编辑器都是不错的候选者。
2.使脚本文件可执行。系统会相当挑剔不允许任何旧的文本文件被看作是一个程序，并且
有充分的理由!所以我们需要设置脚本文件的权限来允许其可执行。
355
3.把脚本放置到shell能够找到的地方。当没有指定可执行文件明确的路径名时，shell会自
动地搜索某些目录，来查找此可执行文件。为了最大程度的方便，我们会把脚本放到这些
目录当中。
25.3脚本文件格式
为了保持编程传统，我们将创建一个“hello world”程序来说明一个极端简单的脚本。所以让
我们启动我们的文本编辑器，然后输入以下脚本：
#!/bin/bash
#Thisisourfirstscript.
echo'HelloWorld!'
对于脚本中的最后一行，我们应该是相当的熟悉，仅仅是一个带有一个字符串参数的 echo
命令。对于第二行也很熟悉。它看起来像一个注释，我们已经在许多我们检查和编辑过的配置
文件中看到过。关于 shell脚本中的注释，它们也可以出现在文本行的末尾，像这样：
echo'HelloWorld!'#Thisisacommenttoo
文本行中，#符号之后的所有字符都会被忽略。
类似于许多命令，这也在命令行中起作用：
[me@linuxbox~]$echo'HelloWorld!'#Thisisacommenttoo
HelloWorld!
虽然很少在命令行中使用注释，但它们也能起作用。
我们脚本中的第一行文本有点儿神秘。它看起来它应该是一条注释，因为它起始于一个 #
符号，但是它看起来太有意义，以至于不仅仅是注释。事实上，这个 #!字符序列是一种特殊
的结构叫做 shebang。这个 shebang被用来告诉操作系统将执行此脚本所用的解释器的名字。
每个 shell脚本都应该把这一文本行作为它的第一行。
让我们把此脚本文件保存为 hello_world。
356
25.4可执行权限
下一步我们要做的事情是让我们的脚本可执行。使用 chmod命令，这很容易做到：
[me@linuxbox~]$ls-lhello_world
-rw-r--r--1meme632009-03-0710:10hello_world
[me@linuxbox~]$chmod755hello_world
[me@linuxbox~]$ls-lhello_world
-rwxr-xr-x1meme632009-03-0710:10hello_world
对于脚本文件，有两个常见的权限设置；权限为 755的脚本，则每个人都能执行，和权限为
700的脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。
25.5脚本文件位置
当设置了脚本权限之后，我们就能执行我们的脚本了：
[me@linuxbox~]$./hello_world
HelloWorld!
为了能够运行此脚本，我们必须指定脚本文件明确的路径。如果我们没有那样做，我们会得
到这样的提示：
[me@linuxbox~]$hello_world
bash:hello_world:commandnotfound
为什么会这样呢？什么使我们的脚本不同于其它的程序？结果证明，什么也没有。我们的脚
本没有问题。是脚本存储位置的问题。回到第 12章，我们讨论了 PATH环境变量及其在系统
查找可执行程序方面的作用。回顾一下，如果没有给出可执行程序的明确路径名，那么系统每
次都会搜索一系列的目录，来查找此可执行程序。这个/bin目录就是其中一个系统会自动搜索
的目录。这个目录列表被存储在一个名为 PATH的环境变量中。这个 PATH变量包含一个由
冒号分隔开的目录列表。我们可以查看 PATH的内容：
357
[me@linuxbox~]$echo$PATH
/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:
/bin:/usr/games
这里我们看到了我们的目录列表。如果我们的脚本位于此列表中任意目录下，那么我们
的问题将会被解决。注意列表中的第一个目录/home/me/bin。大多数的 Linux发行版会配置
PATH变量，让其包含一个位于用户家目录下的 bin目录，从而允许用户能够执行他们自己的
程序。所以如果我们创建了一个 bin目录，并把我们的脚本放在这个目录下，那么这个脚本就
应该像其它程序一样开始工作了：
[me@linuxbox~]$mkdirbin
[me@linuxbox~]$mvhello_worldbin
[me@linuxbox~]$hello_world
HelloWorld!
它的确工作了。
如果这个 PATH变量不包含这个目录，我们能够轻松地添加它，通过在我们的.bashrc文件
中包含下面这一行文本：
exportPATH=~/bin:"$PATH"
当做了这个修改之后，它会在每个新的终端会话中生效。为了把这个修改应用到当前的终
端会话中，我们必须让 shell重新读取这个.bashrc文件。这可以通过“sourcing”.bashrc文件
来完成：
[me@linuxbox~]$..bashrc
这个点（.）命令是 source命令的同义词，一个 shell内建命令，用来读取一个指定的 shell
命令文件，并把它看作是从键盘中输入的一样。
358
注意：在 Ubuntu系统中，如果存在/bin目录，当执行用户的.bashrc文件时，Ubuntu会
自动地添加这个/bin目录到 PATH变量中。所以在 Ubuntu系统中，如果我们创建了这个
/bin目录，随后退出，然后再登录，一切会正常运行。
25.5.1脚本文件的好去处
这个/bin目录是存放为个人所用脚本的好地方。如果我们编写了一个脚本，系统中的每个用
户都可以使用它，那么这个脚本的传统位置是 /usr/local/bin。系统管理员使用的脚本经常放
到 /usr/local/sbin目录下。大多数情况下，本地支持的软件，不管是脚本还是编译过的程序，
都应该放到 /usr/local目录下，而不是在 /bin或 /usr/bin目录下。这些目录都是由 Linux文
件系统层次结构标准指定，只包含由 Linux发行商所提供和维护的文件。
25.6更多的格式技巧
严肃认真的脚本书写的关键目标之一是为了易于维护；也就是说，一个脚本可以轻松地被作者
或其它用户修改，使它适应变化的需求。使脚本容易阅读和理解是一种方便维护的方法。
25.6.1长选项名称
我们学过的许多命令都以长短两种选项名称为特征。例如，这个 ls命令有许多选项既可以用短
形式也可以用长形式来表示。例如：
[me@linuxbox~]$ls-ad
和：
[me@linuxbox~]$ls--all--directory
是等价的命令。为了减少输入，当在命令行中输入选项的时候，短选项更受欢迎，但是当书
写脚本的时候，长选项能提供可读性。
359
25.6.2缩进和行继续符
当使用长命令的时候，通过把命令在几个文本行中展开，可以提高命令的可读性。在第十八章
中，我们看到了一个特别长的 find命令实例：
[me@linuxbox~]$findplayground\(-typef-not-perm0600-exec
chmod0600‘{}’‘;’\)-or\(-typed-not-perm0711-execchmod
0711‘{}’‘;’\)
显然，这个命令有点儿难理解，当第一眼看到它的时候。在脚本中，这个命令可能会比较容
易理解，如果这样书写它：
findplayground\
\(\
-typef\
-not-perm0600\
-execchmod0600‘{}’‘;’\
\)\
-or\
\(\
-typed\
-not-perm0711\
-execchmod0711‘{}’‘;’\
\)
通过使用行继续符（反斜杠-回车符序列）和缩进，这个复杂命令的逻辑会被更清楚地描述
给读者。这个技巧在命令行中同样有效，虽然很少使用它，因为输入和编辑这个命令非常麻烦。
脚本和命令行的一个区别是，脚本可能使用 tab字符来实现缩进，然而命令行却不能，因为
tab字符被用来激活自动补全功能。
为书写脚本配置 vim
这个 vim文本编辑器有许多许多的配置设置。有几个常见的选项能够有助于脚
本书写：
:syntaxon
360
打开语法高亮。通过这个设置，当查看脚本的时候，不同的 shell语法元素会以
不同的颜色显示。这对于识别某些编程错误很有帮助。并且它看起来也很酷。注意
为了这个功能起作用，你必须安装了一个完整的 vim版本，并且你编辑的文件必须
有一个 shebang，来说明这个文件是一个 shell脚本。如果对于上面的命令，你遇到
了困难，试试:setsyntax=sh。
:sethlsearch
打开这个选项是为了高亮查找结果。比如说我们查找单词“echo”。通过设置这
个选项，这个单词的每个实例会高亮显示。
:settabstop=4
设置一个 tab字符所占据的列数。默认是 8列。把这个值设置为 4（一种
常见做法），从而让长文本行更容易适应屏幕。
:setautoindent
打开 “auto indent”功能。这导致 vim能对新的文本行缩进与刚输入的文本行相
同的列数。对于许多编程结构来说，这就加速了输入。停止缩进，输入 Ctrl-d。
通过把这些命令（没有开头的冒号字符）添加到你的/.vimrc文件中，这些改
动会永久生效。
25.7总结归纳
在这脚本编写的第一章中，我们已经看过怎样编写脚本，怎样让它们在我们的系统中轻松地执
行。我们也知道了怎样使用各种格式技巧来提高脚本的可读性（可维护性）。在以后的各章中，
轻松维护会作为编写好脚本的中心法则一次又一次地出现。
25.8拓展阅读
•查看各种各样编程语言的“Hello World”程序和实例：
http://en.wikipedia.org/wiki/Hello_world
•这篇 Wikipedia文章讨论了更多关于 shebang机制的内容：
http://en.wikipedia.org/wiki/Shebang_(Unix)
361
26|启动一个项目
从这一章开始，我们将建设一个项目。这个项目的目的是为了了解怎样使用各种各样的 shell
功能来创建程序，更重要的是，创建好程序。
我们将要编写的程序是一个报告生成器。它会显示系统的各种统计数据和它的状态，并将
产生 HTML格式的报告，所以我们能通过网络浏览器，比如说 Firefox或者 Konqueror，来查
看这个报告。
通常，创建程序要经过一系列阶段，每个阶段会添加新的特性和功能。我们程序的第一个阶
段将会产生一个非常小的 HTML网页，其不包含系统信息。随后我们会添加这些信息。
26.1第一阶段：最小的文档
首先我们需要知道的事是一个规则的 HTML文档的格式。它看起来像这样：
<HTML>
<HEAD>
<TITLE>PageTitle</TITLE>
</HEAD>
<BODY>
Pagebody.
</BODY>
</HTML>
如果我们将这些内容输入到文本编辑器中，并把文件保存为 foo.html，然后我们就能在
Firefox中使用下面的 URL来查看文件内容：
file:///home/username/foo.html
362
程序的第一个阶段将这个 HTML文件输出到标准输出。我们可以编写一个程序，相当容易
地完成这个任务。启动我们的文本编辑器，然后创建一个名为/bin/sys_info_page的新文件：
[me@linuxbox~]$vim~/bin/sys_info_page
随后输入下面的程序：
#!/bin/bash
#Programtooutputasysteminformationpage
echo"<HTML>"
echo"<HEAD>"
echo"<TITLE>PageTitle</TITLE>"
echo"</HEAD>"
echo"<BODY>"
echo"Pagebody."
echo"</BODY>"
echo"</HTML>"
我们第一次尝试解决这个问题，程序包含了一个 shebang，一条注释（总是一个好主意）和
一系列的 echo命令，每个命令负责输出一行文本。保存文件之后，我们将让它成为可执行文
件，再尝试运行它：
[me@linuxbox~]$chmod755~/bin/sys_info_page
[me@linuxbox~]$sys_info_page
当程序运行的时候，我们应该看到 HTML文本在屏幕上显示出来，因为脚本中的 echo
命令会将输出发送到标准输出。我们再次运行这个程序，把程序的输出重定向到文件
sys_info_page.html中，从而我们可以通过网络浏览器来查看输出结果：
[me@linuxbox~]$sys_info_page>sys_info_page.html
[me@linuxbox~]$firefoxsys_info_page.html
363
到目前为止，一切顺利。
在编写程序的时候，尽量做到简单明了，这总是一个好主意。当一个程序易于阅读和理解的
时候，维护它也就更容易，更不用说，通过减少键入量，可以使程序更容易书写了。我们当前
的程序版本工作正常，但是它可以更简单些。实际上，我们可以把所有的 echo命令结合成一个
echo命令，当然这样能更容易地添加更多的文本行到程序的输出中。那么，把我们的程序修改
为：
#!/bin/bash
#Programtooutputasysteminformationpage
echo"<HTML>
<HEAD>
<TITLE>PageTitle</TITLE>
</HEAD>
<BODY>
Pagebody.
</BODY>
</HTML>"
一个带引号的字符串可能包含换行符，因此可以包含多个文本行。Shell会持续读取文本直
到它遇到右引号。它在命令行中也是这样工作的：
[me@linuxbox~]$echo"<HTML>
><HEAD>
<TITLE>PageTitle</TITLE>
></HEAD>
><BODY>
>Pagebody.
></BODY>
></HTML>"
开头的“>”字符是包含在 PS2shell变量中的 shell提示符。每当我们在 shell中键入多行
语句的时候，这个提示符就会出现。现在这个功能有点儿晦涩，但随后，当我们介绍多行编程
语句时，它会派上大用场。
364
26.2第二阶段：添加一点儿数据
现在我们的程序能生成一个最小的文档，让我们给报告添加些数据吧。为此，我们将做以下修
改：
#!/bin/bash
#Programtooutputasysteminformationpage
echo"<HTML>
<HEAD>
<TITLE>SystemInformationReport</TITLE>
</HEAD>
<BODY>
<H1>SystemInformationReport</H1>
</BODY>
</HTML>"
我们增加了一个网页标题，并且在报告正文部分加了一个标题。
26.3变量和常量
然而，我们的脚本存在一个问题。请注意字符串“System Information Report”是怎样被重复
使用的？对于这个微小的脚本而言，它不是一个问题，但是让我们设想一下，我们的脚本非常
冗长，并且我们有许多这个字符串的实例。如果我们想要更换一个标题，我们必须对脚本中的
许多地方做修改，这会是很大的工作量。如果我们能整理一下脚本，让这个字符串只出现一次
而不是多次，会怎样呢？这样会使今后的脚本维护工作更加轻松。我们可以这样做：
#!/bin/bash
#Programtooutputasysteminformationpage
title="SystemInformationReport"
echo"<HTML>
<HEAD>
<TITLE>$title</TITLE>
</HEAD>
<BODY>
<H1>$title</H1>
</BODY>
365
</HTML>"
通过创建一个名为 title的变量，并把“System Information Report”字符串赋值给它，我
们就可以利用参数展开功能，把这个字符串放到文件中的多个位置。
那么，我们怎样来创建一个变量呢？很简单，我们只管使用它。当 shell碰到一个变量的时
候，它会自动地创建它。这不同于许多编程语言，它们中的变量在使用之前，必须显式的声明
或是定义。关于这个问题，shell要求非常宽松，这可能会导致一些问题。例如，考虑一下在命
令行中发生的这种情形：
[me@linuxbox~]$foo="yes"
[me@linuxbox~]$echo$foo
yes
[me@linuxbox~]$echo$fool
[me@linuxbox~]$
首先我们把“yes”赋给变量 foo，然后用 echo命令来显示变量值。接下来，我们显示拼写
错误的变量名“fool”的变量值，然后得到一个空值。这是因为当 shell遇到 fool的时候,它很
高兴地创建了变量 fool并且赋给 fool一个空的默认值。因此，我们必须小心谨慎地拼写！同样
理解实例中究竟发生了什么事情也很重要。从我们以前学习 shell执行展开操作，我们知道这
个命令：
[me@linuxbox~]$echo$foo
经历了参数展开操作，然后得到：
[me@linuxbox~]$echoyes
然而这个命令：
[me@linuxbox~]$echo$fool
366
展开为：
[me@linuxbox~]$echo
这个空变量展开值为空！对于需要参数的命令来说，这会引起混乱。下面是一个例子：
[me@linuxbox~]$foo=foo.txt
[me@linuxbox~]$foo1=foo1.txt
[me@linuxbox~]$cp$foo$fool
cp:missingdestinationfileoperandafter`foo.txt'
Try`cp--help'formoreinformation.
我们给两个变量赋值，foo和 foo1。然后我们执行 cp操作，但是拼写错了第二个参数的名
字。参数展开之后，这个 cp命令只接受到一个参数，虽然它需要两个。
有一些关于变量名的规则：
1.变量名可由字母数字字符（字母和数字）和下划线字符组成。
2.变量名的第一个字符必须是一个字母或一个下划线。
3.变量名中不允许出现空格和标点符号。
单词“variable”意味着可变的值，并且在许多应用程序当中，都是以这种方式来使用变量
的。然而，我们应用程序中的变量，title，被用作一个常量。常量有一个名字且包含一个值，在
这方面就像是变量。不同之处是常量的值是不能改变的。在执行几何运算的应用程序中，我们
可以把 PI定义为一个常量，并把 3.1415赋值给它，用它来代替数字字面值。shell不能辨别变
量和常量；它们大多数情况下是为了方便程序员。一个常用惯例是指定大写字母来表示常量，
小写字母表示真正的变量。我们将修改我们的脚本来遵从这个惯例：
#!/bin/bash
#Programtooutputasysteminformationpage
TITLE="SystemInformationReportFor$HOSTNAME"
echo"<HTML>
<HEAD>
<TITLE>$TITLE</TITLE>
367
</HEAD>
<BODY>
<H1>$TITLE</H1>
</BODY>
</HTML>"
我们亦借此机会，通过在标题中添加 shell变量名 HOSTNAME，让标题变得活泼有趣些。
这个变量名是这台机器的网络名称。
注意：实际上，shell确实提供了一种方法，通过使用带有-r（只读）选项的内部命令 declare，
来强制常量的不变性。如果我们给 TITLE这样赋值：
那么随后所有给 TITLE的赋值都会被 shell阻止。这个功能极少被使用，但为了很早之前
的脚本，它仍然存在。
26.3.1给变量和常量赋值
这里是我们真正开始使用参数扩展知识的地方。正如我们所知道的，这样给变量赋值：
variable=value
这里的variable是变量的名字，value是一个字符串。不同于一些其它的编程语言，shell不
会在乎变量值的类型；它把它们都看作是字符串。通过使用带有-i选项的 declare命令，你可
以强制 shell把赋值限制为整数，但是，正如像设置变量为只读一样，极少这样做。
注意在赋值过程中，变量名、等号和变量值之间必须没有空格。那么，这些值由什么组成
呢？可以展开成字符串的任意值：
a=z#Assignthestring"z"tovariablea.
b="astring"#Embeddedspacesmustbewithinquotes.
c="astringand$b"#Otherexpansionssuchasvariablescanbe
#expandedintotheassignment.
368
d=$(ls-lfoo.txt)#Resultsofacommand.
e=$((5*7))#Arithmeticexpansion.
f="\t\tastring\n"#Escapesequencessuchastabsandnewlines.
可以在同一行中对多个变量赋值：
a=5b="astring"
在参数展开过程中，变量名可能被花括号“{}”包围着。由于变量名周围的上下文，其变得
不明确的情况下，这会很有帮助。这里，我们试图把一个文件名从 myfile改为 myfile1，使用
一个变量：
[me@linuxbox~]$filename="myfile"
[me@linuxbox~]$touch$filename
[me@linuxbox~]$mv$filename$filename1
mv:missingdestinationfileoperandafter`myfile'
Try`mv--help'formoreinformation.
这种尝试失败了，因为 shell把 mv命令的第二个参数解释为一个新的（并且空的）变量。
通过这种方法可以解决这个问题：
[me@linuxbox~]$mv$filename${filename}1
通过添加花括号，shell不再把末尾的 1解释为变量名的一部分。
我们将利用这个机会来添加一些数据到我们的报告中，即创建包括的日期和时间，以及创建
者的用户名：
#!/bin/bash
#Programtooutputasysteminformationpage
TITLE="SystemInformationReportFor$HOSTNAME"
CURRENT_TIME=$(date+"%x%r%Z")
369
TIME_STAMP="Generated$CURRENT_TIME,by$USER"
echo"<HTML>
<HEAD>
<TITLE>$TITLE</TITLE>
</HEAD>
<BODY>
<H1>$TITLE</H1>
<P>$TIME_STAMP</P>
</BODY>
</HTML>"
26.4HereDocuments
我们已经知道了两种不同的文本输出方法，两种方法都使用了 echo命令。还有第三种方法，叫
做 here document或者 here script。一个 here document是另外一种 I/O重定向形式，我们在
脚本文件中嵌入正文文本，然后把它发送给一个命令的标准输入。它这样工作：
command<<token
text
token
这里的 command是一个可以接受标准输入的命令名，token是一个用来指示嵌入文本结束
的字符串。我们将修改我们的脚本，来使用一个 here document:
#!/bin/bash
#Programtooutputasysteminformationpage
TITLE="SystemInformationReportFor$HOSTNAME"
CURRENT_TIME=$(date+"%x%r%Z")
TIME_STAMP="Generated$CURRENT_TIME,by$USER"
cat<<_EOF_
<HTML>
<HEAD>
<TITLE>$TITLE</TITLE>
</HEAD>
<BODY>
370
<H1>$TITLE</H1>
<P>$TIME_STAMP</P>
</BODY>
</HTML>
_EOF_
取代 echo命令，现在我们的脚本使用 cat命令和一个 here document。这个字符串 _EOF_
（意思是“文件结尾”，一个常见用法）被选作为 token，并标志着嵌入文本的结尾。注意这个
token必须在一行中单独出现，并且文本行中没有末尾的空格。
那么使用一个 here document的优点是什么呢？它很大程度上和 echo一样，除了默认情况
下，here documents中的单引号和双引号会失去它们在 shell中的特殊含义。这里有一个命令
中的例子：
[me@linuxbox~]$foo="sometext"
[me@linuxbox~]$cat<<_EOF_
>$foo
>"$foo"
>'$foo'
>\$foo
>_EOF_
sometext
"sometext"
'sometext'
$foo
正如我们所见到的，shell根本没有注意到引号。它把它们看作是普通的字符。这就允许我
们在一个 here document中可以随意的嵌入引号。对于我们的报告程序来说，这将是非常方便
的。
Here documents可以和任意能接受标准输入的命令一块使用。在这个例子中，我们使用了
一个 here document将一系列的命令传递到这个 ftp程序中，为的是从一个远端 FTP服务器
中得到一个文件：
#!/bin/bash
#ScripttoretrieveafileviaFTP
371
FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz
ftp-n<<_EOF_
open$FTP_SERVER
useranonymousme@linuxbox
cd$FTP_PATH
hash
get$REMOTE_FILE
bye
_EOF_
ls-l$REMOTE_FILE
如果我们把重定向操作符从“<<”改为“<<-”，shell会忽略在此 here document中开头
的 tab字符。这就能缩进一个 here document，从而提高脚本的可读性：
#!/bin/bash
#ScripttoretrieveafileviaFTP
FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz
ftp-n<<-_EOF_
open$FTP_SERVER
useranonymousme@linuxbox
cd$FTP_PATH
hash
get$REMOTE_FILE
bye
_EOF_
ls-l$REMOTE_FILE
26.5总结归纳
在这一章中，我们启动了一个项目，其带领我们领略了创建一个成功脚本的整个过程。同时我
们介绍了变量和常量的概念，以及怎样使用它们。它们是我们将找到的众多参数展开应用程序
中的第一批实例。我们也知道了怎样从我们的脚本文件中产生输出，及其各种各样嵌入文本块
372
的方法。
26.6拓展阅读
•关于 HTML的更多信息，查看下面的文章和教材：
http://en.wikipedia.org/wiki/Html
http://en.wikibooks.org/wiki/HTML_Programming
http://html.net/tutorials/html/
• Bash手册包括一节“HERE DOCUMENTS”的内容，其详细的讲述了这个功能。
373
27|自顶向下设计
随着程序变得更加庞大和复杂，设计、编码和维护它们也变得更加困难。对于任意一个大项目
而言，把繁重、复杂的任务分割为细小且简单的任务，往往是一个好主意。想象一下，我们试
图描述一个平凡无奇的工作，一位火星人要去市场买食物。我们可能通过下面一系列步骤来形
容整个过程：
•上车
•开车到市场
•停车
•买食物
•回到车中
•开车回家
•回到家中
然而，火星人可能需要更详细的信息。我们可以进一步细化子任务“停车”为这些步骤：
•找到停车位
•开车到停车位
•关闭引擎
•拉紧手刹
•下车
•锁车
374
这个“关闭引擎”子任务可以进一步细化为这些步骤，包括“关闭点火装置”，“移开点火
匙”等等，直到已经完整定义了要去市场买食物整个过程的每一个步骤。
这种先确定上层步骤，然后再逐步细化这些步骤的过程被称为自顶向下设计。这种技巧允
许我们把庞大而复杂的任务分割为许多小而简单的任务。自顶向下设计是一种常见的程序设计
方法，尤其适合 shell编程。
在这一章中，我们将使用自顶向下的设计方法来进一步开发我们的报告产生器脚本。
27.1Shell函数
目前我们的脚本执行以下步骤来产生这个 HTML文档：
•打开网页
•打开网页标头
•设置网页标题
•关闭网页标头
•打开网页主体部分
•输出网页标头
•输出时间戳
•关闭网页主体
•关闭网页
为了下一阶段的开发，我们将在步骤 7和 8之间添加一些额外的任务。这些将包括：
•系统正常运行时间和负载。这是自上次关机或重启之后系统的运行时间，以及在几个时
间间隔内当前运行在处理中的平均任务量。
•磁盘空间。系统中存储设备的总使用量。
•家目录空间。每个用户所使用的存储空间使用量。
如果对于每一个任务，我们都有相应的命令，那么通过命令替换，我们就能很容易地把它们
添加到我们的脚本中：
375
#!/bin/bash
#Programtooutputasysteminformationpage
TITLE="SystemInformationReportFor$HOSTNAME"
CURRENT_TIME=$(date+"%x%r%Z")
TIME_STAMP="Generated$CURRENT_TIME,by$USER"
cat<<_EOF_
<HTML>
<HEAD>
<TITLE>$TITLE</TITLE>
</HEAD>
<BODY>
<H1>$TITLE</H1>
<P>$TIME_STAMP</P>
$(report_uptime)
$(report_disk_space)
$(report_home_space)
</BODY>
</HTML>
_EOF_
我们能够用两种方法来创建这些额外的命令。我们可以分别编写三个脚本，并把它们放置
到环境变量 PATH所列出的目录下，或者我们也可以把这些脚本作为 shell函数嵌入到我们的
程序中。我们之前已经提到过，shell函数是位于其它脚本中的“微脚本”，作为自主程序。Shell
函数有两种语法形式：
functionname{
commands
return
}
and
name(){
commands
return
}
这里的 name是函数名，commands是一系列包含在函数中的命令。
376
两种形式是等价的，可以交替使用。下面我们将查看一个说明 shell函数使用方法的脚本：
1#!/bin/bash
2
3#Shellfunctiondemo
4
5functionfunct{
6echo"Step2"
7return
8}
9
10#Mainprogramstartshere
11
12echo"Step1"
13funct
14echo"Step3"
随着 shell读取这个脚本，它会跳过第 1行到第 11行的代码，因为这些文本行由注释和函数
定义组成。从第 12行代码开始执行，有一个 echo命令。第 13行会调用 shell函数 funct，然
后 shell会执行这个函数，就如执行其它命令一样。这样程序控制权会转移到第六行，执行第二
个 echo命令。然后再执行第 7行。这个 return命令终止这个函数，并把控制权交给函数调用
之后的代码（第 14行），从而执行最后一个 echo命令。注意为了使函数调用被识别出是 shell
函数，而不是被解释为外部程序的名字，在脚本中 shell函数定义必须出现在函数调用之前。
我们将给脚本添加最小的 shell函数定义：
#!/bin/bash
#Programtooutputasysteminformationpage
TITLE="SystemInformationReportFor$HOSTNAME"
CURRENT_TIME=$(date+"%x%r%Z")
TIME_STAMP="Generated$CURRENT_TIME,by$USER"
report_uptime(){
return
}
report_disk_space(){
return
}
377
report_home_space(){
return
}
cat<<_EOF_
<HTML>
<HEAD>
<TITLE>$TITLE</TITLE>
</HEAD>
<BODY>
<H1>$TITLE</H1>
<P>$TIME_STAMP</P>
$(report_uptime)
$(report_disk_space)
$(report_home_space)
</BODY>
</HTML>
_EOF_
Shell函数的命名规则和变量一样。一个函数必须至少包含一条命令。这条 return命令（是
可选的）满足要求。
27.2局部变量
目前我们所写的脚本中，所有的变量（包括常量）都是全局变量。全局变量在整个程序中保持
存在。对于许多事情来说，这很好，但是有时候它会使 shell函数的使用变得复杂。在 shell函
数中，经常期望会有局部变量。局部变量只能在定义它们的 shell函数中使用，并且一旦 shell
函数执行完毕，它们就不存在了。
局部变量的存在使得程序员可以使用可能已存在的变量，这些变量可以是全局变量，或者是
其它 shell函数中的局部变量，却不必担心潜在的名字冲突。
这里有一个实例脚本，其说明了怎样来定义和使用局部变量：
#!/bin/bash
#local-vars:scripttodemonstratelocalvariables
foo=0#globalvariablefoo
funct_1(){
localfoo#variablefoolocaltofunct_1
378
foo=1
echo"funct_1:foo=$foo"
}
funct_2(){
localfoo#variablefoolocaltofunct_2
foo=2
echo"funct_2:foo=$foo"
}
echo"global:foo=$foo"
funct_1
echo"global:foo=$foo"
funct_2
echo"global:foo=$foo"
正如我们所看到的，通过在变量名之前加上单词 local，来定义局部变量。这就创建了一个
只对其所在的 shell函数起作用的变量。在这个 shell函数之外，这个变量不再存在。当我们运
行这个脚本的时候，我们会看到这样的结果：
[me@linuxbox~]$local-vars
global:foo=0
funct_1:foo=1
global:foo=0
funct_2:foo=2
global:foo=0
我们看到对两个 shell函数中的局部变量 foo赋值，不会影响到在函数之外定义的变量 foo
的值。
这个功能就允许 shell函数能保持各自以及与它们所在脚本之间的独立性。这个非常有价
值，因为它帮忙阻止了程序各部分之间的相互干涉。这样 shell函数也可以移植。也就是说，按
照需求，shell函数可以在脚本之间进行剪切和粘贴。
27.3保持脚本运行
当开发程序的时候，保持程序的可执行状态非常有用。这样做，并且经常测试，我们就可以在
程序开发过程的早期检测到错误。这将使调试问题容易多了。例如，如果我们运行这个程序，
379
做一个小的修改，然后再次执行这个程序，最后发现一个问题，非常有可能这个最新的修改就
是问题的来源。通过添加空函数，程序员称之为 stub，我们可以在早期阶段证明程序的逻辑流
程。当构建一个 stub的时候，能够包含一些为程序员提供反馈信息的代码是一个不错的主意，
这些信息展示了正在执行的逻辑流程。现在看一下我们脚本的输出结果：
[me@linuxbox~]$sys_info_page
<HTML>
<HEAD>
<TITLE>SystemInformationReportFortwin2</TITLE>
</HEAD>
<BODY>
<H1>SystemInformationReportForlinuxbox</H1>
<P>Generated03/19/200904:02:10PMEDT,byme</P>
</BODY>
</HTML>
我们看到时间戳之后的输出结果中有一些空行，但是我们不能确定这些空行产生的原因。
如果我们修改这些函数，让它们包含一些反馈信息：
report_uptime(){
echo"Functionreport_uptimeexecuted."
return
}
report_disk_space(){
echo"Functionreport_disk_spaceexecuted."
return
}
report_home_space(){
echo"Functionreport_home_spaceexecuted."
return
}
然后再次运行这个脚本：
380
[me@linuxbox~]$sys_info_page
<HTML>
<HEAD>
<TITLE>SystemInformationReportForlinuxbox</TITLE>
</HEAD>
<BODY>
<H1>SystemInformationReportForlinuxbox</H1>
<P>Generated03/20/200905:17:26AMEDT,byme</P>
Functionreport_uptimeexecuted.
Functionreport_disk_spaceexecuted.
Functionreport_home_spaceexecuted.
</BODY>
</HTML>
现在我们看到，事实上，执行了三个函数。
我们的函数框架已经各就各位并且能工作，是时候更新一些函数代码了。首先，是
report_uptime函数：
report_uptime(){
cat<<-_EOF_
<H2>SystemUptime</H2>
<PRE>$(uptime)</PRE>
_EOF_
return
}
这些代码相当直截了当。我们使用一个 here文档来输出标题和 uptime命令的输出结果，
命令结果被 <PRE>标签包围，为的是保持命令的输出格式。这个 report_disk_space函数类
似：
report_disk_space(){
cat<<-_EOF_
<H2>DiskSpaceUtilization</H2>
<PRE>$(df-h)</PRE>
381
_EOF_
return
}
这个函数使用 df -h命令来确定磁盘空间的数量。最后，我们将建造 report_home_space
函数：
report_home_space(){
cat<<-_EOF_
<H2>HomeSpaceUtilization</H2>
<PRE>$(du-sh/home/*)</PRE>
_EOF_
return
}
我们使用带有 -sh选项的 du命令来完成这个任务。然而，这并不是此问题的完整解决方
案。虽然它会在一些系统（例如 Ubuntu）中起作用，但是在其它系统中它不工作。这是因为许
多系统会设置家目录的权限，以此阻止其它用户读取它们，这是一个合理的安全措施。在这些
系统中，这个 report_home_space函数，只有用超级用户权限执行我们的脚本时，才会工作。
一个更好的解决方案是让脚本能根据用户的使用权限来调整自己的行为。我们将在下一章中讨
论这个问题。
你的.bashrc文件中的 shell函数
Shell函数完美地替代了别名，并且实际上是创建个人所用的小命令的首选方法。
别名非常局限于命令的种类和它们支持的 shell功能，然而 shell函数允许任何可以
编写脚本的东西。例如，如果我们喜欢为我们的脚本开发的这个 report_disk_space
shell函数，我们可以为我们的.bashrc文件创建一个相似的名为 ds的函数：
ds(){
echo“DiskSpaceUtilizationFor$HOSTNAME”
df-h
}
382
27.4总结归纳
这一章中，我们介绍了一种常见的程序设计方法，叫做自顶向下设计，并且我们知道了怎样使
用 shell函数按照要求来完成逐步细化的任务。我们也知道了怎样使用局部变量使 shell函数独
立于其它函数，以及其所在程序的其它部分。这就有可能使 shell函数以可移植的方式编写，并
且能够重复使用，通过把它们放置到多个程序中；节省了大量的时间。
27.5拓展阅读
• Wikipedia上面有许多关于软件设计原理的文章。这里是一些好文章：
http://en.wikipedia.org/wiki/Top-down_design
http://en.wikipedia.org/wiki/Subroutines
383
28|流程控制：if分支结构
在上一章中，我们遇到一个问题。怎样使我们的报告生成器脚本能适应运行此脚本的用户的权
限？这个问题的解决方案要求我们能找到一种方法，在脚本中基于测试条件结果，来“改变方
向”。用编程术语表达，就是我们需要程序可以分支。让我们考虑一个简单的用伪码表示的逻
辑实例，伪码是一种模拟的计算机语言，为的是便于人们理解：
X=5
IfX=5,then:
Say“Xequals5.”
Otherwise:
Say“Xisnotequalto5.”
这就是一个分支的例子。根据条件，“Does X = 5?”做一件事情，“Say X equals 5,”否则，
做另一件事情，“Say X is not equal to 5.”
28.1if
使用 shell，我们可以编码上面的逻辑，如下所示：
x=5
if[$x=5];then
echo"xequals5."
else
echo"xdoesnotequal5."
fi
或者我们可以直接在命令行中输入以上代码（略有缩短）：
384
[me@linuxbox~]$x=5
[me@linuxbox~]$if[$x=5];thenecho"equals5";elseecho"does
notequal5";fi
equals5
[me@linuxbox~]$x=0
[me@linuxbox~]$if[$x=5];thenecho"equals5";elseecho"does
notequal5";fi
doesnotequal5
在这个例子中，我们执行了两次这个命令。第一次是，把 x的值设置为 5，从而导致输出字
符串“equals 5”,第二次是，把 x的值设置为 0，从而导致输出字符串“does not equal 5”。
这个 if语句语法如下：
ifcommands;then
commands
[elifcommands;then
commands...]
[else
commands]
fi
这里的 commands是指一系列命令。第一眼看到会有点儿困惑。但是在我们弄清楚这些语
句之前，我们必须看一下 shell是如何评判一个命令的成功与失败的。
28.2退出状态
当命令执行完毕后，命令（包括我们编写的脚本和 shell函数）会给系统发送一个值，叫做退出
状态。这个值是一个 0到 255之间的整数，说明命令执行成功或是失败。按照惯例，一个零值
说明成功，其它所有值说明失败。Shell提供了一个参数，我们可以用它检查退出状态。用具体
实例看一下：
[me@linuxbox~]$ls-d/usr/bin
/usr/bin
385
[me@linuxbox~]$echo$?
0
[me@linuxbox~]$ls-d/bin/usr
ls:cannotaccess/bin/usr:Nosuchfileordirectory
[me@linuxbox~]$echo$?
2
在这个例子中，我们执行了两次 ls命令。第一次，命令执行成功。如果我们显示参数$?
的值，我们看到它是零。我们第二次执行 ls命令的时候，产生了一个错误，并再次查看参数
$?。这次它包含一个数字 2，表明这个命令遇到了一个错误。有些命令使用不同的退出值，来
诊断错误，而许多命令当它们执行失败的时候，会简单地退出并发送一个数字 1。手册页中经
常会包含一章标题为“退出状态”的内容，描述了使用的代码。然而，一个零总是表明成功。
shell提供了两个极其简单的内部命令，它们不做任何事情，除了以一个 0或 1退出状态来
终止执行。True命令总是执行成功，而 false命令总是执行失败：
[me@linuxbox~]$true
[me@linuxbox~]$echo$?
0
[me@linuxbox~]$false
[me@linuxbox~]$echo$?
1
我们能够使用这些命令，来看一下 if语句是怎样工作的。If语句真正做的事情是计算命令
执行成功或失败：
[me@linuxbox~]$iftrue;thenecho"It'strue.";fi
It'strue.
[me@linuxbox~]$iffalse;thenecho"It'strue.";fi
[me@linuxbox~]$
当 if之后的命令执行成功的时候，命令 echo “It’s true.”将会执行，否则此命令不执行。如
果 if之后跟随一系列命令，则将计算列表中的最后一个命令：
386
[me@linuxbox~]$iffalse;true;thenecho"It'strue.";fi
It'strue.
[me@linuxbox~]$iftrue;false;thenecho"It'strue.";fi
[me@linuxbox~]$
28.3测试
到目前为止，经常与 if一块使用的命令是 test。这个 test命令执行各种各样的检查与比较。它
有两种等价模式：
testexpression
比较流行的格式是：
[expression]
这里的 expression是一个表达式，其执行结果是 true或者是 false。当表达式为真时，这个
test命令返回一个零退出状态，当表达式为假时，test命令退出状态为 1。
28.3.1文件表达式
以下表达式被用来计算文件状态：
表达式如果下列条件为真则返回 True
file1 -ef file2 file1和 file2拥有相同的索引号（通过硬链接两个文件名指
向相同的文件）。
file1 -nt file2 file1新于 file2。
file1 -ot file2 file1早于 file2。
-b file file存在并且是一个块（设备）文件。
-c file file存在并且是一个字符（设备）文件。
-d file file存在并且是一个目录。
-e file file存在。
387
-f file file存在并且是一个普通文件。
-g file file存在并且设置了组 ID。
-G file file存在并且由有效组 ID拥有。
-k file file存在并且设置了它的“sticky bit”。
-L file file存在并且是一个符号链接。
-O file file存在并且由有效用户 ID拥有。
-p file file存在并且是一个命名管道。
-r file file存在并且可读（有效用户有可读权限）。
-s file file存在且其长度大于零。
-S file file存在且是一个网络 socket。
-t fd fd是一个定向到终端／从终端定向的文件描述符。这可以
被用来决定是否重定向了标准输入／输出错误。
-u file file存在并且设置了 setuid位。
-w file file存在并且可写（有效用户拥有可写权限）。
-x file file存在并且可执行（有效用户有执行／搜索权限）。
表 28-1:测试文件表达式
这里我们有一个脚本说明了一些文件表达式：
#!/bin/bash
#test-file:Evaluatethestatusofafile
FILE=~/.bashrc
if[-e"$FILE"];then
if[-f"$FILE"];then
echo"$FILEisaregularfile."
fi
if[-d"$FILE"];then
echo"$FILEisadirectory."
fi
if[-r"$FILE"];then
echo"$FILEisreadable."
fi
if[-w"$FILE"];then
echo"$FILEiswritable."
388
fi
if[-x"$FILE"];then
echo"$FILEisexecutable/searchable."
fi
else
echo"$FILEdoesnotexist"
exit1
fi
exit
这个脚本会计算赋值给常量 FILE的文件，并显示计算结果。对于此脚本有两点需要注意。
第一个，在表达式中参数$FILE是怎样被引用的。引号并不是必需的，但这是为了防范空参
数。如果$FILE的参数展开是一个空值，就会导致一个错误（操作符将会被解释为非空的字符
串而不是操作符）。用引号把参数引起来就确保了操作符之后总是跟随着一个字符串，即使字
符串为空。第二个，注意脚本末尾的 exit命令。这个 exit命令接受一个单独的，可选的参数，
其成为脚本的退出状态。当不传递参数时，退出状态默认为零。以这种方式使用 exit命令，则
允许此脚本提示失败如果$FILE展开成一个不存在的文件名。这个 exit命令出现在脚本中的
最后一行，是一个当一个脚本“运行到最后”（到达文件末尾），不管怎样，默认情况下它以退
出状态零终止。
类似地，通过带有一个整数参数的 return命令，shell函数可以返回一个退出状态。如果我
们打算把上面的脚本转变为一个 shell函数，为了在更大的程序中包含此函数，我们用 return
语句来代替 exit命令，则得到期望的行为：
test_file(){
#test-file:Evaluatethestatusofafile
FILE=~/.bashrc
if[-e"$FILE"];then
if[-f"$FILE"];then
echo"$FILEisaregularfile."
fi
if[-d"$FILE"];then
echo"$FILEisadirectory."
fi
if[-r"$FILE"];then
echo"$FILEisreadable."
fi
389
if[-w"$FILE"];then
echo"$FILEiswritable."
fi
if[-x"$FILE"];then
echo"$FILEisexecutable/searchable."
fi
else
echo"$FILEdoesnotexist"
return1
fi
}
28.3.2字符串表达式
以下表达式用来计算字符串：
表达式如果下列条件为真则返回 True
string string不为 null。
-n string字符串 string的长度大于零。
-z string字符串 string的长度为零。
string1 = string2 string1和 string2相同。单或双等号都可以，不
string1 == string2过双等号更受欢迎。
string1 != string2 string1和 string2不相同。
string1 > string2 sting1排列在 string2之后。
string1 < string2 string1排列在 string2之前。
表 28-2:测试字符串表达式
警告：当与 test一块使用的时候，>和 <表达式操作符必须用引号引起来（或者是用反斜
杠转义）。如果不这样，它们会被 shell解释为重定向操作符，造成潜在的破坏结果。同时也要
注意虽然 bash文档声明排序遵从当前语系的排列规则，但并不这样。将来的 bash版本，包含
4.0，使用 ASCII（POSIX）排序规则。
390
这是一个演示这些问题的脚本：
#!/bin/bash
#test-string:evaluatethevalueofastring
ANSWER=maybe
if[-z"$ANSWER"];then
echo"Thereisnoanswer.">&2
exit1
fi
if["$ANSWER"="yes"];then
echo"TheanswerisYES."
elif["$ANSWER"="no"];then
echo"TheanswerisNO."
elif["$ANSWER"="maybe"];then
echo"TheanswerisMAYBE."
else
echo"TheanswerisUNKNOWN."
fi
在这个脚本中，我们计算常量 ANSWER。我们首先确定是否此字符串为空。如果为空，我
们就终止脚本，并把退出状态设为 1。注意这个应用于 echo命令的重定向操作。其把错误信息
“There is no answer.”重定向到标准错误，这是处理错误信息的“正确”方法。如果字符串不
为空，我们就计算字符串的值，看看它是否等于“yes,”“no,”或者“maybe”。为此使用了 elif，
它是“else if”的简写。通过使用 elif，我们能够构建更复杂的逻辑测试。
28.3.3整型表达式
下面的表达式用于整数：
表达式如果为真...
integer1 -eq integer2 integer1等于 integer2。
integer1 -ne integer2 integer1不等于 integer2。
integer1 -le integer2 integer1小于或等于 integer2。
integer1 -lt integer2 integer1小于 integer2。
integer1 -ge integer2 integer1大于或等于 integer2。
integer1 -gt integer2 integer1大于 integer2。
表 28-3:测试整数表达式
391
这里是一个演示以上表达式用法的脚本：
#!/bin/bash
#test-integer:evaluatethevalueofaninteger.
INT=-5
if[-z"$INT"];then
echo"INTisempty.">&2
exit1
fi
if[$INT-eq0];then
echo"INTiszero."
else
if[$INT-lt0];then
echo"INTisnegative."
else
echo"INTispositive."
fi
if[$((INT%2))-eq0];then
echo"INTiseven."
else
echo"INTisodd."
fi
fi
这个脚本中有趣的地方是怎样来确定一个整数是偶数还是奇数。通过用模数 2对数字执行
求模操作，就是用数字来除以 2，并返回余数，从而知道数字是偶数还是奇数。
28.4更现代的测试版本
目前的 bash版本包括一个复合命令，作为加强的 test命令替代物。它使用以下语法：
[[expression]]
这里，类似于 test，expression是一个表达式，其计算结果为真或假。这个[[]]命令非
常相似于 test命令（它支持所有的表达式），但是增加了一个重要的新的字符串表达式：
392
string1=~regex
其返回值为真，如果 string1匹配扩展的正则表达式 regex。这就为执行比如数据验证等任
务提供了许多可能性。在我们前面的整数表达式示例中，如果常量 INT包含除了整数之外的任
何数据，脚本就会运行失败。这个脚本需要一种方法来证明此常量包含一个整数。使用[[]]
和=字符串表达式操作符，我们能够这样来改进脚本：
#!/bin/bash
#test-integer2:evaluatethevalueofaninteger.
INT=-5
if[["$INT"=~^-?[0-9]+$]];then
if[$INT-eq0];then
echo"INTiszero."
else
if[$INT-lt0];then
echo"INTisnegative."
else
echo"INTispositive."
fi
if[$((INT%2))-eq0];then
echo"INTiseven."
else
echo"INTisodd."
fi
fi
else
echo"INTisnotaninteger.">&2
exit1
fi
通过应用正则表达式，我们能够限制 INT的值只是字符串，其开始于一个可选的减号，随
后是一个或多个数字。这个表达式也消除了空值的可能性。
[[]]添加的另一个功能是==操作符支持类型匹配，正如路径名展开所做的那样。例如：
393
[me@linuxbox~]$FILE=foo.bar
[me@linuxbox~]$if[[$FILE==foo.*]];then
>echo"$FILEmatchespattern'foo.*'"
>fi
foo.barmatchespattern'foo.*'
这就使[[]]有助于计算文件和路径名。
28.5(())-为整数设计
除了[[]]复合命令之外，bash也提供了(())复合命令，其有利于操作整数。它支持一套
完整的算术计算，我们将在第 35章中讨论这个主题。
(())被用来执行算术真测试。如果算术计算的结果是非零值，则其测试值为真。
[me@linuxbox~]$if((1));thenecho"Itistrue.";fi
Itistrue.
[me@linuxbox~]$if((0));thenecho"Itistrue.";fi
[me@linuxbox~]$
使用(())，我们能够略微简化 test-integer2脚本，像这样：
#!/bin/bash
#test-integer2a:evaluatethevalueofaninteger.
INT=-5
if[["$INT"=~^-?[0-9]+$]];then
if((INT==0));then
echo"INTiszero."
else
if((INT<0));then
echo"INTisnegative."
else
echo"INTispositive."
fi
if((((INT%2))==0));then
394
echo"INTiseven."
else
echo"INTisodd."
fi
fi
else
echo"INTisnotaninteger.">&2
exit1
fi
注意我们使用小于和大于符号，以及 ==用来测试是否相等。这是使用整数较为自然的语
法了。也要注意，因为复合命令(())是 shell语法的一部分，而不是一个普通的命令，而且
它只处理整数，所以它能够通过名字识别出变量，而不需要执行展开操作。我们将在第 35中
进一步讨论(())命令和相关的算术展开操作。
28.6结合表达式
也有可能把表达式结合起来创建更复杂的计算。通过使用逻辑操作符来结合表达式。我们在第
18章中学习 find命令的时候已经知道了这些。有三个用于 test和[[]]的逻辑操作。它们是
AND、OR和 NOT。test和[[]]使用不同的操作符来表示这些操作：
操作符测试 [[ ]] and (( ))
AND -a &&
OR -o ||
NOT ! !
表 28-4:逻辑操作符
这里有一个 AND操作的示例。下面的脚本决定了一个整数是否属于某个范围内的值：
#!/bin/bash
#test-integer3:determineifanintegeriswithina
#specifiedrangeofvalues.
MIN_VAL=1
MAX_VAL=100
INT=50
395
if[["$INT"=~^-?[0-9]+$]];then
if[[INT-geMIN_VAL&&INT-leMAX_VAL]];then
echo"$INTiswithin$MIN_VALto$MAX_VAL."
else
echo"$INTisoutofrange."
fi
else
echo"INTisnotaninteger.">&2
exit1
fi
我们也可以对表达式使用圆括号，为的是分组。如果不使用括号，那么否定只应用于第一个
表达式，而不是两个组合的表达式。用 test可以这样来编码：
if[!\($INT-ge$MIN_VAL-a$INT-le$MAX_VAL\)];then
echo"$INTisoutside$MIN_VALto$MAX_VAL."
else
echo"$INTisinrange."
fi
因为 test使用的所有的表达式和操作符都被 shell看作是命令参数（不像[[]]和(())
），对于 bash有特殊含义的字符，比如说 <，>，(，和)，必须引起来或者是转义。
知道了 test和[[]]基本上完成相同的事情，哪一个更好呢？test更传统（是 POSIX的
一部分），然而[[]]特定于 bash。知道怎样使用 test很重要，因为它被非常广泛地应用，但
是显然[[]]更有用，并更易于编码。
可移植性是头脑狭隘人士的心魔
如果你和“真正的”Unix用户交谈，你很快就会发现他们大多数人不是非常喜
欢 Linux。他们认为 Linux肮脏且不干净。Unix追随者的一个宗旨是，一切都应
“可移植的”。这意味着你编写的任意一个脚本都应当无需修改，就能运行在任何一
个类 Unix的系统中。
Unix用户有充分的理由相信这一点。在 POSIX之前，Unix用户已经看到了命
令的专有扩展以及 shell对 Unix世界的所做所为，他们自然会警惕 Linux对他们心
爱系统的影响。
396
但是可移植性有一个严重的缺点。它防碍了进步。它要求做事情要遵循“最低
常见标准”。在 shell编程这种情况下，它意味着一切要与 sh兼容，最初的 Bourne
shell。
这个缺点是一个专有软件供应商用来为他们专有的扩展做辩解的借口，只有他们
称他们为“创新”。但是他们只是为他们的客户锁定设备。
GNU工具，比如说 bash，就没有这些限制。他们通过支持标准和普遍地可用性
来鼓励可移植性。你几乎可以在所有类型的系统中安装 bash和其它的 GNU工具，
甚至是 Windows，而没有损失。所以就感觉可以自由的使用 bash的所有功能。它
是真正的可移植。
28.7控制操作符：分支的另一种方法
bash支持两种可以执行分支任务的控制操作符。&&（AND）和||（OR）操作符作用如同复合命
令[[]]中的逻辑操作符。这是语法：
command1&&command2
和
command1||command2
理解这些操作很重要。对于 &&操作符，先执行 command1，如果并且只有如果 command1
执行成功后，才会执行 command2。对于 ||操作符，先执行 command1，如果并且只有如果
command1执行失败后，才会执行 command2。
在实际中，它意味着我们可以做这样的事情：
[me@linuxbox~]$mkdirtemp&&cdtemp
这会创建一个名为 temp的目录，并且若它执行成功后，当前目录会更改为 temp。第二个
命令会尝试执行只有当 mkdir命令执行成功之后。同样地，一个像这样的命令：
397
[me@linuxbox~]$[-dtemp]||mkdirtemp
会测试目录 temp是否存在，并且只有测试失败之后，才会创建这个目录。这种构造类型非
常有助于在脚本中处理错误，这个主题我们将会在随后的章节中讨论更多。例如，我们在脚本
中可以这样做：
[-dtemp]||exit1
如果这个脚本要求目录 temp，且目录不存在，然后脚本会终止，并返回退出状态 1。
28.8总结
这一章开始于一个问题。我们怎样使sys_info_page脚本来检测是否用户拥有权限来读
取所有的家目录？根据我们的 if知识，我们可以解决这个问题，通过把这些代码添加到
report_home_space函数中：
report_home_space(){
if[[$(id-u)-eq0]];then
cat<<-_EOF_
<H2>HomeSpaceUtilization(AllUsers)</H2>
<PRE>$(du-sh/home/*)</PRE>
else
cat<<-_EOF_
<H2>HomeSpaceUtilization($USER)</H2>
<PRE>$(du-sh$HOME)</PRE>
fi
return
}
我们计算 id命令的输出结果。通过带有 -u选项的 id命令，输出有效用户的数字用户 ID
号。超级用户总是零，其它每个用户是一个大于零的数字。知道了这点，我们能够构建两种不
同的 here文档，一个利用超级用户权限，另一个限制于用户拥有的家目录。
398
我们将暂别sys_info_page程序，但不要着急。它还会回来。同时，当我们继续工作的时
候，将会讨论一些我们需要的话题。
28.9拓展阅读
bash手册页中有几部分对本章中涵盖的主题提供了更详细的内容：
• Lists (讨论控制操作符||和&& )
• Compound Commands (讨论[[]],(())和 if )
• CONDITIONAL EXPRESSIONS（条件表达式）
• SHELL BUILTIN COMMANDS (讨论 test )
进一步，Wikipedia中有一篇关于伪代码概念的好文章：
http://en.wikipedia.org/wiki/Pseudocode
399
29|读取键盘输入
到目前为止我们编写的脚本都缺乏一项在大多数计算机程序中都很常见的功能－交互性。也就
是，程序与用户进行交互的能力。虽然许多程序不必是可交互的，但一些程序却得到益处，能
够直接接受用户的输入。以这个前面章节中的脚本为例：
#!/bin/bash
#test-integer2:evaluatethevalueofaninteger.
INT=-5
if[["$INT"=~^-?[0-9]+$]];then
if[$INT-eq0];then
echo"INTiszero."
else
if[$INT-lt0];then
echo"INTisnegative."
else
echo"INTispositive."
fi
if[$((INT%2))-eq0];then
echo"INTiseven."
else
echo"INTisodd."
fi
fi
else
echo"INTisnotaninteger.">&2
exit1
fi
每次我们想要改变 INT数值的时候，我们必须编辑这个脚本。如果脚本能请求用户输入数
值，那么它会更加有用处。在这个脚本中，我们将看一下我们怎样给程序增加交互性功能。
400
29.1read-从标准输入读取数值
这个 read内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使
用重定向的时候，读取文件中的一行数据。这个命令有以下语法形式：
read[-options][variable...]
这里的 options是下面列出的可用选项中的一个或多个，且 variable是用来存储输入数值的
一个或多个变量名。如果没有提供变量名，shell变量 REPLY会包含数据行。
基本上，read会把来自标准输入的字段赋值给具体的变量。如果我们修改我们的整数求值
脚本，让其使用 read，它可能看起来像这样：
#!/bin/bash
#read-integer:evaluatethevalueofaninteger.
echo-n"Pleaseenteraninteger->"
readint
if[["$int"=~^-?[0-9]+$]];then
if[$int-eq0];then
echo"$intiszero."
else
if[$int-lt0];then
echo"$intisnegative."
else
echo"$intispositive."
fi
if[$((int%2))-eq0];then
echo"$intiseven."
else
echo"$intisodd."
fi
fi
else
echo"Inputvalueisnotaninteger.">&2
exit1
fi
401
我们使用带有 -n选项（其会删除输出结果末尾的换行符）的 echo命令，来显示提示信息，
然后使用 read来读入变量 int的数值。运行这个脚本得到以下输出：
[me@linuxbox~]$read-integer
Pleaseenteraninteger->5
5ispositive.
5isodd.
read可以给多个变量赋值，正如下面脚本中所示：
#!/bin/bash
#read-multiple:readmultiplevaluesfromkeyboard
echo-n"Enteroneormorevalues>"
readvar1var2var3var4var5
echo"var1='$var1'"
echo"var2='$var2'"
echo"var3='$var3'"
echo"var4='$var4'"
echo"var5='$var5'"
在这个脚本中，我们给五个变量赋值并显示其结果。注意当给定不同个数的数值后，read
怎样操作：
[me@linuxbox~]$read-multiple
Enteroneormorevalues>abcde
var1='a'
var2='b'
var3='c'
var4='d'
var5='e'
[me@linuxbox~]$read-multiple
Enteroneormorevalues>a
var1='a'
var2=''
var3=''
402
var4=''
var5=''
[me@linuxbox~]$read-multiple
Enteroneormorevalues>abcdefg
var1='a'
var2='b'
var3='c'
var4='d'
var5='efg'
如果 read命令接受到变量值数目少于期望的数字，那么额外的变量值为空，而多余的输入
数据则会被包含到最后一个变量中。如果 read命令之后没有列出变量名，则一个 shell变量，
REPLY，将会包含所有的输入：
#!/bin/bash
#read-single:readmultiplevaluesintodefaultvariable
echo-n"Enteroneormorevalues>"
read
echo"REPLY='$REPLY'"
这个脚本的输出结果是：
[me@linuxbox~]$read-single
Enteroneormorevalues>abcd
REPLY='abcd'
29.1.1选项
read支持以下选项：
选项说明
-a array把输入赋值到数组 array中，从索引号零开始。我们将在第
36章中讨论数组问题。
-d delimiter用字符串 delimiter中的第一个字符指示输入结束，而不是
一个换行符。
403
-e使用 Readline来处理输入。这使得与命令行相同的方式编
辑输入。
-n num读取 num个输入字符，而不是整行。
-p prompt为输入显示提示信息，使用字符串 prompt。
-r Raw mode.不把反斜杠字符解释为转义字符。
-s Silent mode.不会在屏幕上显示输入的字符。当输入密码和
其它确认信息的时候，这会很有帮助。
-t seconds超时.几秒钟后终止输入。若输入超时，read会返回一个非
零退出状态。
-u fd使用文件描述符 fd中的输入，而不是标准输入。
表 29-1: read选项
使用各种各样的选项，我们能用 read完成有趣的事情。例如，通过-p选项，我们能够提供
提示信息：
#!/bin/bash
#read-single:readmultiplevaluesintodefaultvariable
read-p"Enteroneormorevalues>"
echo"REPLY='$REPLY'"
通过 -t和 -s选项，我们可以编写一个这样的脚本，读取“秘密”输入，并且如果在特定的
时间内输入没有完成，就终止输入。
#!/bin/bash
#read-secret:inputasecretpassphrase
ifread-t10-sp"Entersecretpassphrase>"secret_pass;then
echo"\nSecretpassphrase='$secret_pass'"
else
echo"\nInputtimedout">&2
exit1
fi
404
这个脚本提示用户输入一个密码，并等待输入 10秒钟。如果在特定的时间内没有完成输入，
则脚本会退出并返回一个错误。因为包含了一个 -s选项，所以输入的密码不会出现在屏幕上。
29.2IFS
通常，shell对提供给 read的输入按照单词进行分离。正如我们所见到的，这意味着多个由一
个或几个空格分离开的单词在输入行中变成独立的个体，并被 read赋值给单独的变量。这种行
为由 shell变量 __IFS__（内部字符分隔符）配置。IFS的默认值包含一个空格，一个 tab，
和一个换行符，每一个都会把字段分割开。
我们可以调整IFS的值来控制输入字段的分离。例如，这个 /etc/passwd文件包含的数据
行使用冒号作为字段分隔符。通过把IFS的值更改为单个冒号，我们可以使用 read读取 /etc/
passwd中的内容，并成功地把字段分给不同的变量。这个就是做这样的事情：
#!/bin/bash
#read-ifs:readfieldsfromafile
FILE=/etc/passwd
read-p"Enterausername>"user_name
file_info=$(grep"^$user_name:"$FILE)
if[-n"$file_info"];then
IFS=":"readuserpwuidgidnamehomeshell<<<"$file_info"
echo"User='$user'"
echo"UID='$uid'"
echo"GID='$gid'"
echo"FullName='$name'"
echo"HomeDir.='$home'"
echo"Shell='$shell'"
else
echo"Nosuchuser'$user_name'">&2
exit1
fi
这个脚本提示用户输入系统中一个帐户的用户名，然后显示在文件 /etc/passwd/文件中关
于用户记录的不同字段。这个脚本包含有趣的两行。第一个是：
file_info=$(grep"^$user_name:"$FILE)
405
这一行把 grep命令的输入结果赋值给变量 file_info。grep命令使用的正则表达式确保用户
名只会在 /etc/passwd文件中匹配一行。
第二个有意思的一行是：
IFS=":"readuserpwuidgidnamehomeshell<<<"$file_info"
这一行由三部分组成：对一个变量的赋值操作，一个带有一串参数的 read命令，和一个奇
怪的新的重定向操作符。我们首先看一下变量赋值。
Shell允许在一个命令之前给一个或多个变量赋值。这些赋值会暂时改变之后的命令的环境
变量。在这种情况下，IFS的值被改成一个冒号。等效的，我们也可以这样写：
OLD_IFS="$IFS"
IFS=":"
readuserpwuidgidnamehomeshell<<<"$file_info"
IFS="$OLD_IFS"
我们先存储 IFS的值，然后赋给一个新值，再执行 read命令，最后把 IFS恢复原值。显
然，完成相同的任务，在命令之前放置变量名赋值是一种更简明的方式。
这个<<<操作符指示一个 here字符串。一个 here字符串就像一个 here文档，只是比较简
短，由单个字符串组成。在这个例子中，来自 /etc/passwd文件的数据发送给 read命令的标准
输入。我们可能想知道为什么选择这种相当晦涩的方法而不是：
echo"$file_info"|IFS=":"readuserpwuidgidnamehomeshell
你不能把管道用在 read上
虽然通常 read命令接受标准输入，但是你不能这样做：
echo“foo”|read
我们期望这个命令能生效，但是它不能。这个命令将显示成功，但是 REPLY变
量总是为空。为什么会这样？
406
答案与 shell处理管道线的方式有关系。在 bash（和其它 shells，例如 sh）中，
管道线会创建子 shell。这个子 shell是为了执行执行管线中的命令而创建的 shell和
它的环境的副本。上面示例中，read命令将在子 shell中执行。
在类 Unix的系统中，子 shell执行的时候，会为进程创建父环境的副本。当进
程结束之后，该副本就会被破坏掉。这意味着一个子 shell永远不能改变父进程的
环境。read赋值变量，然后会变为环境的一部分。在上面的例子中，read在它的子
shell环境中，把 foo赋值给变量 REPLY，但是当命令退出后，子 shell和它的环境
将被破坏掉，这样赋值的影响就会消失。
使用 here字符串是解决此问题的一种方法。另一种方法将在 37章中讨论。
29.3校正输入
从键盘输入这种新技能，带来了额外的编程挑战，校正输入。很多时候，一个良好编写的程序
与一个拙劣程序之间的区别就是程序处理意外的能力。通常，意外会以错误输入的形式出现。
在前面章节中的计算程序，我们已经这样做了一点儿，我们检查整数值，甄别空值和非数字字
符。每次程序接受输入的时候，执行这类的程序检查非常重要，为的是避免无效数据。对于由
多个用户共享的程序，这个尤为重要。如果一个程序只使用一次且只被作者用来执行一些特殊
任务，那么为了经济利益而忽略这些保护措施，可能会被原谅。即使这样，如果程序执行危险
任务，比如说删除文件，所以最好包含数据校正，以防万一。
这里我们有一个校正各种输入的示例程序：
#!/bin/bash
#read-validate:validateinput
invalid_input(){
echo"Invalidinput'$REPLY'">&2
exit1
}
read-p"Enterasingleitem>"
#inputisempty(invalid)
[[-z$REPLY]]&&invalid_input
#inputismultipleitems(invalid)
(($(echo$REPLY|wc-w)>1))&&invalid_input
#isinputavalidfilename?
407
if[[$REPLY=~^[-[:alnum:]\._]+$]];then
echo"'$REPLY'isavalidfilename."
if[[-e$REPLY]];then
echo"Andfile'$REPLY'exists."
else
echo"However,file'$REPLY'doesnotexist."
fi
#isinputafloatingpointnumber?
if[[$REPLY=~^-?[[:digit:]]*\.[[:digit:]]+$]];then
echo"'$REPLY'isafloatingpointnumber."
else
echo"'$REPLY'isnotafloatingpointnumber."
fi
#isinputaninteger?
if[[$REPLY=~^-?[[:digit:]]+$]];then
echo"'$REPLY'isaninteger."
else
echo"'$REPLY'isnotaninteger."
fi
else
echo"Thestring'$REPLY'isnotavalidfilename."
fi
这个脚本提示用户输入一个数字。随后，分析这个数字来决定它的内容。正如我们所看到
的，这个脚本使用了许多我们已经讨论过的概念，包括 shell函数，[[]]，(())，控制操作符
&&，以及if和一些正则表达式。
29.4菜单
一种常见的交互类型称为菜单驱动。在菜单驱动程序中，呈现给用户一系列选择，并要求用户
选择一项。例如，我们可以想象一个展示以下信息的程序：
PleaseSelect:
1.DisplaySystemInformation
2.DisplayDiskSpace
3.DisplayHomeSpaceUtilization
0.Quit
408
Enterselection[0-3]>
使用我们从编写 sys_info_page程序中所学到的知识，我们能够构建一个菜单驱动程序来
执行上述菜单中的任务：
#!/bin/bash
#read-menu:amenudrivensysteminformationprogram
clear
echo"
PleaseSelect:
1.DisplaySystemInformation
2.DisplayDiskSpace
3.DisplayHomeSpaceUtilization
0.Quit
"
read-p"Enterselection[0-3]>"
if[[$REPLY=~^[0-3]$]];then
if[[$REPLY==0]];then
echo"Programterminated."
exit
fi
if[[$REPLY==1]];then
echo"Hostname:$HOSTNAME"
uptime
exit
fi
if[[$REPLY==2]];then
df-h
exit
fi
if[[$REPLY==3]];then
if[[$(id-u)-eq0]];then
echo"HomeSpaceUtilization(AllUsers)"
du-sh/home/*
else
echo"HomeSpaceUtilization($USER)"
409
du-sh$HOME
fi
exit
fi
else
echo"Invalidentry.">&2
exit1
fi
The presence of multiple｀ exit｀ points in a program is generally a bad idea (it makes
从逻辑上讲，这个脚本被分为两部分。第一部分显示菜单和用户输入。第二部分确认用户
反馈，并执行选择的行动。注意脚本中使用的 exit命令。在这里，在一个行动执行之后，exit
被用来阻止脚本执行不必要的代码。通常在程序中出现多个 exit代码不是一个好主意（它使程
序逻辑较难理解），但是它在这个脚本中可以使用。
29.5总结归纳
在这一章中，我们向着程序交互性迈出了第一步；允许用户通过键盘向程序输入数据。使用目
前已经学过的技巧，有可能编写许多有用的程序，比如说特定的计算程序和容易使用的命令行
工具前端。在下一章中，我们将继续建立菜单驱动程序概念，让它更完善。
29.5.1友情提示
仔细研究本章中的程序，并对程序的逻辑结构有一个完整的理解，这是非常重要的，因为即将
到来的程序会日益复杂。作为练习，用 test命令而不是[[]]复合命令来重新编写本章中的
程序。提示：使用 grep命令来计算正则表达式及其退出状态。这会是一个不错的练习。
29.6拓展阅读
• Bash参考手册有一章关于内部命令的内容，其包括了read命令：
http://www.gnu.org/software/bash/manual/bashref.html#Bash-Builtins
410
30|流程控制：while/until循环
在前面的章节中，我们开发了菜单驱动程序，来产生各种各样的系统信息。虽然程序能够运行，
但它仍然存在重大的可用性问题。它只能执行单一的选择，然后终止。更糟糕地是，如果做了
一个无效的选择，程序会以错误终止，而没有给用户提供再试一次的机会。如果我们能构建程
序，以致于程序能够重复显示菜单，而且能一次又一次的选择，直到用户选择退出程序，这样
的程序会更好一些。
在这一章中，我们将看一个叫做循环的程序概念，其可用来使程序的某些部分重复。shell
为循环提供了三个复合命令。本章我们将查看其中的两个命令，随后章节介绍第三个命令。
30.1循环
日常生活中充满了重复性的活动。每天去散步，遛狗，切胡萝卜，所有任务都要重复一系列的
步骤。让我们以切胡萝卜为例。如果我们用伪码表达这种活动，它可能看起来像这样：
1.准备切菜板
2.准备菜刀
3.把胡萝卜放到切菜板上
4.提起菜刀
5.向前推进胡萝卜
6.切胡萝卜
7.如果切完整个胡萝卜，就退出，要不然回到第四步继续执行
从第四步到第七步形成一个循环。重复执行循环内的动作直到满足条件“切完整个胡萝
卜”。
411
30.1.1while
bash能够表达相似的想法。比方说我们想要按照顺序从 1到 5显示五个数字。可如下构造一
个 bash脚本：
#!/bin/bash
#while-count:displayaseriesofnumbers
count=1
while[$count-le5];do
echo$count
count=$((count+1))
done
echo"Finished."
当执行的时候，这个脚本显示如下信息：
[me@linuxbox~]$while-count
1
2
3
4
5
Finished.
while命令的语法是：
whilecommands;docommands;done
和 if一样，while计算一系列命令的退出状态。只要退出状态为零，它就执行循环内的命
令。在上面的脚本中，创建了变量 count，并初始化为 1。while命令将会计算 test命令的退
出状态。只要 test命令返回退出状态零，循环内的所有命令就会执行。每次循环结束之后，会
重复执行 test命令。第六次循环之后，count的数值增加到 6，test命令不再返回退出状态零，
且循环终止。程序继续执行循环之后的语句。
我们可以使用一个 while循环，来提高前面章节的 read-menu程序：
412
#!/bin/bash
#while-menu:amenudrivensysteminformationprogram
DELAY=3#Numberofsecondstodisplayresults
while[[$REPLY!=0]];do
clear
cat<<-_EOF_
PleaseSelect:
1.DisplaySystemInformation
2.DisplayDiskSpace
3.DisplayHomeSpaceUtilization
0.Quit
_EOF_
read-p"Enterselection[0-3]>"
if[[$REPLY=~^[0-3]$]];then
if[[$REPLY==1]];then
echo"Hostname:$HOSTNAME"
uptime
sleep$DELAY
fi
if[[$REPLY==2]];then
df-h
sleep$DELAY
fi
if[[$REPLY==3]];then
if[[$(id-u)-eq0]];then
echo"HomeSpaceUtilization(AllUsers)"
du-sh/home/*
else
echo"HomeSpaceUtilization($USER)"
du-sh$HOME
fi
sleep$DELAY
fi
else
echo"Invalidentry."
sleep$DELAY
fi
done
echo"Programterminated."
413
通过把菜单包含在 while循环中，每次用户选择之后，我们能够让程序重复显示菜单。只要
REPLY不等于 “0”，循环就会继续，菜单就能显示，从而用户有机会重新选择。每次动作完成
之后，会执行一个 sleep命令，所以在清空屏幕和重新显示菜单之前，程序将会停顿几秒钟，为
的是能够看到选项输出结果。一旦 REPLY等于“0”，则表示选择了“退出”选项，循环就会
终止，程序继续执行 done语句之后的代码。
30.2跳出循环
bash提供了两个内部命令，它们可以用来在循环内部控制程序流程。break命令立即终止一个
循环，且程序继续执行循环之后的语句。continue命令导致程序跳过循环中剩余的语句，且程
序继续执行下一次循环。这里我们看看采用了 break和 continue两个命令的 while-menu程序
版本：
#!/bin/bash
#while-menu2:amenudrivensysteminformationprogram
DELAY=3#Numberofsecondstodisplayresults
whiletrue;do
clear
cat<<-_EOF_
PleaseSelect:
1.DisplaySystemInformation
2.DisplayDiskSpace
3.DisplayHomeSpaceUtilization
0.Quit
_EOF_
read-p"Enterselection[0-3]>"
if[[$REPLY=~^[0-3]$]];then
if[[$REPLY==1]];then
echo"Hostname:$HOSTNAME"
uptime
sleep$DELAY
continue
fi
if[[$REPLY==2]];then
df-h
sleep$DELAY
continue
414
fi
if[[$REPLY==3]];then
if[[$(id-u)-eq0]];then
echo"HomeSpaceUtilization(AllUsers)"
du-sh/home/*
else
echo"HomeSpaceUtilization($USER)"
du-sh$HOME
fi
sleep$DELAY
continue
fi
if[[$REPLY==0]];then
break
fi
else
echo"Invalidentry."
sleep$DELAY
fi
done
echo"Programterminated."
在这个脚本版本中，我们设置了一个无限循环（就是自己永远不会终止的循环），通过使
用 true命令为 while提供一个退出状态。因为 true的退出状态总是为零，所以循环永远不会
终止。这是一个令人惊讶的通用脚本编程技巧。因为循环自己永远不会结束，所以由程序员
在恰当的时候提供某种方法来跳出循环。此脚本，当选择 “0”选项的时候，break命令被用来
退出循环。continue命令被包含在其它选择动作的末尾，来提高程序执行的效率。通过使用
continue命令，当一个选项确定后，程序会跳过不需执行的其他代码。例如，如果选择了选项
“1”，则没有理由去测试其它选项。
30.2.1until
until命令与 while非常相似，除了当遇到一个非零退出状态的时候，while退出循环，而 until
不退出。一个 until循环会继续执行直到它接受了一个退出状态零。在我们的 while-count脚本
中，我们继续执行循环直到 count变量的数值小于或等于 5。我们可以得到相同的结果，通过
在脚本中使用 until命令：
415
#!/bin/bash
#until-count:displayaseriesofnumbers
count=1
until[$count-gt5];do
echo$count
count=$((count+1))
done
echo"Finished."
通过把 test表达式更改为 $count -gt 5，until会在正确的时间终止循环。至于使用 while
循环还是 until循环，通常是选择其 test判断条件最容易写的那种。
30.3使用循环读取文件
while和 until能够处理标准输入。这就可以使用 while和 until处理文件。在下面的例子中，
我们将显示在前面章节中使用的 distros.txt文件的内容：
#!/bin/bash
#while-read:readlinesfromafile
whilereaddistroversionrelease;do
printf"Distro:%s\tVersion:%s\tReleased:%s\n"\
$distro\
$version\
$release
done<distros.txt
为了重定向文件到循环中，我们把重定向操作符放置到 done语句之后。循环将使用 read
从重定向文件中读取字段。这个 read命令读取每个文本行之后，将会退出，其退出状态为零，
直到到达文件末尾。到时候，它的退出状态为非零数值，因此终止循环。也有可能把标准输入
管道到循环中。
#!/bin/bash
#while-read2:readlinesfromafile
sort-k1,1-k2ndistros.txt|whilereaddistroversionrelease;do
416
printf"Distro:%s\tVersion:%s\tReleased:%s\n"\
$distro\
$version\
$release
done
这里我们接受 sort命令的标准输出，然后显示文本流。然而，因为管道将会在子 shell中执
行循环，当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失，记住这一点很重
要。
30.4总结
通过引入循环和我们之前遇到的分支、子例程和序列，我们已经介绍了程序流程控制的主要类
型。bash还有一些锦囊妙计，但它们都是关于这些基本概念的完善。
30.5拓展阅读
• Linux文档工程中的 Bash初学者指南一书中介绍了更多的 while循环实例：
http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html
• Wikipedia中有一篇关于循环的文章，其是一篇比较长的关于流程控制的文章中的一部分：
http://en.wikipedia.org/wiki/Control_flow#Loops
417
31|疑难排解
随着我们的脚本变得越来越复杂，当脚本运行错误，执行结果出人意料的时候,我们就应该查
看一下原因了。在这一章中，我们将会看一些脚本中出现地常见错误类型，同时还会介绍几个
可以跟踪和消除问题的有用技巧。
31.1语法错误
一个普通的错误类型是语法。语法错误涉及到一些 shell语法元素的拼写错误。大多数情况下，
这类错误会导致 shell拒绝执行此脚本。
在以下讨论中，我们将使用下面这个脚本，来说明常见的错误类型：
#!/bin/bash
#trouble:scripttodemonstratecommonerrors
number=1
if[$number=1];then
echo"Numberisequalto1."
else
echo"Numberisnotequalto1."
fi
参看脚本内容，我们知道这个脚本执行成功了：
[me@linuxbox~]$trouble
Numberisequalto1.
31.1.1丢失引号
如果我们编辑我们的脚本，并从跟随第一个 echo命令的参数中，删除其末尾的双引号：
418
#!/bin/bash
#trouble:scripttodemonstratecommonerrors
number=1
if[$number=1];then
echo"Numberisequalto1.
else
echo"Numberisnotequalto1."
fi
观察发生了什么：
[me@linuxbox~]$trouble
/home/me/bin/trouble:line10:unexpectedEOFwhilelookingfor
matching`"'
/home/me/bin/trouble:line13:syntaxerror:unexpectedendoffile
这个脚本产生了两个错误。有趣地是，所报告的行号不是引号被删除的地方，而是程序中后
面的文本行。我们能知道为什么，如果我们跟随丢失引号文本行之后的程序。bash会继续寻找
右引号，直到它找到一个，其就是这个紧随第二个 echo命令之后的引号。找到这个引号之后，
bash变得很困惑，并且 if命令的语法被破坏了，因为现在这个 fi语句在一个用引号引起来的
（但是开放的）字符串里面。
在冗长的脚本中，此类错误很难找到。使用带有语法高亮的编辑器将会帮助查找错误。如
果安装了 vim的完整版，通过输入下面的命令，可以使语法高亮生效：
:syntaxon
31.1.2丢失或意外的标记
另一个常见错误是忘记补全一个复合命令，比如说 if或者是 while。让我们看一下，如果我们
删除 if命令中测试之后的分号，会出现什么情况：
419
#!/bin/bash
#trouble:scripttodemonstratecommonerrors
number=1
if[$number=1]then
echo"Numberisequalto1."
else
echo"Numberisnotequalto1."
fi
结果是这样的：
[me@linuxbox~]$trouble
/home/me/bin/trouble:line9:syntaxerrornearunexpectedtoken
`else'
/home/me/bin/trouble:line9:`else'
再次，错误信息指向一个错误，其出现的位置在实际问题所在的文本行的后面。所发生的事
情真是相当有意思。我们记得，if能够接受一系列命令，并且会计算列表中最后一个命令的退
出代码。在我们的程序中，我们打算这个列表由单个命令组成，即 [，测试的同义词。这个 [命
令把它后面的东西看作是一个参数列表。在我们这种情况下，有三个参数：$number，=，和]。
由于删除了分号，单词 then被添加到参数列表中，从语法上讲，这是合法的。随后的 echo命
令也是合法的。它被解释为命令列表中的另一个命令，if将会计算命令的退出代码。接下来遇
到单词 else，但是它出局了，因为 shell把它认定为一个保留字（对于 shell有特殊含义的单词），
而不是一个命令名，因此报告错误信息。
31.1.3预料不到的展开
可能有这样的错误，它们仅会间歇性地出现在一个脚本中。有时候这个脚本执行正常，其它时
间会失败，这是因为展开结果造成的。如果我们归还我们丢掉的分号，并把 number的数值更
改为一个空变量，我们可以示范一下：
#!/bin/bash
#trouble:scripttodemonstratecommonerrors
420
number=
if[$number=1];then
echo"Numberisequalto1."
else
echo"Numberisnotequalto1."
fi
运行这个做了修改的脚本，得到以下输出：
[me@linuxbox~]$trouble
/home/me/bin/trouble:line7:[:=:unaryoperatorexpected
Numberisnotequalto1.
我们得到一个相当神秘的错误信息，其后是第二个 echo命令的输出结果。这问题是由于
test命令中 number变量的展开结果造成的。当此命令：
[$number=1]
经过展开之后，number变为空值，结果就是这样：
[=1]
这是无效的，所以就产生了错误。这个 =操作符是一个二元操作符（它要求每边都有一个
数值），但是第一个数值是缺失的，这样 test命令就期望用一个一元操作符（比如 -z）来代替。
进一步说，因为 test命令运行失败了（由于错误），这个 if命令接收到一个非零退出代码，因
此执行第二个 echo命令。
通过为 test命令中的第一个参数添加双引号，可以更正这个问题：
["$number"=1]
然后当展开操作发生地时候，执行结果将会是这样：
421
[""=1]
其得到了正确的参数个数。除了代表空字符串之外，引号应该被用于这样的场合，一个要展
开成多单词字符串的数值，及其包含嵌入式空格的文件名。
31.2逻辑错误
不同于语法错误，逻辑错误不会阻止脚本执行。虽然脚本会正常运行，但是它不会产生期望的
结果，归咎于脚本的逻辑问题。虽然有不计其数的可能的逻辑错误，但下面是一些在脚本中找
到的最常见的逻辑错误类型：
1.不正确的条件表达式。很容易编写一个错误的 if/then/else语句，并且执行错误的逻辑。
有时候逻辑会被颠倒，或者是逻辑结构不完整。
2.“超出一个值”错误。当编写带有计数器的循环语句的时候，为了计数在恰当的点结束，
循环语句可能要求从 0开始计数，而不是从 1开始，这有可能会被忽视。这些类型的错
误要不导致循环计数太多，而“超出范围”，要不就是过早的结束了一次迭代，从而错过
了最后一次迭代循环。
3.意外情况。大多数逻辑错误来自于程序碰到了程序员没有预见到的数据或者情况。这也
可以包括出乎意料的展开，比如说一个包含嵌入式空格的文件名展开成多个命令参数而
不是单个的文件名。
31.2.1防错编程
当编程的时候，验证假设非常重要。这意味着要仔细地计算脚本所使用的程序和命令的退出状
态。这里有个基于一个真实的故事的实例。为了在一台重要的服务器中执行维护任务，一位不
幸的系统管理员写了一个脚本。这个脚本包含下面两行代码：
cd$dir_name
rm*
从本质上来说，这两行代码没有任何问题，只要是变量 dir_name中存储的目录名字存在就
可以。但是如果不是这样会发生什么事情呢？在那种情况下，cd命令会运行失败，脚本会继续
422
执行下一行代码，将会删除当前工作目录中的所有文件。完成不是期望的结果！由于这种设计
策略，这个倒霉的管理员销毁了服务器中的一个重要部分。
让我们看一些能够提高这个设计的方法。首先，在 cd命令执行成功之后，再运行 rm命令，
可能是明智的选择。
cd$dir_name&&rm*
这样，如果 cd命令运行失败后，rm命令将不会执行。这样比较好，但是仍然有可能未设
置变量 dir_name或其变量值为空，从而导致删除了用户家目录下面的所有文件。这个问题也
能够避免，通过检验变量 dir_name中包含的目录名是否真正地存在：
[[-d$dir_name]]&&cd$dir_name&&rm*
通常，当某种情况（比如上述问题）发生的时候，最好是终止脚本执行，并对这种情况提示
错误信息：
if[[-d$dir_name]];then
ifcd$dir_name;then
rm*
else
echo"cannotcdto'$dir_name'">&2
exit1
fi
else
echo"nosuchdirectory:'$dir_name'">&2
exit1
fi
这里，我们检验了两种情况，一个名字，看看它是否为一个真正存在的目录，另一个是 cd
命令是否执行成功。如果任一种情况失败，就会发送一个错误说明信息到标准错误，然后脚本
终止执行，并用退出状态 1表明脚本执行失败。
423
31.2.2验证输入
一个良好的编程习惯是如果一个程序可以接受输入数据，那么这个程序必须能够应对它所接受
的任意数据。这通常意味着必须非常仔细地筛选输入数据，以确保只有有效的输入数据才能被
程序用来做进一步地处理。在前面章节中我们学习 read命令的时候，我们遇到过一个这样的
例子。一个脚本中包含了下面一条测试语句，用来验证一个选择菜单：
[[$REPLY=~^[0-3]$]]
这条测试语句非常明确。只有当用户输入是一个位于 0到 3范围内（包括 0和 3）的数字
的时候，这条语句才返回一个 0退出状态。而其它任何输入概不接受。有时候编写这类测试条
件非常具有挑战性，但是为了能产出一个高质量的脚本，付出还是必要的。
设计是时间的函数
当我还是一名大学生，在学习工业设计的时候，一位明智的教授说过一个项目的
设计程度是由给定设计师的时间量来决定的。如果给你五分钟来设计一款能够“杀
死苍蝇”的产品，你会设计出一个苍蝇拍。如果给你五个月的时间，你可能会制作
出激光制导的“反苍蝇系统”。
同样的原理适用于编程。有时候一个“快速但粗糙”的脚本就可以解决问题，但
这个脚本只能被其作者使用一次。这类脚本很常见，为了节省气力也应该被快速地
开发出来。所以这些脚本不需要太多的注释和防错检查。相反，如果一个脚本打算
用于生产使用，也就是说，某个重要任务或者多个客户会不断地用到它，此时这个
脚本就需要非常谨慎小心地开发了。
31.3测试
在各类软件开发中（包括脚本），测试是一个重要的环节。在开源世界中有一句谚语，“早发布，
常发布”，这句谚语就反映出这个事实（测试的重要性）。通过提早和经常发布，软件能够得到
更多曝光去使用和测试。经验表明如果在开发周期的早期发现 bug，那么这些 bug就越容易定
位，而且越能低成本的修复。
在之前的讨论中，我们知道了如何使用 stubs来验证程序流程。在脚本开发的最初阶段，它
们是一项有价值的技术来检测我们的工作进度。
424
让我们看一下上面的文件删除问题，为了轻松测试，看看如何修改这些代码。测试原本那个
代码片段将是危险的，因为它的目的是要删除文件，但是我们可以修改代码，让测试安全：
if[[-d$dir_name]];then
ifcd$dir_name;then
echorm*#TESTING
else
echo"cannotcdto'$dir_name'">&2
exit1
fi
else
echo"nosuchdirectory:'$dir_name'">&2
exit1
fi
exit#TESTING
因为在满足出错条件的情况下代码可以打印出有用信息，所以我们没有必要再添加任何额
外信息了。最重要的改动是仅在 rm命令之前放置了一个 echo命令，为的是把 rm命令及其展
开的参数列表打印出来，而不是执行实际的 rm命令语句。这个改动可以安全的执行代码。在
这段代码的末尾，我们放置了一个 exit命令来结束测试，从而防止执行脚本其它部分的代码。
这个需求会因脚本的设计不同而变化。
我们也在代码中添加了一些注释，用来标记与测试相关的改动。当测试完成之后，这些注释
可以帮助我们找到并删除所有的更改。
31.3.1测试案例
为了执行有用的测试，开发和使用好的测试案例是很重要的。这个要求可以通过谨慎地选择输
入数据或者运行边缘案例和极端案例来完成。在我们的代码片段中（是非常简单的代码），我们
想要知道在下面的三种具体情况下这段代码是怎样执行的：
1. dir_name包含一个已经存在的目录的名字
2. dir_name包含一个不存在的目录的名字
3. dir_name为空
通过执行以上每一个测试条件，就达到了一个良好的测试覆盖率。
425
正如设计，测试也是一个时间的函数。不是每一个脚本功能都需要做大量的测试。问题关
键是确定什么功能是最重要的。因为测试若发生故障会存在如此潜在的破坏性，所以我们的代
码片在设计和测试段期间都应值得仔细推敲。
31.4调试
如果测试暴露了脚本中的一个问题，那下一步就是调试了。“一个问题”通常意味着在某种情况
下，这个脚本的执行结果不是程序员所期望的结果。若是这种情况，我们需要仔细确认这个脚
本实际到底要完成什么任务，和为什么要这样做。有时候查找 bug要牵涉到许多监测工作。一
个设计良好的脚本会对查找错误有帮助。设计良好的脚本应该具备防卫能力，能够监测异常条
件，并能为用户提供有用的反馈信息。然而有时候，出现的问题相当稀奇，出人意料，这时候
就需要更多的调试技巧了。
31.4.1找到问题区域
在一些脚本中，尤其是一些代码比较长的脚本，有时候隔离脚本中与出现的问题相关的代码区
域对查找问题很有帮助。隔离的代码区域并不总是真正的错误所在，但是隔离往往可以深入了
解实际的错误原因。可以用来隔离代码的一项技巧是“添加注释”。例如，我们的文件删除代码
可以修改成这样，从而决定注释掉的这部分代码是否导致了一个错误：
if[[-d$dir_name]];then
ifcd$dir_name;then
rm*
else
echo"cannotcdto'$dir_name'">&2
exit1
fi
#else
#echo"nosuchdirectory:'$dir_name'">&2
#exit1
fi
通过给脚本中的一个逻辑区块内的每条语句的开头添加一个注释符号，我们就阻止了这部
分代码的执行。然后可以再次执行测试，来看看清除的代码是否影响了错误的行为。
426
31.4.2追踪
在一个脚本中，错误往往是由意想不到的逻辑流导致的。也就是说，脚本中的一部分代码或者
从未执行，或是以错误的顺序，或在错误的时间给执行了。为了查看真实的程序流，我们使用
一项叫做追踪（tracing）的技术。
一种追踪方法涉及到在脚本中添加可以显示程序执行位置的提示性信息。我们可以添加提
示信息到我们的代码片段中：
echo"preparingtodeletefiles">&2
if[[-d$dir_name]];then
ifcd$dir_name;then
echo"deletingfiles">&2
rm*
else
echo"cannotcdto'$dir_name'">&2
exit1
fi
else
echo"nosuchdirectory:'$dir_name'">&2
exit1
fi
echo"filedeletioncomplete">&2
我们把提示信息输出到标准错误输出，让其从标准输出中分离出来。我们也没有缩进包含
提示信息的语句，这样想要删除它们的时候，能比较容易找到它们。
当这个脚本执行的时候，就可能看到文件删除操作已经完成了：
[me@linuxbox~]$deletion-script
preparingtodeletefiles
deletingfiles
filedeletioncomplete
[me@linuxbox~]$
bash还提供了一种名为追踪的方法，这种方法可通过 -x选项和 set命令加上 -x选项两种
途径实现。拿我们之前的 trouble脚本为例，给该脚本的第一行语句添加 -x选项，我们就能追
踪整个脚本。
427
#!/bin/bash-x
#trouble:scripttodemonstratecommonerrors
number=1
if[$number=1];then
echo"Numberisequalto1."
else
echo"Numberisnotequalto1."
fi
当脚本执行后，输出结果看起来像这样:
[me@linuxbox~]$trouble
+number=1
+'['1=1']'
+echo'Numberisequalto1.'
Numberisequalto1.
追踪生效后，我们看到脚本命令展开后才执行。行首的加号表明追踪的迹象，使其与常规输
出结果区分开来。加号是追踪输出的默认字符。它包含在 PS4（提示符 4）shell变量中。可以
调整这个变量值让提示信息更有意义。这里，我们修改该变量的内容，让其包含脚本中追踪执
行到的当前行的行号。注意这里必须使用单引号是为了防止变量展开，直到提示符真正使用的
时候，就不需要了。
[me@linuxbox~]$exportPS4='$LINENO+'
[me@linuxbox~]$trouble
5+number=1
7+'['1=1']'
8+echo'Numberisequalto1.'
Numberisequalto1.
我们可以使用 set命令加上 -x选项，为脚本中的一块选择区域，而不是整个脚本启用追踪。
428
#!/bin/bash
#trouble:scripttodemonstratecommonerrors
number=1
set-x#Turnontracing
if[$number=1];then
echo"Numberisequalto1."
else
echo"Numberisnotequalto1."
fi
set+x#Turnofftracing
我们使用 set命令加上 -x选项来启动追踪，+x选项关闭追踪。这种技术可以用来检查一
个有错误的脚本的多个部分。
31.4.3执行时检查数值
伴随着追踪，在脚本执行的时候显示变量的内容，以此知道脚本内部的工作状态，往往是很用
的。使用额外的 echo语句通常会奏效。
#!/bin/bash
#trouble:scripttodemonstratecommonerrors
number=1
echo"number=$number"#DEBUG
set-x#Turnontracing
if[$number=1];then
echo"Numberisequalto1."
else
echo"Numberisnotequalto1."
fi
set+x#Turnofftracing
在这个简单的示例中，我们只是显示变量 number的数值，并为其添加注释，随后利于其识
别和清除。当查看脚本中的循环和算术语句的时候，这种技术特别有用。
429
31.5总结
在这一章中，我们仅仅看了几个在脚本开发期间会出现的问题。当然，还有很多。这章中描述
的技术对查找大多数的常见错误是有效的。调试是一种艺术，可以通过开发经验，在知道如何
避免错误 (整个开发过程中不断测试)以及在查找 bug（有效利用追踪）两方面都会得到提升。
31.6拓展阅读
• Wikipedia上面有两篇关于语法和逻辑错误的短文：
http://en.wikipedia.org/wiki/Syntax_error
http://en.wikipedia.org/wiki/logic_error
•网上有很多关于技术层面的 bash编程的资源：
http://mywiki.wooledge.org/BashPitfalls
http://tldp.org/LDP/abs/html/gotchas.html
http://www.gnu.org/software/bash/manual/html_node/Reserved-Word-Index.html
•想要学习从编写良好的 Unix程序中得知的基本概念，可以参考 Eric Raymond的《Unix
编程的艺术》这本伟大的著作。书中的许多想法都能适用于 shell脚本：
http://www.faqs.org/docs/artu/
http://www.faqs.org/docs/artu/ch01s06.html
•对于真正的高强度的调试，参考这个 Bash Debugger：
http://bashdb.sourceforge.net/
430
32|流程控制：case分支
在这一章中，我们将继续看一下程序的流程控制。在第 28章中，我们构建了一些简单的菜单
并创建了用来应对各种用户选择的程序逻辑。为此，我们使用了一系列的 if命令来识别哪一个
可能的选项已经被选中。这种类型的构造经常出现在程序中，出现频率如此之多，以至于许多
编程语言（包括 shell）专门为多选决策提供了一种流程控制机制。
32.1case
Bash的多选复合命令称为 case。它的语法规则如下所示：
casewordin
[pattern[|pattern]...)commands;;]...
esac
如果我们看一下第 28章中的读菜单程序，我们就知道了用来应对一个用户选项的逻辑流程：
#!/bin/bash
#read-menu:amenudrivensysteminformationprogram
clear
echo"
PleaseSelect:
1.DisplaySystemInformation
2.DisplayDiskSpace
3.DisplayHomeSpaceUtilization
0.Quit
"
read-p"Enterselection[0-3]>"
if[[$REPLY=~^[0-3]$]];then
431
if[[$REPLY==0]];then
echo"Programterminated."
exit
fi
if[[$REPLY==1]];then
echo"Hostname:$HOSTNAME"
uptime
exit
fi
if[[$REPLY==2]];then
df-h
exit
fi
if[[$REPLY==3]];then
if[[$(id-u)-eq0]];then
echo"HomeSpaceUtilization(AllUsers)"
du-sh/home/*
else
echo"HomeSpaceUtilization($USER)"
du-sh$HOME
fi
exit
fi
else
echo"Invalidentry.">&2
exit1
fi
使用 case语句，我们可以用更简单的代码替换这种逻辑：
#!/bin/bash
#case-menu:amenudrivensysteminformationprogram
clear
echo"
PleaseSelect:
1.DisplaySystemInformation
2.DisplayDiskSpace
3.DisplayHomeSpaceUtilization
432
0.Quit
"
read-p"Enterselection[0-3]>"
case$REPLYin
0)echo"Programterminated."
exit
;;
1)echo"Hostname:$HOSTNAME"
uptime
;;
2)df-h
;;
3)if[[$(id-u)-eq0]];then
echo"HomeSpaceUtilization(AllUsers)"
du-sh/home/*
else
echo"HomeSpaceUtilization($USER)"
du-sh$HOME
fi
;;
*)echo"Invalidentry">&2
exit1
;;
esac
case命令检查一个变量值，在我们这个例子中，就是 REPLY变量的变量值，然后试图去
匹配其中一个具体的模式。当与之相匹配的模式找到之后，就会执行与该模式相关联的命令。
若找到一个模式之后，就不会再继续寻找。
32.2模式
这里 case语句使用的模式和路径展开中使用的那些是一样的。模式以一个“)”为终止符。这
里是一些有效的模式。
模式描述
a)若单词为“a”，则匹配
[[:alpha:]])若单词是一个字母字符，则匹配
433
???)若单词只有 3个字符，则匹配
*.txt)若单词以“.txt”字符结尾，则匹配
*)匹配任意单词。把这个模式做为 case命令的最后一个模式，
是一个很好的做法，可以捕捉到任意一个与先前模式不匹配
的数值；也就是说，捕捉到任何可能的无效值。
表 32-1: case模式实例
这里是一个模式使用实例：
#!/bin/bash
read-p"enterword>"
case$REPLYin
[[:alpha:]])echo"isasinglealphabeticcharacter.";;
[ABC][0-9])echo"isA,B,orCfollowedbyadigit.";;
???)echo"isthreecharacterslong.";;
*.txt)echo"isawordendingin'.txt'";;
*)echo"issomethingelse.";;
esac
还可以使用竖线字符作为分隔符，把多个模式结合起来。这就创建了一个“或”条件模式。
这对于处理诸如大小写字符很有用处。例如：
#!/bin/bash
#case-menu:amenudrivensysteminformationprogram
clear
echo"
PleaseSelect:
A.DisplaySystemInformation
B.DisplayDiskSpace
C.DisplayHomeSpaceUtilization
Q.Quit
"
read-p"Enterselection[A,B,CorQ]>"
case$REPLYin
q|Q)echo"Programterminated."
434
exit
;;
a|A)echo"Hostname:$HOSTNAME"
uptime
;;
b|B)df-h
;;
c|C)if[[$(id-u)-eq0]];then
echo"HomeSpaceUtilization(AllUsers)"
du-sh/home/*
else
echo"HomeSpaceUtilization($USER)"
du-sh$HOME
fi
;;
*)echo"Invalidentry">&2
exit1
;;
esac
这里，我们更改了 case-menu程序的代码，用字母来代替数字做为菜单选项。注意新模式
如何使得大小写字母都是有效的输入选项。
32.3执行多个动作
早于版本号 4.0的 bash，case语法只允许执行与一个成功匹配的模式相关联的动作。匹配成功
之后，命令将会终止。这里我们看一个测试一个字符的脚本：
#!/bin/bash
#case4-1:testacharacter
read-n1-p"Typeacharacter>"
echo
case$REPLYin
[[:upper:]])echo"'$REPLY'isuppercase.";;
[[:lower:]])echo"'$REPLY'islowercase.";;
[[:alpha:]])echo"'$REPLY'isalphabetic.";;
[[:digit:]])echo"'$REPLY'isadigit.";;
435
[[:graph:]])echo"'$REPLY'isavisiblecharacter.";;
[[:punct:]])echo"'$REPLY'isapunctuationsymbol.";;
[[:space:]])echo"'$REPLY'isawhitespacecharacter.";;
[[:xdigit:]])echo"'$REPLY'isahexadecimaldigit.";;
esac
运行这个脚本，输出这些内容：
[me@linuxbox~]$case4-1
Typeacharacter>a
'a'islowercase.
大多数情况下这个脚本工作是正常的，但若输入的字符不止与一个 POSIX字符集匹配的
话，这时脚本就会出错。例如，字符“a”既是小写字母，也是一个十六进制的数字。早于 4.0
的 bash，对于 case语法绝不能匹配多个测试条件。现在的 bash版本，添加“;;&”表达式来终
止每个行动，所以现在我们可以做到这一点：
#!/bin/bash
#case4-2:testacharacter
read-n1-p"Typeacharacter>"
echo
case$REPLYin
[[:upper:]])echo"'$REPLY'isuppercase.";;&
[[:lower:]])echo"'$REPLY'islowercase.";;&
[[:alpha:]])echo"'$REPLY'isalphabetic.";;&
[[:digit:]])echo"'$REPLY'isadigit.";;&
[[:graph:]])echo"'$REPLY'isavisiblecharacter.";;&
[[:punct:]])echo"'$REPLY'isapunctuationsymbol.";;&
[[:space:]])echo"'$REPLY'isawhitespacecharacter.";;&
[[:xdigit:]])echo"'$REPLY'isahexadecimaldigit.";;&
esac
当我们运行这个脚本的时候，我们得到这些：
436
[me@linuxbox~]$case4-2
Typeacharacter>a
'a'islowercase.
'a'isalphabetic.
'a'isavisiblecharacter.
'a'isahexadecimaldigit.
添加的“;;&”的语法允许 case语句继续执行下一条测试，而不是简单地终止运行。
32.4总结
case命令是我们编程技巧口袋中的一个便捷工具。在下一章中我们将看到，对于处理某些类型
的问题来说，case命令是一个完美的工具。
32.5拓展阅读
• Bash参考手册的条件构造一节详尽的介绍了 case命令：
http://tiswww.case.edu/php/chet/bash/bashref.html#SEC21
•高级 Bash脚本指南提供了更深一层的 case应用实例：
http://tldp.org/LDP/abs/html/testbranch.html
437
33|位置参数
现在我们的程序还缺少一种本领，就是接收和处理命令行选项和参数的能力。在这一章中，我
们将探究一些能让程序访问命令行内容的 shell性能。
33.1访问命令行
shell提供了一个称为位置参数的变量集合，这个集合包含了命令行中所有独立的单词。这些变
量按照从 0到 9给予命名。可以以这种方式讲明白：
#!/bin/bash
#posit-param:scripttoviewcommandlineparameters
echo"
\$0=$0
\$1=$1
\$2=$2
\$3=$3
\$4=$4
\$5=$5
\$6=$6
\$7=$7
\$8=$8
\$9=$9
"
一个非常简单的脚本，显示从 $0到 $9所有变量的值。当不带命令行参数执行该脚本时，
输出结果如下：
[me@linuxbox~]$posit-param
438
$0=/home/me/bin/posit-param
$1=
$2=
$3=
$4=
$5=
$6=
$7=
$8=
$9=
即使不带命令行参数，位置参数 $0总会包含命令行中出现的第一个单词，也就是已执行程
序的路径名。当带参数执行脚本时，我们看看输出结果：
[me@linuxbox~]$posit-paramabcd
$0=/home/me/bin/posit-param
$1=a
$2=b
$3=c
$4=d
$5=
$6=
$7=
$8=
$9=
注意：实际上通过参数展开方式你可以访问的参数个数多于 9个。只要指定一个大于 9的
数字，用花括号把该数字括起来就可以。例如 ${10}、${55}、${211}等等。
33.1.1确定参数个数
另外 shell还提供了一个名为 $#，可以得到命令行参数个数的变量:
#!/bin/bash
#posit-param:scripttoviewcommandlineparameters
echo"
439
Numberofarguments:$#
\$0=$0
\$1=$1
\$2=$2
\$3=$3
\$4=$4
\$5=$5
\$6=$6
\$7=$7
\$8=$8
\$9=$9
"
结果是：
[me@linuxbox~]$posit-paramabcd
Numberofarguments:4
$0=/home/me/bin/posit-param
$1=a
$2=b
$3=c
$4=d
$5=
$6=
$7=
$8=
$9=
33.1.2shift-访问多个参数的利器
但是如果我们给一个程序添加大量的命令行参数，会怎么样呢？正如下面的例子：
[me@linuxbox~]$posit-param*
Numberofarguments:82
$0=/home/me/bin/posit-param
$1=addresses.ldif
440
$2=bin
$3=bookmarks.html
$4=debian-500-i386-netinst.iso
$5=debian-500-i386-netinst.jigdo
$6=debian-500-i386-netinst.template
$7=debian-cd_info.tar.gz
$8=Desktop
$9=dirlist-bin.txt
在这个例子运行的环境下，通配符 *展开成 82个参数。我们如何处理那么多的参数？为此，
shell提供了一种方法，尽管笨拙，但可以解决这个问题。执行一次 shift命令，就会导致所有
的位置参数“向下移动一个位置”。事实上，用 shift命令也可以处理只有一个参数的情况（除
了其值永远不会改变的变量 $0）：
#!/bin/bash
#posit-param2:scripttodisplayallarguments
count=1
while[[$#-gt0]];do
echo"Argument$count=$1"
count=$((count+1))
shift
done
每次 shift命令执行的时候，变量 $2的值会移动到变量 $1中，变量 $3的值会移动到变量
$2中，依次类推。变量 $#的值也会相应的减 1。
在该 posit-param2程序中，我们编写了一个计算剩余参数数量，只要参数个数不为零就会
继续执行的 while循环。我们显示当前的位置参数，每次循环迭代变量 count的值都会加 1，
用来计数处理的参数数量，最后，执行 shift命令加载 $1，其值为下一个位置参数的值。这里
是程序运行后的输出结果:
[me@linuxbox~]$posit-param2abcd
Argument1=a
Argument2=b
Argument3=c
Argument4=d
441
33.1.3简单应用
即使没有 shift命令，也可以用位置参数编写一个有用的应用。举例说明，这里是一个简单的输
出文件信息的程序：
#!/bin/bash
#file_info:simplefileinformationprogram
PROGNAME=$(basename$0)
if[[-e$1]];then
echo-e"\nFileType:"
file$1
echo-e"\nFileStatus:"
stat$1
else
echo"$PROGNAME:usage:$PROGNAMEfile">&2
exit1
fi
这个程序显示一个具体文件的文件类型（由 file命令确定）和文件状态（来自 stat命令）。
该程序一个有意思的特点是 PROGNAME变量。它的值就是 basename $0命令的执行结果。
这个 basename命令清除一个路径名的开头部分，只留下一个文件的基本名称。在我们的程序
中，basename命令清除了包含在 $0位置参数中的路径名的开头部分，$0中包含着我们示例程
序的完整路径名。当构建提示信息正如程序结尾的使用信息的时候，basename $0的执行结果
就很有用处。按照这种方式编码，可以重命名该脚本，且程序信息会自动调整为包含相应的程
序名称。
33.1.4Shell函数中使用位置参数
正如位置参数被用来给 shell脚本传递参数一样，它们也能够被用来给 shell函数传递参数。为
了说明这一点，我们将把 file_info脚本转变成一个 shell函数：
file_info(){
#file_info:functiontodisplayfileinformation
if[[-e$1]];then
echo-e"\nFileType:"
file$1
442
echo-e"\nFileStatus:"
stat$1
else
echo"$FUNCNAME:usage:$FUNCNAMEfile">&2
return1
fi
}
现在，如果一个包含 shell函数 file_info的脚本调用该函数，且带有一个文件名参数，那这
个参数会传递给 file_info函数。
通过此功能，我们可以写出许多有用的 shell函数，这些函数不仅能在脚本中使用，也可以
用在.bashrc文件中。
注意那个 PROGNAME变量已经改成 shell变量 FUNCNAME了。shell会自动更新
FUNCNAME变量，以便跟踪当前执行的 shell函数。注意位置参数 $0总是包含命令行中第
一项的完整路径名（例如，该程序的名字），但不会包含这个我们可能期望的 shell函数的名字。
33.2处理集体位置参数
有时候把所有的位置参数作为一个集体来管理是很有用的。例如，我们可能想为另一个程序编
写一个“包裹程序”。这意味着我们会创建一个脚本或 shell函数，来简化另一个程序的执行。
包裹程序提供了一个神秘的命令行选项列表，然后把这个参数列表传递给下一级的程序。
为此 shell提供了两种特殊的参数。他们二者都能扩展成完整的位置参数列表，但以相当微
妙的方式略有不同。它们是：
参数描述
$*展开成一个从 1开始的位置参数列表。当它被用双引号引
起来的时候，展开成一个由双引号引起来的字符串，包含了
所有的位置参数，每个位置参数由 shell变量 IFS的第一个
字符（默认为一个空格）分隔开。
$@展开成一个从 1开始的位置参数列表。当它被用双引号引
起来的时候，它把每一个位置参数展开成一个由双引号引起
来的分开的字符串。
表 32-1: *和 @特殊参数
443
下面这个脚本用程序中展示了这些特殊参数：
#!/bin/bash
#posit-params3:scripttodemonstrate$*and$@
print_params(){
echo"\$1=$1"
echo"\$2=$2"
echo"\$3=$3"
echo"\$4=$4"
}
pass_params(){
echo-e"\n"'$*:';print_params$*
echo-e"\n"'"$*":';print_params"$*"
echo-e"\n"'$@:';print_params$@
echo-e"\n"'"$@":';print_params"$@"
}
pass_params"word""wordswithspaces"
在这个相当复杂的程序中，我们创建了两个参数：“word”和“words with spaces”，然后
把它们传递给 pass_params函数。这个函数，依次，再把两个参数传递给 print_params函数，
使用了特殊参数 $*和 $@提供的四种可用方法。脚本运行后，揭示了这两个特殊参数存在的
差异：
[me@linuxbox~]$posit-param3
$*:
$1=word
$2=words
$3=with
$4=spaces
"$*":
$1=wordwordswithspaces
$2=
$3=
$4=
$@:
$1=word
$2=words
444
$3=with
$4=spaces
"$@":
$1=word
$2=wordswithspaces
$3=
$4=
通过我们的参数，$*和 $@两个都产生了一个有四个词的结果：
wordwordswithspaces
"$*"producesaonewordresult:
"wordwordswithspaces"
"$@"producesatwowordresult:
"word""wordswithspaces"
这个结果符合我们实际的期望。我们从中得到的教训是尽管 shell提供了四种不同的得到位
置参数列表的方法，但到目前为止，“$@”在大多数情况下是最有用的方法，因为它保留了每一
个位置参数的完整性。
33.3一个更复杂的应用
经过长时间的间断，我们将恢复程序 sys_info_page的工作。我们下一步要给程序添加如下几
个命令行选项：
•输出文件。我们将添加一个选项，以便指定一个文件名，来包含程序的输出结果。选项格
式要么是 -f file，要么是 --file file
•交互模式。这个选项将提示用户输入一个输出文件名，然后判断指定的文件是否已经存
在了。如果文件存在，在覆盖这个存在的文件之前会提示用户。这个选项可以通过 -i或
者 --interactive来指定。
•帮助。指定 -h选项或者是 --help选项，可导致程序输出提示性的使用信息。
这里是处理命令行选项所需的代码：
445
usage(){
echo"$PROGNAME:usage:$PROGNAME[-ffile|-i]"
return
}
#processcommandlineoptions
interactive=
filename=
while[[-n$1]];do
case$1in
-f|--file)shift
filename=$1
;;
-i|--interactive)interactive=1
;;
-h|--help)usage
exit
;;
*)usage>&2
exit1
;;
esac
shift
done
首先，我们添加了一个叫做 usage的 shell函数，以便显示帮助信息，当启用帮助选项或敲
写了一个未知选项的时候。
下一步，我们开始处理循环。当位置参数 $1不为空的时候，这个循环会持续运行。在循环
的底部，有一个 shift命令，用来提升位置参数，以便确保该循环最终会终止。在循环体内，我
们使用了一个 case语句来检查当前位置参数的值，看看它是否匹配某个支持的选项。若找到了
匹配项，就会执行与之对应的代码。若没有，就会打印出程序使用信息，该脚本终止且执行错
误。
处理 -f参数的方式很有意思。当监测到 -f参数的时候，会执行一次 shift命令，从而提升
位置参数 $1为伴随着 -f选项的 filename参数。
我们下一步添加代码来实现交互模式：
446
#interactivemode
if[[-n$interactive]];then
whiletrue;do
read-p"Enternameofoutputfile:"filename
if[[-e$filename]];then
read-p"'$filename'exists.Overwrite?[y/n/q]>"
case$REPLYin
Y|y)break
;;
Q|q)echo"Programterminated."
exit
;;
*)continue
;;
esac
elif[[-z$filename]];then
continue
else
break
fi
done
fi
若 interactive变量不为空，就会启动一个无休止的循环，该循环包含文件名提示和随后存
在的文件处理代码。如果所需要的输出文件已经存在，则提示用户覆盖，选择另一个文件名，
或者退出程序。如果用户选择覆盖一个已经存在的文件，则会执行 break命令终止循环。注意
case语句是怎样只检测用户选择了覆盖还是退出选项。其它任何选择都会导致循环继续并提示
用户再次选择。
为了实现这个输出文件名的功能，首先我们必须把现有的这个写页面（page-writing）的代
码转变成一个 shell函数，一会儿就会明白这样做的原因：
write_html_page(){
cat<<-_EOF_
<HTML>
<HEAD>
<TITLE>$TITLE</TITLE>
447
</HEAD>
<BODY>
<H1>$TITLE</H1>
<P>$TIMESTAMP</P>
$(report_uptime)
$(report_disk_space)
$(report_home_space)
</BODY>
</HTML>
_EOF_
return
}
#outputhtmlpage
if[[-n$filename]];then
iftouch$filename&&[[-f$filename]];then
write_html_page>$filename
else
echo"$PROGNAME:Cannotwritefile'$filename'">&2
exit1
fi
else
write_html_page
fi
解决 -f选项逻辑的代码出现在以上程序片段的末尾。在这段代码中，我们测试一个文件名
是否存在，若文件名存在，则执行另一个测试看看该文件是不是可写文件。为此，会运行 touch
命令，紧随其后执行一个测试，来决定 touch命令创建的文件是否是个普通文件。这两个测试
考虑到了输入是无效路径名（touch命令执行失败），和一个普通文件已经存在的情况。
正如我们所看到的，程序调用 write_html_page函数来生成实际的网页。函数输出要么直
接定向到标准输出（若 filename变量为空的话）要么重定向到具体的文件中。
33.4总结
伴随着位置参数的加入，现在我们能编写相当具有功能性的脚本。例如，重复性的任务，位置
参数使得我们可以编写非常有用的，可以放置在一个用户的.bashrc文件中的 shell函数。
我们的 sys_info_page程序日渐精进。这里是一个完整的程序清单，最新的更改用高亮显
示：
448
#!/bin/bash
#sys_info_page:programtooutputasysteminformationpage
PROGNAME=$(basename$0)
TITLE="SystemInformationReportFor$HOSTNAME"
CURRENT_TIME=$(date+"%x%r%Z")
TIMESTAMP="Generated$CURRENT_TIME,by$USER"
report_uptime(){
cat<<-_EOF_
<H2>SystemUptime</H2>
<PRE>$(uptime)</PRE>
_EOF_
return
}
report_disk_space(){
cat<<-_EOF_
<H2>DiskSpaceUtilization</H2>
<PRE>$(df-h)</PRE>
_EOF_
return
}
report_home_space(){
if[[$(id-u)-eq0]];then
cat<<-_EOF_
<H2>HomeSpaceUtilization(AllUsers)</H2>
<PRE>$(du-sh/home/*)</PRE>
_EOF_
else
cat<<-_EOF_
<H2>HomeSpaceUtilization($USER)</H2>
<PRE>$(du-sh$HOME)</PRE>
_EOF_
fi
return
}
usage(){
echo"$PROGNAME:usage:$PROGNAME[-ffile|-i]"
return
}
write_html_page(){
449
cat<<-_EOF_
<HTML>
<HEAD>
<TITLE>$TITLE</TITLE>
</HEAD>
<BODY>
<H1>$TITLE</H1>
<P>$TIMESTAMP</P>
$(report_uptime)
$(report_disk_space)
$(report_home_space)
</BODY>
</HTML>
_EOF_
return
}
#processcommandlineoptions
interactive=
filename=
while[[-n$1]];do
case$1in
-f|--file)shift
filename=$1
;;
-i|--interactive)interactive=1
;;
-h|--help)usage
exit
;;
*)usage>&2
exit1
;;
esac
shift
done
#interactivemode
if[[-n$interactive]];then
whiletrue;do
read-p"Enternameofoutputfile:"filename
if[[-e$filename]];then
450
read-p"'$filename'exists.Overwrite?[y/n/q]>"
case$REPLYin
Y|y)break
;;
Q|q)echo"Programterminated."
exit
;;
*)continue
;;
esac
fi
done
fi
#outputhtmlpage
if[[-n$filename]];then
iftouch$filename&&[[-f$filename]];then
write_html_page>$filename
else
echo"$PROGNAME:Cannotwritefile'$filename'">&2
exit1
fi
else
write_html_page
fi
我们还没有完成。仍然还有许多事情我们可以做，可以改进。
33.5拓展阅读
•BashHackersWiki上有一篇不错的关于位置参数的文章：
http://wiki.bash-hackers.org/scripting/posparams
• Bash的参考手册有一篇关于特殊参数的文章，包括 $*和 $@：
http://www.gnu.org/software/bash/manual/bashref.html#Special-Parameters
•除了本章讨论的技术之外，bash还包含一个叫做 getopts的内部命令，此命令也可以用
来处理命令行参数。bash参考页面的 SHELL BUILTIN COMMANDS一节介绍了这个
命令，Bash Hackers Wiki上也有对它的描述：
451
http://wiki.bash-hackers.org/howto/getopts_tutorial
452
34|流程控制：for循环
在这关于流程控制的最后一章中，我们将看看另一种 shell循环构造。for循环不同于 while和
until循环，因为在循环中，它提供了一种处理序列的方式。这在编程时非常有用。因此在 bash
脚本中，for循环是非常流行的构造。
实现一个 for循环，很自然的，要用 for命令。在现代版的 bash中，有两种可用的 for循
环格式。
34.1for:传统shell格式
for命令语法是：
forvariable[inwords];do
commands
done
这里的 variable是一个变量的名字，这个变量在循环执行期间会增加，words是一个可选的
条目列表，其值会按顺序赋值给 variable，commands是在每次循环迭代中要执行的命令。
在命令行中 for命令是很有用的。我们可以很容易的说明它是如何工作的：
[me@linuxbox~]$foriinABCD;doecho$i;done
A
B
C
D
在这个例子中，for循环有一个四个单词的列表：“A”、“B”、“C”和“D”。由于这四个单
词的列表，for循环会执行四次。每次循环执行的时候，就会有一个单词赋值给变量 i。在循环
453
体内，我们有一个 echo命令会显示 i变量的值，来演示赋值结果。正如 while和 until循环，
done关键字会关闭循环。
for命令真正强大的功能是我们可以通过许多有趣的方式创建 words列表。例如，通过花括
号展开：
[me@linuxbox~]$foriin{A..D};doecho$i;done
A
B
C
D
或者路径名展开：
[me@linuxbox~]$foriindistros*.txt;doecho$i;done
distros-by-date.txt
distros-dates.txt
distros-key-names.txt
distros-key-vernums.txt
distros-names.txt
distros.txt
distros-vernums.txt
distros-versions.txt
或者命令替换：
#!/bin/bash
#longest-word:findlongeststringinafile
while[[-n$1]];do
if[[-r$1]];then
max_word=
max_len=0
foriin$(strings$1);do
len=$(echo$i|wc-c)
if((len>max_len));then
max_len=$len
454
max_word=$i
fi
done
echo"$1:'$max_word'($max_lencharacters)"
fi
shift
done
在这个示例中，我们要在一个文件中查找最长的字符串。当在命令行中给出一个或多个文
件名的时候，该程序会使用 strings程序（其包含在 GNU binutils包中），为每一个文件产生一
个可读的文本格式的“words”列表。然后这个 for循环依次处理每个单词，判断当前这个单词
是否为目前为止找到的最长的一个。当循环结束的时候，显示出最长的单词。
如果省略掉 for命令的可选项 words部分，for命令会默认处理位置参数。我们将修改
longest-word脚本，来使用这种方式：
#!/bin/bash
#longest-word2:findlongeststringinafile
fori;do
if[[-r$i]];then
max_word=
max_len=0
forjin$(strings$i);do
len=$(echo$j|wc-c)
if((len>max_len));then
max_len=$len
max_word=$j
fi
done
echo"$i:'$max_word'($max_lencharacters)"
fi
done
正如我们所看到的，我们已经更改了最外围的循环，用 for循环来代替 while循环。通过省
略 for命令的 words列表，用位置参数替而代之。在循环体内，之前的变量 i已经改为变量 j。
同时 shift命令也被淘汰掉了。
455
为什么是i？
你可能已经注意到上面所列举的 for循环的实例都选择 i作为变量。为什么呢？
实际上没有具体原因，除了传统习惯。for循环使用的变量可以是任意有效的变量，
但是 i是最常用的一个，其次是 j和 k。
这一传统的基础源于 Fortran编程语言。在 Fortran语言中，以字母 I、J、K、
L和 M开头的未声明变量的类型自动设为整形，而以其它字母开头的变量则为实数
类型（带有小数的数字）。这种行为导致程序员使用变量 I、J和 K作为循环变量，
因为当需要一个临时变量（正如循环变量）的时候，使用它们工作量比较少。这也
引出了如下基于 Fortran的俏皮话：
“神是实数，除非是声明的整数。”
34.2for:C语言格式
最新版本的 bash已经添加了第二种格式的 for命令语法，该语法相似于 C语言中的 for语法
格式。其它许多编程语言也支持这种格式：
for((expression1;expression2;expression3));do
commands
done
这里的 expression1、expression2和 expression3都是算术表达式，commands是每次循环
迭代时要执行的命令。在行为方面，这相当于以下构造形式：
((expression1))
while((expression2));do
commands
((expression3))
done
expression1用来初始化循环条件，expression2用来决定循环结束的时间，还有在每次循环
迭代的末尾会执行 expression3。
456
这里是一个典型应用：
#!/bin/bash
#simple_counter:demoofCstyleforcommand
for((i=0;i<5;i=i+1));do
echo$i
done
脚本执行之后，产生如下输出：
[me@linuxbox~]$simple_counter
0
1
2
3
4
在这个示例中，expression1初始化变量 i的值为 0，expression2允许循环继续执行只要变
量 i的值小于 5，还有每次循环迭代时，expression3会把变量 i的值加 1。
C语言格式的 for循环对于需要一个数字序列的情况是很有用处的。我们将在接下来的两
章中看到几个这样的应用实例。
34.3总结
学习了 for命令的知识，现在我们将对我们的 sys_info_page脚本做最后的改进。目前，这个
report_home_space函数看起来像这样：
report_home_space(){
if[[$(id-u)-eq0]];then
cat<<-_EOF_
<H2>HomeSpaceUtilization(AllUsers)</H2>
<PRE>$(du-sh/home/*)</PRE>
_EOF_
else
457
cat<<-_EOF_
<H2>HomeSpaceUtilization($USER)</H2>
<PRE>$(du-sh$HOME)</PRE>
_EOF_
fi
return
}
下一步，我们将重写它，以便提供每个用户家目录的更详尽信息，并且包含用户家目录中文
件和目录的总个数：
report_home_space(){
localformat="%8s%10s%10s\n"
localidir_listtotal_filestotal_dirstotal_sizeuser_name
if[[$(id-u)-eq0]];then
dir_list=/home/*
user_name="AllUsers"
else
dir_list=$HOME
user_name=$USER
fi
echo"<H2>HomeSpaceUtilization($user_name)</H2>"
foriin$dir_list;do
total_files=$(find$i-typef|wc-l)
total_dirs=$(find$i-typed|wc-l)
total_size=$(du-sh$i|cut-f1)
echo"<H3>$i</H3>"
echo"<PRE>"
printf"$format""Dirs""Files""Size"
printf"$format""----""-----""----"
printf"$format"$total_dirs$total_files$total_size
echo"</PRE>"
done
return
}
这次重写应用了目前为止我们学过的许多知识。我们仍然测试超级用户（superuser），但是
458
我们在 if语句块内设置了一些随后会在 for循环中用到的变量，来取代在 if语句块内执行完备
的动作集合。我们给函数添加了几个本地变量，并且使用 printf来格式化输出。
34.4拓展阅读
•《高级 Bash脚本指南》有一章关于循环的内容，其中列举了各种各样的 for循环实例：
http://tldp.org/LDP/abs/html/loops1.html
•《Bash参考手册》描述了循环复合命令，包括了 for循环：
http://www.gnu.org/software/bash/manual/bashref.html#Looping-Constructs
459
35|字符串和数字
所有的计算机程序都是用来和数据打交道的。在过去的章节中，我们专注于处理文件级别的数
据。然而，许多编程问题需要使用更小的数据单位来解决，比方说字符串和数字。
在这一章中，我们将查看几个用来操作字符串和数字的 shell功能。shell提供了各种执行字
符串操作的参数展开功能。除了算术展开（在第七章中接触过），还有一个常见的命令行程序叫
做 bc，能执行更高级别的数学运算。
35.1参数展开
尽管参数展开在第七章中出现过，但我们并没有详尽地介绍它，因为大多数的参数展开会用在
脚本中，而不是命令行中。我们已经使用了一些形式的参数展开；例如，shell变量。shell提供
了更多方式。
35.1.1基本参数
最简单的参数展开形式反映在平常使用的变量上。
例如：
$a
当 $a展开后，会变成变量 a所包含的值。简单参数也可能用花括号引起来：
${a}
虽然这对展开没有影响，但若该变量 a与其它的文本相邻，可能会把 shell搞糊涂了。在这
个例子中，我们试图创建一个文件名，通过把字符串“_file”附加到变量 a的值的后面。
[me@linuxbox~]$a="foo"
[me@linuxbox~]$echo"$a_file"
460
如果我们执行这个序列，没有任何输出结果，因为 shell会试着展开一个称为 a_file的变量，
而不是 a。通过添加花括号可以解决这个问题：
[me@linuxbox~]$echo"${a}_file"
foo_file
我们已经知道通过把数字包裹在花括号中，可以访问大于 9的位置参数。例如，访问第十
一个位置参数，我们可以这样做：
${11}
35.1.2管理空变量的展开
几种用来处理不存在和空变量的参数展开形式。这些展开形式对于解决丢失的位置参数和给参
数指定默认值的情况很方便。
${parameter:-word}
若 parameter没有设置（例如，不存在）或者为空，展开结果是 word的值。若 parameter
不为空，则展开结果是 parameter的值。
[me@linuxbox~]$foo=
[me@linuxbox~]$echo${foo:-"substitutevalueifunset"}
ifunset
substitutevalue
[me@linuxbox~]$echo$foo
[me@linuxbox~]$foo=bar
[me@linuxbox~]$echo${foo:-"substitutevalueifunset"}
bar
[me@linuxbox~]$echo$foo
bar
${parameter:=word}
若 parameter没有设置或为空，展开结果是 word的值。另外，word的值会赋值给
parameter。若 parameter不为空，展开结果是 parameter的值。
461
[me@linuxbox~]$foo=
[me@linuxbox~]$echo${foo:="defaultvalueifunset"}
defaultvalueifunset
[me@linuxbox~]$echo$foo
defaultvalueifunset
[me@linuxbox~]$foo=bar
[me@linuxbox~]$echo${foo:="defaultvalueifunset"}
bar
[me@linuxbox~]$echo$foo
bar
注意：位置参数或其它的特殊参数不能以这种方式赋值。
${parameter:?word}
若 parameter没有设置或为空，这种展开导致脚本带有错误退出，并且 word的内容会发送
到标准错误。若 parameter不为空，展开结果是 parameter的值。
[me@linuxbox~]$foo=
[me@linuxbox~]$echo${foo:?"parameterisempty"}
bash:foo:parameterisempty
[me@linuxbox~]$echo$?
1
[me@linuxbox~]$foo=bar
[me@linuxbox~]$echo${foo:?"parameterisempty"}
bar
[me@linuxbox~]$echo$?
0
${parameter:+word}
若 parameter没有设置或为空，展开结果为空。若 parameter不为空，展开结果是 word的
值会替换掉 parameter的值；然而，parameter的值不会改变。
462
[me@linuxbox~]$foo=
[me@linuxbox~]$echo${foo:+"substitutevalueifset"}
[me@linuxbox~]$foo=bar
[me@linuxbox~]$echo${foo:+"substitutevalueifset"}
substitutevalueifset
35.2返回变量名的参数展开
shell具有返回变量名的能力。这会用在一些相当独特的情况下。
${!prefix*}
${!prefix@}
这种展开会返回以 prefix开头的已有变量名。根据 bash文档，这两种展开形式的执行结果
相同。这里，我们列出了所有以 BASH开头的环境变量名：
[me@linuxbox~]$echo${!BASH*}
BASHBASH_ARGCBASH_ARGVBASH_COMMANDBASH_COMPLETION
BASH_COMPLETION_DIRBASH_LINENOBASH_SOURCEBASH_SUBSHELL
BASH_VERSINFOBASH_VERSION
35.2.1字符串展开
有大量的展开形式可用于操作字符串。其中许多展开形式尤其适用于路径名的展开。
${#parameter}
展开成由 parameter所包含的字符串的长度。通常，parameter是一个字符串；然而，如果
parameter是 @或者是 *的话，则展开结果是位置参数的个数。
[me@linuxbox~]$foo="Thisstringislong."
[me@linuxbox~]$echo"'$foo'is${#foo}characterslong."
'Thisstringislong.'is20characterslong.
${parameter:offset}
463
${parameter:offset:length}
这些展开用来从 parameter所包含的字符串中提取一部分字符。提取的字符始于第 offset
个字符（从字符串开头算起）直到字符串的末尾，除非指定提取的长度。
[me@linuxbox~]$foo="Thisstringislong."
[me@linuxbox~]$echo${foo:5}
stringislong.
[me@linuxbox~]$echo${foo:5:6}
string
若 offset的值为负数，则认为 offset值是从字符串的末尾开始算起，而不是从开头。注意负
数前面必须有一个空格，为防止与 ${parameter:-word}展开形式混淆。length，若出现，则必
须不能小于零。
如果 parameter是 @，展开结果是 length个位置参数，从第 offset个位置参数开始。
[me@linuxbox~]$foo="Thisstringislong."
[me@linuxbox~]$echo${foo:-5}
long.
[me@linuxbox~]$echo${foo:-5:2}
lo
${parameter#pattern}
${parameter##pattern}
这些展开会从 paramter所包含的字符串中清除开头一部分文本，这些字符要匹配定义的
pattern。pattern是通配符模式，就如那些用在路径名展开中的模式。这两种形式的差异之处
是该 #形式清除最短的匹配结果，而该 ##模式清除最长的匹配结果。
[me@linuxbox~]$foo=file.txt.zip
[me@linuxbox~]$echo${foo#*.}
txt.zip
[me@linuxbox~]$echo${foo##*.}
zip
464
${parameter%pattern}
${parameter%%pattern}
这些展开和上面的 #和 ##展开一样，除了它们清除的文本从 parameter所包含字符串的
末尾开始，而不是开头。
[me@linuxbox~]$foo=file.txt.zip
[me@linuxbox~]$echo${foo%.*}
file.txt
[me@linuxbox~]$echo${foo%%.*}
file
${parameter/pattern/string}
${parameter//pattern/string}
${parameter/#pattern/string}
${parameter/%pattern/string}
这种形式的展开对 parameter的内容执行查找和替换操作。如果找到了匹配通配符 pattern
的文本，则用 string的内容替换它。在正常形式下，只有第一个匹配项会被替换掉。在该 //
形式下，所有的匹配项都会被替换掉。该 /#要求匹配项出现在字符串的开头，而 /%要求匹
配项出现在字符串的末尾。/string可能会省略掉，这样会导致删除匹配的文本。
[me@linuxbox~]$foo=JPG.JPG
[me@linuxbox~]$echo${foo/JPG/jpg}
jpg.JPG
[me@linuxbox~]$echo${foo//JPG/jpg}
jpg.jpg
[me@linuxbox~]$echo${foo/#JPG/jpg}
jpg.JPG
[me@linuxbox~]$echo${foo/%JPG/jpg}
JPG.jpg
知道参数展开是件很好的事情。字符串操作展开可以用来替换其它常见命令比方说 sed和
cut。通过减少使用外部程序，展开提高了脚本的效率。举例说明，我们将修改在之前章节中讨
论的 longest-word程序，用参数展开 ${#j}取代命令 $(echo $j | wc -c)及其 subshell，像这样：
465
#!/bin/bash
#longest-word3:findlongeststringinafile
fori;do
if[[-r$i]];then
max_word=
max_len=
forjin$(strings$i);do
len=${#j}
if((len>max_len));then
max_len=$len
max_word=$j
fi
done
echo"$i:'$max_word'($max_lencharacters)"
fi
shift
done
下一步，我们将使用 time命令来比较这两个脚本版本的效率：
[me@linuxbox~]$timelongest-word2dirlist-usr-bin.txt
dirlist-usr-bin.txt:'scrollkeeper-get-extended-content-list'(38
characters)
real0m3.618s
user0m1.544s
sys0m1.768s
[me@linuxbox~]$timelongest-word3dirlist-usr-bin.txt
dirlist-usr-bin.txt:'scrollkeeper-get-extended-content-list'(38
characters)
real0m0.060s
user0m0.056s
sys0m0.008s
原来的脚本扫描整个文本文件需耗时 3.168秒，而该新版本，使用参数展开，仅仅花费了
0.06秒——一个非常巨大的提高。
466
35.2.2大小写转换
最新的 bash版本已经支持字符串的大小写转换了。bash有四个参数展开和 declare命令的两
个选项来支持大小写转换。
那么大小写转换对什么有好处呢？除了明显的审美价值，它在编程领域还有一个重要的角
色。让我们考虑一个数据库查询的案例。假设一个用户已经敲写了一个字符串到数据输入框中，
而我们想要在一个数据库中查找这个字符串。该用户输入的字符串有可能全是大写字母或全是
小写或是两者的结合。我们当然不希望把每个可能的大小写拼写排列填充到我们的数据库中。
那怎么办？
解决这个问题的常见方法是规范化用户输入。也就是，在我们试图查询数据库之前，把用户
的输入转换成标准化。我们能做到这一点，通过把用户输入的字符全部转换成小写字母或大写
字母，并且确保数据库中的条目按同样的方式规范化。
这个 declare命令可以用来把字符串规范成大写或小写字符。使用 declare命令，我们能强
制一个变量总是包含所需的格式，无论如何赋值给它。
#!/bin/bash
#ul-declare:demonstratecaseconversionviadeclare
declare-uupper
declare-llower
if[[$1]];then
upper="$1"
lower="$1"
echo$upper
echo$lower
fi
在上面的脚本中，我们使用 declare命令来创建两个变量，upper和 lower。我们把第一个
命令行参数的值（位置参数 1）赋给每一个变量，然后把变量值在屏幕上显示出来：
[me@linuxbox~]$ul-declareaBc
ABC
abc
正如我们所看到的，命令行参数（“aBc”）已经规范化了。
有四个参数展开，可以执行大小写转换操作：
467
格式结果
\${parameter„}把 parameter的值全部展开成小写字母。
\${parameter,}仅仅把 parameter的第一个字符展开成小写字母。
\${parameter^^}把 parameter的值全部转换成大写字母。
\${parameter^}仅仅把 parameter的第一个字符转换成大写字母（首字母大
写）。
表 35-1:大小写转换参数展开
这里是一个脚本，演示了这些展开格式：
#!/bin/bash
#ul-param-demonstratecaseconversionviaparameterexpansion
if[[$1]];then
echo${1,,}
echo${1,}
echo${1^^}
echo${1^}
fi
这里是脚本运行后的结果：
[me@linuxbox~]$ul-paramaBc
abc
aBc
ABC
ABc
再次，我们处理了第一个命令行参数，输出了由参数展开支持的四种变体。尽管这个脚本使
用了第一个位置参数，但参数可以是任意字符串，变量，或字符串表达式。
35.3算术求值和展开
我们在第七章中已经接触过算术展开了。它被用来对整数执行各种算术运算。它的基本格式是：
468
$((expression))
这里的 expression是一个有效的算术表达式。
这个与复合命令 (( ))有关，此命令用做算术求值（真测试），我们在第 27章中遇到过。
在之前的章节中，我们看到过一些类型的表达式和运算符。这里，我们将看到一个更完整的
列表。
35.3.1数基
回到第 9章，我们看过八进制（以 8为底）和十六进制（以 16为底）的数字。在算术表达式
中，shell支持任意进制的整型常量。
表示法描述
number默认情况下，没有任何表示法的数字被看做是十进制数（以
10为底）。
0number在算术表达式中，以零开头的数字被认为是八进制数。
0xnumber十六进制表示法
base#number number以 base为底
表 35-2:指定不同的数基
一些例子：
[me@linuxbox~]$echo$((0xff))
255
[me@linuxbox~]$echo$((2#11111111))
255
在上面的示例中，我们打印出十六进制数 ff（最大的两位数）的值和最大的八位二进制数
（以 2为底）。
35.3.2一元运算符
有两个一元运算符，+和 -，它们被分别用来表示一个数字是正数还是负数。例如，-5。
469
35.3.3简单算术
下表中列出了普通算术运算符：
运算符描述
+加
-减
*乘
/整除
**乘方
%取模（余数）
表 35-3:算术运算符
其中大部分运算符是不言自明的，但是整除和取模运算符需要进一步解释一下。
因为 shell算术只操作整型，所以除法运算的结果总是整数：
[me@linuxbox~]$echo$((5/2))
2
这使得确定除法运算的余数更为重要：
[me@linuxbox~]$echo$((5%2))
1
通过使用除法和取模运算符，我们能够确定 5除以 2得数是 2，余数是 1。
在循环中计算余数是很有用处的。在循环执行期间，它允许某一个操作在指定的间隔内执
行。在下面的例子中，我们显示一行数字，并高亮显示 5的倍数：
#!/bin/bash
#modulo:demonstratethemodulooperator
for((i=0;i<=20;i=i+1));do
remainder=$((i%5))
if((remainder==0));then
470
printf"<%d>"$i
else
printf"%d"$i
fi
done
printf"\n"
当脚本执行后，输出结果看起来像这样：
[me@linuxbox~]$modulo
<0>1234<5>6789<10>11121314<15>16171819<20>
35.3.4赋值运算符
尽管它的使用不是那么明显，算术表达式可能执行赋值运算。虽然在不同的上下文中，我们已
经执行了许多次赋值运算。每次我们给变量一个值，我们就执行了一次赋值运算。我们也能在
算术表达式中执行赋值运算：
[me@linuxbox~]$foo=
[me@linuxbox~]$echo$foo
[me@linuxbox~]$if((foo=5));thenecho"Itistrue.";fi
Itistrue.
[me@linuxbox~]$echo$foo
5
在上面的例子中，首先我们给变量 foo赋了一个空值，然后验证 foo的确为空。下一步，我
们执行一个 if复合命令 (( foo = 5 ))。这个过程完成两件有意思的事情：1）它把 5赋值给变量
foo，2）它计算测试条件为真，因为 foo的值非零。
注意：记住上面表达式中 =符号的真正含义非常重要。单个 =运算符执行赋值运算。foo
= 5是说“使得 foo等于 5”，而 ==运算符计算等价性。foo == 5是说“是否 foo等于 5？”。
这会让人感到非常迷惑，因为 test命令接受单个 =运算符来测试字符串等价性。这也是使用
更现代的 [[ ]]和 (( ))复合命令来代替 test命令的另一个原因。
471
除了 =运算符，shell也提供了其它一些表示法，来执行一些非常有用的赋值运算：
表示法描述
parameter = value简单赋值。给 parameter赋值。
parameter += value加。等价于 parameter = parameter + value。
parameter -= value减。等价于 parameter = parameter–value。
parameter *= value乘。等价于 parameter = parameter * value。
parameter /= value整除。等价于 parameter = parameter / value。
parameter %= value取模。等价于 parameter = parameter % value。
parameter++后缀自增变量。等价于 parameter = parameter + 1
(但，要看下面的讨论)。
parameter--后缀自减变量。等价于 parameter = parameter - 1。
++parameter前缀自增变量。等价于 parameter = parameter + 1。
--parameter前缀自减变量。等价于 parameter = parameter - 1。
表 35-4:赋值运算符
这些赋值运算符为许多常见算术任务提供了快捷方式。特别关注一下自增（++）和自减
（--）运算符，它们会把它们的参数值加 1或减 1。这种风格的表示法取自 C编程语言并且被其
它几种编程语言吸收，包括 bash。
自增和自减运算符可能会出现在参数的前面或者后面。然而它们都是把参数值加 1或减 1，
这两个位置有个微小的差异。若运算符放置在参数的前面，参数值会在参数返回之前增加（或
减少）。若放置在后面，则运算会在参数返回之后执行。这相当奇怪，但这是它预期的行为。这
里是个演示的例子：
[me@linuxbox~]$foo=1
[me@linuxbox~]$echo$((foo++))
1
[me@linuxbox~]$echo$foo
2
如果我们把 1赋值给变量 foo，然后通过把自增运算符 ++放到参数名 foo之后来增加它，
foo返回 1。然而，如果我们第二次查看变量 foo的值，我们看到它的值增加了 1。若我们把 +
472
+运算符放到参数 foo之前，我们得到更期望的行为：
[me@linuxbox~]$foo=1
[me@linuxbox~]$echo$((++foo))
2
[me@linuxbox~]$echo$foo
2
对于大多数 shell应用来说，前缀运算符最有用。
自增 ++和自减 --运算符经常和循环操作结合使用。我们将改进我们的 modulo脚本，让
代码更紧凑些：
#!/bin/bash
#modulo2:demonstratethemodulooperator
for((i=0;i<=20;++i));do
if(((i%5)==0));then
printf"<%d>"$i
else
printf"%d"$i
fi
done
printf"\n"
35.3.5位运算符
位运算符是一类以不寻常的方式操作数字的运算符。这些运算符工作在位级别的数字。它们被
用在某类底层的任务中，经常涉及到设置或读取位标志。
运算符描述
˜按位取反。对一个数字所有位取反。
«位左移.把一个数字的所有位向左移动。
»位右移.把一个数字的所有位向右移动。
&位与。对两个数字的所有位执行一个 AND操作。
|位或。对两个数字的所有位执行一个 OR操作。
^位异或。对两个数字的所有位执行一个异或操作。
473
表 35-5:位运算符
注意除了按位取反运算符之外，其它所有位运算符都有相对应的赋值运算符（例如，<<=）。
这里我们将演示产生 2的幂列表的操作，使用位左移运算符：
[me@linuxbox~]$for((i=0;i<8;++i));doecho$((1<<i));done
1
2
4
8
16
32
64
128
35.3.6逻辑运算符
正如我们在第 27章中所看到的，复合命令 (( ))支持各种各样的比较运算符。还有一些可以用
来计算逻辑运算。这里是比较运算符的完整列表：
运算符描述
<=小于或相等
>=大于或相等
<小于
>大于
==相等
!=不相等
&&逻辑与
||逻辑或
expr1?expr2:expr3条件（三元）运算符。若表达式 expr1的计算结果为
非零值（算术真），则执行表达式 expr2，否则执行表
达式 expr3。
表 35-6:比较运算符
474
当表达式用于逻辑运算时，表达式遵循算术逻辑规则；也就是，表达式的计算结果是零，则
认为假，而非零表达式认为真。该 (( ))复合命令把结果映射成 shell正常的退出码：
[me@linuxbox~]$if((1));thenecho"true";elseecho"false";fi
true
[me@linuxbox~]$if((0));thenecho"true";elseecho"false";fi
false
最陌生的逻辑运算符就是这个三元运算符了。这个运算符（仿照于 C编程语言里的三元运
算符）执行一个单独的逻辑测试。它用起来类似于 if/then/else语句。它操作三个算术表达式
（字符串不会起作用），并且若第一个表达式为真（或非零），则执行第二个表达式。否则，执行
第三个表达式。我们可以在命令行中实验一下：
[me@linuxbox~]$a=0
[me@linuxbox~]$((a<1?++a:--a))
[me@linuxbox~]$echo$a
1
[me@linuxbox~]$((a<1?++a:--a))
[me@linuxbox~]$echo$a
0
这里我们看到一个实际使用的三元运算符。这个例子实现了一个切换。每次运算符执行的
时候，变量 a的值从零变为 1，或反之亦然。
请注意在表达式内执行赋值却并非易事。
当企图这样做时，bash会声明一个错误：
[me@linuxbox~]$a=0
[me@linuxbox~]$((a<1?a+=1:a-=1))
bash:((:a<1?a+=1:a-=1:attemptedassignmenttonon-variable(errortokenis"-=1")
通过把赋值表达式用括号括起来，可以解决这个错误：
475
[me@linuxbox~]$((a<1?(a+=1):(a-=1)))
下一步，我们看一个使用算术运算符更完备的例子，该示例产生一个简单的数字表格：
#!/bin/bash
#arith-loop:scripttodemonstratearithmeticoperators
finished=0
a=0
printf"a\ta**2\ta**3\n"
printf"=\t====\t====\n"
until((finished));do
b=$((a**2))
c=$((a**3))
printf"%d\t%d\t%d\n"$a$b$c
((a<10?++a:(finished=1)))
done
在这个脚本中，我们基于变量 finished的值实现了一个 until循环。首先，把变量 finished
的值设为零（算术假），继续执行循环之道它的值变为非零。在循环体内，我们计算计数器 a的
平方和立方。在循环末尾，计算计数器变量 a的值。若它小于 10（最大迭代次数），则 a的值
加 1，否则给变量 finished赋值为 1，使得变量 finished算术为真，从而终止循环。运行该脚本
得到这样的结果：
[me@linuxbox~]$arith-loop
aa**2a**3
=========
000
111
248
3927
41664
525125
636216
749343
864512
476
981729
101001000
35.4bc-一种高精度计算器语言
我们已经看到 shell是可以处理所有类型的整型算术的，但是如果我们需要执行更高级的数学
运算或仅使用浮点数，该怎么办？答案是，我们不能这样做。至少不能直接用 shell完成此类运
算。为此，我们需要使用外部程序。有几种途径可供我们采用。嵌入的 Perl或者 AWK程序
是一种可能的方案，但是不幸的是，超出了本书的内容大纲。另一种方式就是使用一种专业的
计算器程序。这样一个程序叫做 bc，在大多数 Linux系统中都可以找到。
该 bc程序读取一个用它自己的类似于 C语言的语法编写的脚本文件。一个 bc脚本可能是
一个分离的文件或者是从标准输入读入。bc语言支持相当少的功能，包括变量，循环和程序员
定义的函数。这里我们不会讨论整个 bc语言，仅仅体验一下。查看 bc的手册页，其文档整理
得非常好。
让我们从一个简单的例子开始。我们将编写一个 bc脚本来执行 2加 2运算：
/*Averysimplebcscript*/
2+2
脚本的第一行是一行注释。bc使用和 C编程语言一样的注释语法。注释，可能会跨越多行，
开始于/*结束于*/。
35.4.1使用bc
如果我们把上面的 bc脚本保存为 foo.bc，然后我们就能这样运行它：
[me@linuxbox~]$bcfoo.bc
bc1.06.94
Copyright1991-1994,1997,1998,2000,2004,2006FreeSoftware
Foundation,Inc.
ThisisfreesoftwarewithABSOLUTELYNOWARRANTY.
Fordetailstype`warranty'.
4
477
如果我们仔细观察，我们看到算术结果在最底部，版权信息之后。可以通过 -q（quiet）选
项禁止这些版权信息。bc也能够交互使用：
[me@linuxbox~]$bc-q
2+2
4
quit
当使用 bc交互模式时，我们简单地输入我们希望执行的运算，结果就立即显示出来。bc的
quit命令结束交互会话。
也可能通过标准输入把一个脚本传递给 bc程序：
[me@linuxbox~]$bc<foo.bc
4
这种接受标准输入的能力，意味着我们可以使用 here文档，here字符串，和管道来传递脚
本。这里是一个使用 here字符串的例子：
[me@linuxbox~]$bc<<<"2+2"
4
35.4.2一个脚本实例
作为一个真实世界的例子，我们将构建一个脚本，用于计算每月的还贷金额。在下面的脚本中，
我们使用了 here文档把一个脚本传递给 bc：
#!/bin/bash
#loan-calc:scripttocalculatemonthlyloanpayments
PROGNAME=$(basename$0)
usage(){
cat<<-EOF
Usage:$PROGNAMEPRINCIPALINTERESTMONTHS
Where:
478
PRINCIPAListheamountoftheloan.
INTERESTistheAPRasanumber(7%=0.07).
MONTHSisthelengthoftheloan'sterm.
EOF
}
if(($#!=3));then
usage
exit1
fi
principal=$1
interest=$2
months=$3
bc<<-EOF
scale=10
i=$interest/12
p=$principal
n=$months
a=p*((i*((1+i)^n))/(((1+i)^n)-1))
printa,"\n"
EOF
当脚本执行后，输出结果像这样：
[me@linuxbox~]$loan-calc1350000.0775180
475
1270.7222490000
若贷款 135,000美金，年利率为 7.75%，借贷 180个月（15年），这个例子计算出每月需要
还贷的金额。注意这个答案的精确度。这是由脚本中变量 scale的值决定的。bc的手册页提供
了对 bc脚本语言的详尽描述。虽然 bc的数学符号与 shell的略有差异（bc与 C更相近），但
是基于目前我们所学的内容，大多数符号是我们相当熟悉的。
35.5总结
在这一章中，我们学习了很多小东西，在脚本中这些小零碎可以完成“真正的工作”。随着我
们编写脚本经验的增加，能够有效地操作字符串和数字的能力将具有极为重要的价值。我们的
479
loan-calc脚本表明，甚至可以创建简单的脚本来完成一些真正有用的事情。
35.6额外加分
虽然该 loan-calc脚本的基本功能已经很到位了，但脚本还远远不够完善。为了额外加分，试着
给脚本 loan-calc添加以下功能：
•完整的命令行参数验证
•用一个命令行选项来实现“交互”模式，提示用户输入本金、利率和贷款期限
•输出格式美化
35.7拓展阅读
•《Bash Hackers Wiki》对参数展开有一个很好的论述：
http://wiki.bash-hackers.org/syntax/pe
•《Bash参考手册》也介绍了这个：
http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
• Wikipedia上面有一篇很好的文章描述了位运算：
http://en.wikipedia.org/wiki/Bit_operation
•和一篇关于三元运算的文章：
http://en.wikipedia.org/wiki/Ternary_operation
•还有一个对计算还贷金额公式的描述，我们的 loan-calc脚本中用到了这个公式：
http://en.wikipedia.org/wiki/Amortization_calculator
480
36|数组
在上一章中，我们查看了 shell怎样操作字符串和数字的。目前我们所见到的数据类型在计算
机科学圈里被称为标量变量；也就是说，只能包含一个值的变量。
在本章中，我们将看看另一种数据结构叫做数组，数组能存放多个值。数组几乎是所有编程
语言的一个特性。shell也支持它们，尽管以一个相当有限的形式。即便如此，为解决编程问题，
它们是非常有用的。
36.1什么是数组？
数组是一次能存放多个数据的变量。数组的组织结构就像一张表。我们拿电子表格举例。一张
电子表格就像是一个二维数组。它既有行也有列，并且电子表格中的一个单元格，可以通过单
元格所在的行和列的地址定位它的位置。数组行为也是如此。数组有单元格，被称为元素，而
且每个元素会包含数据。使用一个称为索引或下标的地址可以访问一个单独的数组元素。
大多数编程语言支持多维数组。一个电子表格就是一个多维数组的例子，它有两个维度，宽
度和高度。许多语言支持任意维度的数组，虽然二维和三维数组可能是最常用的。
Bash中的数组仅限制为单一维度。我们可以把它们看作是只有一列的电子表格。尽管有这
种局限，但是有许多应用使用它们。对数组的支持第一次出现在 bash版本 2中。原来的 Unix
shell程序，sh，根本就不支持数组。
36.2创建一个数组
数组变量就像其它 bash变量一样命名，当被访问的时候，它们会被自动地创建。这里是一个
例子：
[me@linuxbox~]$a[1]=foo
[me@linuxbox~]$echo${a[1]}
foo
481
这里我们看到一个赋值并访问数组元素的例子。通过第一个命令，把数组 a的元素 1赋值
为“foo”。第二个命令显示存储在元素 1中的值。在第二个命令中使用花括号是必需的，以便
防止 shell试图对数组元素名执行路径名展开操作。
也可以用 declare命令创建一个数组：
[me@linuxbox~]$declare-aa
使用 -a选项，declare命令的这个例子创建了数组 a。
36.3数组赋值
有两种方式可以给数组赋值。单个值赋值使用以下语法：
name[subscript]=value
这里的 name是数组的名字，subscript是一个大于或等于零的整数（或算术表达式）。注意
数组第一个元素的下标是 0，而不是 1。数组元素的值可以是一个字符串或整数。
多个值赋值使用下面的语法：
name=(value1value2...)
这里的 name是数组的名字，value…是要按照顺序赋给数组的值，从元素 0开始。例如，如
果我们希望把星期几的英文简写赋值给数组 days，我们可以这样做：
[me@linuxbox~]$days=(SunMonTueWedThuFriSat)
还可以通过指定下标，把值赋给数组中的特定元素：
[me@linuxbox~]$days=([0]=Sun[1]=Mon[2]=Tue[3]=Wed[4]=Thu[5]=Fri[6]=Sat)
482
36.4访问数组元素
那么数组对什么有好处呢？就像许多数据管理任务一样，可以用电子表格程序来完成，许多编
程任务则可以用数组完成。
让我们考虑一个简单的数据收集和展示的例子。我们将构建一个脚本，用来检查一个特定
目录中文件的修改次数。从这些数据中，我们的脚本将输出一张表，显示这些文件最后是在一
天中的哪个小时被修改的。这样一个脚本可以被用来确定什么时段一个系统最活跃。这个脚本，
称为 hours，输出这样的结果：
[me@linuxbox~]$hours.
HourFilesHourFiles
-----------------
0001211
011137
020141
030157
041166
041175
066184
073194
081201
0914210
102220
115230
Totalfiles=80
当执行该 hours程序时，指定当前目录作为目标目录。它打印出一张表显示一天（0-23小
时）每小时内，有多少文件做了最后修改。程序代码如下所示：
#!/bin/bash
#hours:scripttocountfilesbymodificationtime
usage(){
echo"usage:$(basename$0)directory">&2
}
#Checkthatargumentisadirectory
if[[!-d$1]];then
483
usage
exit1
fi
#Initializearray
foriin{0..23};dohours[i]=0;done
#Collectdata
foriin$(stat-c%y"$1"/*|cut-c12-13);do
j=${i/#0}
((++hours[j]))
((++count))
done
#Displaydata
echo-e"Hour\tFiles\tHour\tFiles"
echo-e"----\t-----\t----\t-----"
foriin{0..11};do
j=$((i+12))
printf"%02d\t%d\t%02d\t%d\n"$i${hours[i]}$j${hours[j]}
done
printf"\nTotalfiles=%d\n"$count
这个脚本由一个函数（名为 usage），和一个分为四个区块的主体组成。在第一部分，我们
检查是否有一个命令行参数，且该参数为目录。如果不是目录，会显示脚本使用信息并退出。
第二部分初始化一个名为 hours的数组。给每一个数组元素赋值一个 0。虽然没有特殊需要
在使用之前准备数组，但是我们的脚本需要确保没有元素是空值。注意这个循环构建方式很有
趣。通过使用花括号展开（{0..23}），我们能很容易为 for命令产生一系列的数据（words）。
接下来的一部分收集数据，对目录中的每一个文件运行 stat程序。我们使用 cut命令从结
果中抽取两位数字的小时字段。在循环里面，我们需要把小时字段开头的零清除掉，因为 shell
将试图（最终会失败）把从“00”到“09”的数值解释为八进制（见表 35-1）。下一步，我们
以小时为数组索引，来增加其对应的数组元素的值。最后，我们增加一个计数器的值（count），
记录目录中总共的文件数目。
脚本的最后一部分显示数组中的内容。我们首先输出两行标题，然后进入一个循环产生两
栏输出。最后，输出总共的文件数目。
36.5数组操作
有许多常见的数组操作。比方说删除数组，确定数组大小，排序，等等。有许多脚本应用程序。
484
36.5.1输出整个数组的内容
下标 *和 @可以被用来访问数组中的每一个元素。与位置参数一样，@表示法在两者之中更
有用处。这里是一个演示：
[me@linuxbox~]$animals=("adog""acat""afish")
[me@linuxbox~]$foriin${animals[*]};doecho$i;done
a
dog
a
cat
a
fish
[me@linuxbox~]$foriin${animals[@]};doecho$i;done
a
dog
a
cat
a
fish
[me@linuxbox~]$foriin"${animals[*]}";doecho$i;done
adogacatafish
[me@linuxbox~]$foriin"${animals[@]}";doecho$i;done
adog
acat
afish
我们创建了数组 animals，并把三个含有两个字的字符串赋值给数组。然后我们执行四个循
环看一下对数组内容进行分词的效果。表示法 ${animals[*]}和 ${animals[@]}的行为是一致的
直到它们被用引号引起来。
36.5.2确定数组元素个数
使用参数展开，我们能够确定数组元素的个数，与计算字符串长度的方式几乎相同。这里是一
个例子:
[me@linuxbox~]$a[100]=foo
485
[me@linuxbox~]$echo${#a[@]}#numberofarrayelements
1
[me@linuxbox~]$echo${#a[100]}#lengthofelement100
3
我们创建了数组 a，并把字符串“foo”赋值给数组元素 100。下一步，我们使用参数展开
来检查数组的长度，使用 @表示法。最后，我们查看了包含字符串“foo”的数组元素 100的
长度。有趣的是，尽管我们把字符串赋值给数组元素 100，bash仅仅报告数组中有一个元素。
这不同于一些其它语言的行为，这种行为是数组中未使用的元素（元素 0-99）会初始化为空值，
并把它们计入数组长度。
36.5.3找到数组使用的下标
因为 bash允许赋值的数组下标包含“间隔”，有时候确定哪个元素真正存在是很有用的。为做
到这一点，可以使用以下形式的参数展开：
${!array[*]}
${!array[@]}
这里的 array是一个数组变量的名字。和其它使用符号 *和 @的展开一样，用引号引起来
的 @格式是最有用的，因为它能展开成分离的词。
[me@linuxbox~]$foo=([2]=a[4]=b[6]=c)
[me@linuxbox~]$foriin"${foo[@]}";doecho$i;done
a
b
c
[me@linuxbox~]$foriin"${!foo[@]}";doecho$i;done
2
4
6
36.5.4在数组末尾添加元素
如果我们需要在数组末尾附加数据，那么知道数组中元素的个数是没用的，因为通过 *和 @表
示法返回的数值不能告诉我们使用的最大数组索引。幸运地是，shell为我们提供了一种解决方
486
案。通过使用 +=赋值运算符，我们能够自动地把值附加到数组末尾。这里，我们把三个值赋
给数组 foo，然后附加另外三个。
[me@linuxbox~]$foo=(abc)
[me@linuxbox~]$echo${foo[@]}
abc
[me@linuxbox~]$foo+=(def)
[me@linuxbox~]$echo${foo[@]}
abcdef
36.5.5数组排序
就像电子表格，经常有必要对一列数据进行排序。Shell没有这样做的直接方法，但是通过一点
儿代码，并不难实现。
#!/bin/bash
#array-sort:Sortanarray
a=(fedcba)
echo"Originalarray:${a[@]}"
a_sorted=($(foriin"${a[@]}";doecho$i;done|sort))
echo"Sortedarray:${a_sorted[@]}"
当执行之后，脚本产生这样的结果：
[me@linuxbox~]$array-sort
Originalarray:fedcba
Sortedarray:
abcdef
脚本运行成功，通过使用一个复杂的命令替换把原来的数组（a）中的内容复制到第二个数
组（a_sorted）中。通过修改管道线的设计，这个基本技巧可以用来对数组执行各种各样的操
作。
487
36.5.6删除数组
删除一个数组，使用 unset命令：
[me@linuxbox~]$foo=(abcdef)
[me@linuxbox~]$echo${foo[@]}
abcdef
[me@linuxbox~]$unsetfoo
[me@linuxbox~]$echo${foo[@]}
[me@linuxbox~]$
也可以使用 unset命令删除单个的数组元素：
[me@linuxbox~]$foo=(abcdef)
[me@linuxbox~]$echo${foo[@]}
abcdef
[me@linuxbox~]$unset'foo[2]'
[me@linuxbox~]$echo${foo[@]}
abdef
在这个例子中，我们删除了数组中的第三个元素，下标为 2。记住，数组下标开始于 0，而
不是 1！也要注意数组元素必须用引号引起来为的是防止 shell执行路径名展开操作。
有趣地是，给一个数组赋空值不会清空数组内容：
[me@linuxbox~]$foo=(abcdef)
[me@linuxbox~]$foo=
[me@linuxbox~]$echo${foo[@]}
bcdef
任何没有下标的对数组变量的引用都指向数组元素 0：
[me@linuxbox~]$foo=(abcdef)
[me@linuxbox~]$echo${foo[@]}
abcdef
488
[me@linuxbox~]$foo=A
[me@linuxbox~]$echo${foo[@]}
Abcdef
36.6关联数组
现在最新的 bash版本支持关联数组了。关联数组使用字符串而不是整数作为数组索引。这种
功能给出了一种有趣的新方法来管理数据。例如，我们可以创建一个叫做“colors”的数组，并
用颜色名字作为索引。
declare-Acolors
colors["red"]="#ff0000"
colors["green"]="#00ff00"
colors["blue"]="#0000ff"
不同于整数索引的数组，仅仅引用它们就能创建数组，关联数组必须用带有 -A选项的
declare命令创建。
访问关联数组元素的方式几乎与整数索引数组相同：
echo${colors["blue"]}
在下一章中，我们将看一个脚本，很好地利用关联数组，生产出了一个有意思的报告。
36.7总结
如果我们在 bash手册页中搜索单词“array”的话，我们能找到许多 bash在哪里会使用数组变
量的实例。其中大部分相当晦涩难懂，但是它们可能在一些特殊场合提供临时的工具。事实上，
在 shell编程中，整套数组规则利用率相当低，很大程度上归咎于传统 Unix shell程序（比如说
sh）缺乏对数组的支持。这样缺乏人气是不幸的，因为数组广泛应用于其它编程语言，并为解
决各种各样的编程问题，提供了一个强大的工具。
数组和循环有一种天然的姻亲关系，它们经常被一起使用。该
489
for((expr;expr;expr))
形式的循环尤其适合计算数组下标。
36.8拓展阅读
• Wikipedia上面有两篇关于在本章提到的数据结构的文章：
http://en.wikipedia.org/wiki/Scalar_(computing)
http://en.wikipedia.org/wiki/Associative_array
490
37|奇珍异宝
在我们 bash学习旅程中的最后一站，我们将看一些零星的知识点。当然我们在之前的章节中
已经涵盖了很多方面，但是还有许多 bash特性我们没有涉及到。其中大部分特性相当晦涩，主
要对那些把 bash集成到 Linux发行版的程序有用处。然而还有一些特性，虽然不常用，但是
对某些程序问题是很有帮助的。我们将在这里介绍它们。
37.1组命令和子shell
bash允许把命令组合在一起。可以通过两种方式完成；要么用一个 group命令，要么用一个子
shell。这里是每种方式的语法示例：
组命令：
{command1;command2;[command3;...]}
子 shell：
(command1;command2;[command3;...])
这两种形式的不同之处在于，组命令用花括号把它的命令包裹起来，而子 shell用括号。值
得注意的是，鉴于 bash实现组命令的方式，花括号与命令之间必须有一个空格，并且最后一个
命令必须用一个分号或者一个换行符终止。
那么组命令和子 shell命令对什么有好处呢？尽管它们有一个很重要的差异（我们马上会接
触到），但它们都是用来管理重定向的。让我们考虑一个对多个命令执行重定向的脚本片段。
491
ls-l>output.txt
echo"Listingoffoo.txt">>output.txt
catfoo.txt>>output.txt
这些代码相当简洁明了。三个命令的输出都重定向到一个名为 output.txt的文件中。使用
一个组命令，我们可以重新编写这些代码，如下所示：
{ls-l;echo"Listingoffoo.txt";catfoo.txt;}>output.txt
使用一个子 shell是相似的：
(ls-l;echo"Listingoffoo.txt";catfoo.txt)>output.txt
使用这样的技术，我们为我们自己节省了一些打字时间，但是组命令和子 shell真正闪光的
地方是与管道线相结合。当构建一个管道线命令的时候，通常把几个命令的输出结果合并成一
个流是很有用的。组命令和子 shell使这种操作变得很简单：
{ls-l;echo"Listingoffoo.txt";catfoo.txt;}|lpr
这里我们已经把我们的三个命令的输出结果合并在一起，并把它们用管道输送给命令 lpr的
输入，以便产生一个打印报告。
在下面的脚本中，我们将使用组命令，看几个与关联数组结合使用的编程技巧。这个脚本，
称为 array-2，当给定一个目录名，打印出目录中的文件列表，伴随着每个文件的文件所有者和
组所有者。在文件列表的末尾，脚本打印出属于每个所有者和组的文件数目。这里我们看到的
（为简单起见而缩短的）结果，是给定脚本的目录为 /usr/bin的时候：
[me@linuxbox~]$array-2/usr/bin
/usr/bin/2to3-2.6rootroot
/usr/bin/2to3rootroot
492
/usr/bin/a2prootroot
/usr/bin/abrowserrootroot
/usr/bin/aconnectrootroot
/usr/bin/acpi_fakekeyrootroot
/usr/bin/acpi_listenrootroot
/usr/bin/add-apt-repositoryrootroot
.
/usr/bin/zipgreprootroot
/usr/bin/zipinforootroot
/usr/bin/zipnoterootroot
/usr/bin/ziprootroot
/usr/bin/zipsplitrootroot
/usr/bin/zjsdecoderootroot
/usr/bin/zsoelimrootroot
Fileowners:
daemon:1file(s)
root:1394file(s)Filegroupowners:
crontab:1file(s)
daemon:1file(s)
lpadmin:1file(s)
mail:4file(s)
mlocate:1file(s)
root:1380file(s)
shadow:2file(s)
ssh:1file(s)
tty:2file(s)
utmp:2file(s)
这里是脚本代码列表（带有行号）：
1#!/bin/bash
2
3#array-2:Usearraystotallyfileowners
4
5declare-Afilesfile_groupfile_ownergroupsowners
6
7if[[!-d"$1"]];then
493
8echo"Usage:array-2dir">&2
9exit1
10fi
11
12foriin"$1"/*;do
13owner=$(stat-c%U"$i")
14group=$(stat-c%G"$i")
15files["$i"]="$i"
16file_owner["$i"]=$owner
17file_group["$i"]=$group
18((++owners[$owner]))
19((++groups[$group]))
20done
21
22#Listthecollectedfiles
23{foriin"${files[@]}";do
24printf"%-40s%-10s%-10s\n"\
25"$i"${file_owner["$i"]}${file_group["$i"]}
26done}|sort
27echo
28
29#Listowners
30echo"Fileowners:"
31{foriin"${!owners[@]}";do
32printf"%-10s:%5dfile(s)\n""$i"${owners["$i"]}
33done}|sort
34echo
35
36#Listgroups
37echo"Filegroupowners:"
38{foriin"${!groups[@]}";do
39printf"%-10s:%5dfile(s)\n""$i"${groups["$i"]}
40done}|sort
让我们看一下这个脚本的运行机制：
行 5：关联数组必须用带有 -A选项的 declare命令创建。在这个脚本中我们创建了如下五
个数组：
files包含了目录中文件的名字，按文件名索引
494
file_group包含了每个文件的组所有者，按文件名索引
file_owner包含了每个文件的所有者，按文件名索引
groups包含了属于索引的组的文件数目
owners包含了属于索引的所有者的文件数目
行 7-10：查看是否一个有效的目录名作为位置参数传递给程序。如果不是，就会显示一条
使用信息，并且脚本退出，退出状态为 1。
行 12-20：循环遍历目录中的所有文件。使用 stat命令，行 13和行 14抽取文件所有者和
组所有者，并把值赋给它们各自的数组（行 16，17），使用文件名作为数组索引。同样地，文件
名自身也赋值给 files数组。
行 18-19：属于文件所有者和组所有者的文件总数各自加 1。
行 22-27：输出文件列表。为做到这一点，使用了“${array[@]}”参数展开，展开成整个的
数组元素列表，并且每个元素被当做是一个单独的词。从而允许文件名包含空格的情况。也要
注意到整个循环是包裹在花括号中，从而形成了一个组命令。这样就允许整个循环输出会被管
道输送给 sort命令的输入。这是必要的，因为展开的数组元素是无序的。
行 29-40：这两个循环与文件列表循环相似，除了它们使用“${!array[@]}”展开，展开成数
组索引的列表而不是数组元素的。
37.1.1进程替换
虽然组命令和子 shell看起来相似，并且它们都能用来在重定向中合并流，但是两者之间有一个
很重要的不同之处。然而，一个组命令在当前 shell中执行它的所有命令，而一个子 shell（顾
名思义）在当前 shell的一个子副本中执行它的命令。这意味着运行环境被复制给了一个新的
shell实例。当这个子 shell退出时，环境副本会消失，所以在子 shell环境（包括变量赋值）中
的任何更改也会消失。因此，在大多数情况下，除非脚本要求一个子 shell，组命令比子 shell
更受欢迎。组命令运行很快并且占用的内存也少。
我们在第 20章中看到过一个子 shell运行环境问题的例子，当我们发现管道线中的一个
read命令不按我们所期望的那样工作的时候。为了重现问题，我们构建一个像这样的管道线：
echo"foo"|read
echo$REPLY
该 REPLY变量的内容总是为空，是因为这个 read命令在一个子 shell中执行，所以当该
子 shell终止的时候，它的 REPLY副本会被毁掉。因为管道线中的命令总是在子 shell中执行，
495
任何给变量赋值的命令都会遭遇这样的问题。幸运地是，shell提供了一种奇异的展开方式，叫
做进程替换，它可以用来解决这种麻烦。进程替换有两种表达方式：
一种适用于产生标准输出的进程：
<(list)
另一种适用于接受标准输入的进程：
>(list)
这里的 list是一串命令列表：
为了解决我们的 read命令问题，我们可以雇佣进程替换，像这样：
read<<(echo"foo")
echo$REPLY
进程替换允许我们把一个子 shell的输出结果当作一个用于重定向的普通文件。事实上，因
为它是一种展开形式，我们可以检验它的真实值：
[me@linuxbox~]$echo<(echo"foo")
/dev/fd/63
通过使用 echo命令，查看展开结果，我们看到子 shell的输出结果，由一个名为 /dev/fd/
63的文件提供。
进程替换经常被包含 read命令的循环用到。这里是一个 read循环的例子，处理一个目录
列表的内容，内容创建于一个子 shell：
#!/bin/bash
#pro-sub:demoofprocesssubstitution
whilereadattrlinksownergroupsizedatetimefilename;do
496
cat<<-EOF
Filename:$filename
Size:$size
Owner:$owner
Group:$group
Modified:$date$time
Links:$links
Attributes:$attr
EOF
done<<(ls-l|tail-n+2)
这个循环对目录列表的每一个条目执行 read命令。列表本身产生于该脚本的最后一行代
码。这一行代码把从进程替换得到的输出重定向到这个循环的标准输入。这个包含在管道线中
的 tail命令，是为了消除列表的第一行文本，这行文本是多余的。
当脚本执行后，脚本产生像这样的输出：
[me@linuxbox~]$pro_sub|head-n20
Filename:addresses.ldif
Size:14540
Owner:me
Group:me
Modified:2009-04-0211:12
Links:
1
Attributes:-rw-r--r--
Filename:bin
Size:4096
Owner:me
Group:me
Modified:2009-07-1007:31
Links:2
Attributes:drwxr-xr-x
Filename:bookmarks.html
Size:394213
Owner:me
Group:me
497
37.2陷阱
在第 10章中，我们看到过程序是怎样响应信号的。我们也可以把这个功能添加到我们的脚本
中。然而到目前为止，我们所编写过的脚本还不需要这种功能（因为它们运行时间非常短暂，
并且不创建临时文件），大且更复杂的脚本可能会受益于一个信息处理程序。
当我们设计一个大的，复杂的脚本的时候，若脚本仍在运行时，用户注销或关闭了电脑，这
时候会发生什么，考虑到这一点非常重要。当像这样的事情发生了，一个信号将会发送给所有
受到影响的进程。依次地，代表这些进程的程序会执行相应的动作，来确保程序合理有序的终
止。比方说，例如，我们编写了一个会在执行时创建临时文件的脚本。在一个好的设计流程，
我们应该让脚本删除创建的临时文件，当脚本完成它的任务之后。若脚本接收到一个信号，表
明该程序即将提前终止的信号，此时让脚本删除创建的临时文件，也会是很精巧的设计。
为满足这样需求，bash提供了一种机制，众所周知的 trap。陷阱正好由内部命令 trap实
现。trap使用如下语法：
trapargumentsignal[signal...]
这里的 argument是一个字符串，它被读取并被当作一个命令，signal是一个信号的说明，
它会触发执行所要解释的命令。
这里是一个简单的例子：
#!/bin/bash
#trap-demo:simplesignalhandlingdemo
trap"echo'Iamignoringyou.'"SIGINTSIGTERM
foriin{1..5};do
echo"Iteration$iof5"
sleep5
done
这个脚本定义一个陷阱，当脚本运行的时候，这个陷阱每当接受到一个 SIGINT或
SIGTERM信号时，就会执行一个 echo命令。当用户试图通过按下 Ctrl-c组合键终止脚本运
行的时候，该程序的执行结果看起来像这样：
498
[me@linuxbox~]$trap-demo
Iteration1of5
Iteration2of5
Iamignoringyou.
Iteration3of5
Iamignoringyou.
Iteration4of5
Iteration5of5
正如我们所看到的，每次用户试图中断程序时，会打印出这条信息。
构建一个字符串来形成一个有用的命令序列是很笨拙的，所以通常的做法是指定一个 shell
函数作为命令。在这个例子中，为每一个信号指定了一个单独的 shell函数来处理：
#!/bin/bash
#trap-demo2:simplesignalhandlingdemo
exit_on_signal_SIGINT(){
echo"Scriptinterrupted."2>&1
exit0
}
exit_on_signal_SIGTERM(){
echo"Scriptterminated."2>&1
exit0
}
trapexit_on_signal_SIGINTSIGINT
trapexit_on_signal_SIGTERMSIGTERM
foriin{1..5};do
echo"Iteration$iof5"
sleep5
done
这个脚本的特色是有两个 trap命令，每个命令对应一个信号。每个 trap，依次，当接受到
相应的特殊信号时，会执行指定的 shell函数。注意每个信号处理函数中都包含了一个 exit命
令。没有 exit命令，信号处理函数执行完后，该脚本将会继续执行。
当用户在这个脚本执行期间，按下 Ctrl-c组合键的时候，输出结果看起来像这样：
499
[me@linuxbox~]$trap-demo2
Iteration1of5
Iteration2of5
Scriptinterrupted.
临时文件
把信号处理程序包含在脚本中的一个原因是删除临时文件，在脚本执行期间，脚
本可能会创建临时文件来存放中间结果。命名临时文件是一种艺术。传统上，在类
似于 unix系统中的程序会在 /tmp目录下创建它们的临时文件，/tmp是一个服务
于临时文件的共享目录。然而，因为这个目录是共享的，这会引起一定的安全顾虑，
尤其对那些用超级用户特权运行的程序。除了为暴露给系统中所有用户的文件设置
合适的权限这一明显步骤之外，给临时文件一个不可预测的文件名是很重要的。这
就避免了一种为大众所知的 temp race攻击。一种创建一个不可预测的（但是仍有
意义的）临时文件名的方法是，做一些像这样的事情：
tempfile=/tmp/$(basename$0).$$.$RANDOM
这将创建一个由程序名字，程序进程的 ID（PID）文件名，和一个随机整数组
成。注意，然而，该 $RANDOM shell变量只能返回一个范围在 1-32767内的整数
值，这在计算机术语中不是一个很大的范围，所以一个单一的该变量实例是不足以
克服一个坚定的攻击者的。
一个比较好的方法是使用 mktemp程序（不要和 mktemp标准库函数相混淆）
来命名和创建临时文件。这个 mktemp程序接受一个用于创建文件名的模板作为参
数。这个模板应该包含一系列的“X”字符，随后这些字符会被相应数量的随机字
母和数字替换掉。一连串的“X”字符越长，则一连串的随机字符也就越长。这里
是一个例子：
tempfile=$(mktemp/tmp/foobar.$$.XXXXXXXXXX)
这里创建了一个临时文件，并把临时文件的名字赋值给变量 tempfile。因为模板
中的“X”字符会被随机字母和数字代替，所以最终的文件名（在这个例子中，文件
名也包含了特殊参数 $$的展开值，进程的 PID）可能像这样：
/tmp/foobar.6593.UOZuvM6654
对于那些由普通用户操作执行的脚本，避免使用 /tmp目录，而是在用户家目录
下为临时文件创建一个目录，通过像这样的一行代码：
500
[[-d$HOME/tmp]]||mkdir$HOME/tmp
37.3异步执行
有时候需要同时执行多个任务。我们已经知道现在所有的操作系统若不是多用户的但至少是多
任务的。脚本也可以构建成多任务处理的模式。
通常这涉及到启动一个脚本，依次，启动一个或多个子脚本来执行额外的任务，而父脚本继
续运行。然而，当一系列脚本以这种方式运行时，要保持父子脚本之间协调工作，会有一些问
题。也就是说，若父脚本或子脚本依赖于另一方，并且一个脚本必须等待另一个脚本结束任务
之后，才能完成它自己的任务，这应该怎么办？
bash有一个内置命令，能帮助管理诸如此类的异步执行的任务。wait命令导致一个父脚本
暂停运行，直到一个特定的进程（例如，子脚本）运行结束。
37.3.1等待
首先我们将演示一下 wait命令的用法。为此，我们需要两个脚本，一个父脚本：
#!/bin/bash
#async-parent:Asynchronousexecutiondemo(parent)
echo"Parent:starting..."
echo"Parent:launchingchildscript..."
async-child&
pid=$!
echo"Parent:child(PID=$pid)launched."
echo"Parent:continuing..."
sleep2
echo"Parent:pausingtowaitforchildtofinish..."
wait$pid
echo"Parent:childisfinished.Continuing..."
echo"Parent:parentisdone.Exiting."
和一个子脚本：
501
#!/bin/bash
#async-child:Asynchronousexecutiondemo(child)
echo"Child:childisrunning..."
sleep5
echo"Child:childisdone.Exiting."
在这个例子中，我们看到该子脚本是非常简单的。真正的操作通过父脚本完成。在父脚本
中，子脚本被启动，并被放置到后台运行。子脚本的进程 ID记录在 pid变量中，这个变量的
值是 $! shell参数的值，它总是包含放到后台执行的最后一个任务的进程 ID号。
父脚本继续，然后执行一个以子进程 PID为参数的 wait命令。这就导致父脚本暂停运行，
直到子脚本退出，父脚本随之结束。
当执行后，父子脚本产生如下输出：
[me@linuxbox~]$async-parent
Parent:starting...
Parent:launchingchildscript...
Parent:child(PID=6741)launched.
Parent:continuing...
Child:childisrunning...
Parent:pausingtowaitforchildtofinish...
Child:childisdone.Exiting.
Parent:childisfinished.Continuing...
Parent:parentisdone.Exiting.
37.4命名管道
在大多数类似 Unix的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管
道用来在两个进程之间建立连接，也可以像其它类型的文件一样使用。虽然它们不是那么流行，
但是它们值得我们去了解。
有一种常见的编程架构，叫做客户端-服务器，它可以利用像命名管道这样的通信方式，也
可以使用其它类型的进程间通信方式，比如网络连接。
最为广泛使用的客户端-服务器系统类型当然是一个 web浏览器与一个 web服务器之间进
行通信。web浏览器作为客户端，向服务器发出请求，服务器响应请求，并把对应的网页发送
502
给浏览器。
命名管道的行为类似于文件，但实际上形成了先入先出（FIFO）的缓冲。和普通（未命令
的）管道一样，数据从一端进入，然后从另一端出现。通过命名管道，有可能像这样设置一些
东西：
process1>named_pipe
和
process2<named_pipe
表现出来就像这样：
process1|process2
37.4.1设置一个命名管道
首先，我们必须创建一个命名管道。使用 mkfifo命令能够创建命名管道：
[me@linuxbox~]$mkfifopipe1
[me@linuxbox~]$ls-lpipe1
prw-r--r--1me
me
02009-07-1706:41pipe1
这里我们使用 mkfifo创建了一个名为 pipe1的命名管道。使用 ls命令，我们查看这个文件，
看到位于属性字段的第一个字母是“p”，表明它是一个命名管道。
37.4.2使用命名管道
为了演示命名管道是如何工作的，我们将需要两个终端窗口（或用两个虚拟控制台代替）。在第
一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道：
503
[me@linuxbox~]$ls-l>pipe1
我们按下 Enter按键之后，命令将会挂起。这是因为在管道的另一端没有任何对象来接收
数据。这种现象被称为管道阻塞。一旦我们绑定一个进程到管道的另一端，该进程开始从管道
中读取输入的时候，管道阻塞现象就不存在了。使用第二个终端窗口，我们输入这个命令：
[me@linuxbox~]$cat<pipe1
然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat命令的输出。在
第一个终端窗口中的 ls命令一旦它不再阻塞，会成功地结束。
37.5总结
嗯，我们已经完成了我们的旅程。现在剩下的唯一要做的事就是练习，练习，再练习。纵然在
我们的长途跋涉中，我们涉及了很多命令，但是就命令行而言，我们只是触及了它的表面。仍
留有成千上万的命令行程序，需要去发现和享受。开始挖掘 /usr/bin目录吧，你将会看到！
37.6拓展阅读
• bash手册页的“复合命令”部分包含了对组命令和子 shell表示法的详尽描述。
• bash手册也的 EXPANSION部分包含了一小部分进程替换的内容：
•《高级 Bash脚本指南》也有对进程替换的讨论：
http://tldp.org/LDP/abs/html/process-sub.html
•《Linux杂志》有两篇关于命名管道的好文章。第一篇，源于 1997年 9月：
http://www.linuxjournal.com/article/2156
•和第二篇，源于 2009年 3月：
http://www.linuxjournal.com/content/using-named-pipes-fifos-bash
504
